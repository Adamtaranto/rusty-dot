{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"rusty-dot","text":"<p>rusty-dot is a Rust + PyO3 tool for making fast dot plot comparisons of DNA sequences using a Rust FM-Index.</p>"},{"location":"#overview","title":"Overview","text":"<p>rusty-dot provides a high-performance toolkit for pairwise DNA sequence comparison and visualisation. At its core, it builds an FM-index (via rust-bio) for each sequence and uses k-mer set intersection to efficiently find shared subsequences between any two sequences in the collection.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Fast FM-index construction via Rust + PyO3 bindings</li> <li>Read FASTA / gzipped FASTA files via needletail</li> <li>Build FM-indexes per sequence using rust-bio</li> <li>K-mer set intersection for efficient shared k-mer lookup</li> <li>Both-strand k-mer matching: forward (<code>+</code>) and reverse-complement (<code>-</code>) hits via <code>compare_sequences_stranded</code></li> <li>Complete RC hit coverage: two patterns merged independently \u2014 anti-diagonal (standard inverted repeat) and co-diagonal (both arms same direction)</li> <li>Unified merge API (<code>py_merge_runs</code>) handles all orientation cases with a single call</li> <li>PAF format output for alignment records</li> <li>FM-index serialization/deserialization with serde + postcard</li> <li>All-vs-all dotplot visualization with matplotlib: forward hits in blue, RC hits in red; edge-only axis labels in grid plots; subpanels scaled by sequence length by default (<code>scale_sequences=True</code>)</li> <li>SVG vector output via the <code>format</code> parameter (<code>format='svg'</code>) or by using a <code>.svg</code> file extension \u2014 suitable for publication-quality figures</li> <li>Minimum alignment length filter (<code>min_length</code>) on <code>DotPlotter.plot()</code> / <code>plot_single()</code> \u2014 suppresses short or spurious alignment hits before rendering</li> <li>Identity-based alignment colouring \u2014 when alignments are loaded from a PAF file, pass <code>color_by_identity=True</code> to colour each segment by <code>residue_matches / alignment_block_len</code> using any Matplotlib colormap (<code>identity_palette</code>); <code>DotPlotter.plot_identity_colorbar()</code> renders the scale as a standalone figure</li> <li><code>CrossIndex</code> multi-group cross-index: N arbitrary sequence groups, configurable group pairs for alignment, per-group contig ordering (insertion order, length, or collinearity), <code>run_merge</code> to update cached PAF records, compatible with <code>DotPlotter</code></li> <li><code>PafAlignment.filter_by_min_length()</code> \u2014 discard short alignment records from a loaded PAF file; filters on query aligned length</li> <li>Full Python bindings via PyO3</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n\n# Build index for two sequences\nidx = SequenceIndex(k=15)\nidx.load_fasta(\"genome1.fasta\")\nidx.load_fasta(\"genome2.fasta\")\n\n# Get PAF-format alignments (forward strand only)\nfor line in idx.get_paf(\"seq1\", \"seq2\"):\n    print(line)\n\n# Stranded comparison: forward (+) and reverse-complement (-) hits\nhits = idx.compare_sequences_stranded(\"seq1\", \"seq2\", merge=True)\nfor qs, qe, ts, te, strand in hits:\n    print(f\"{strand}  q[{qs}:{qe}]  t[{ts}:{te}]\")\n\n# Generate dotplot \u2014 forward hits blue, RC hits red\nplotter = DotPlotter(idx)\nplotter.plot(output_path=\"dotplot.png\")\n\n# Save as SVG vector image\nplotter.plot(output_path=\"dotplot.svg\")\n\n# Filter short alignments (&lt; 200 bp) before plotting\nplotter.plot(output_path=\"dotplot_filtered.png\", min_length=200)\n\n# Colour alignments by identity from a PAF file\nfrom rusty_dot.paf_io import PafAlignment\naln = PafAlignment.from_file(\"alignments.paf\")\nplotter = DotPlotter(idx, paf_alignment=aln)\nplotter.plot(output_path=\"identity_dotplot.png\", color_by_identity=True, identity_palette=\"viridis\")\nplotter.plot_identity_colorbar(palette=\"viridis\", output_path=\"colorbar.png\")\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Installation \u2014 how to install rusty-dot and its dependencies.</li> <li>Tutorials \u2014 step-by-step Jupyter notebook walkthroughs.</li> <li>API Reference \u2014 full documentation for all classes and functions.</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This page explains how to set up a local development environment for rusty-dot so you can edit both the Rust extension and the Python package and run the full test suite.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":""},{"location":"development/#install-rust","title":"Install Rust","text":"<p>rusty-dot requires a working Rust toolchain (stable channel). Install it with rustup:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource $HOME/.cargo/env\nrustup update stable\n</code></pre> <p>Verify the installation:</p> <pre><code>rustc --version\ncargo --version\n</code></pre>"},{"location":"development/#create-a-conda-environment","title":"Create a conda environment","text":"<p>A minimal conda environment file is provided at <code>environment.yml</code>. It pins Python to 3.13 and installs the key Python dependencies.</p> <pre><code>conda env create -f environment.yml\nconda activate rustydot\n</code></pre> <p>Alternatively, use any Python \u2265 3.9 virtual environment:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate   # Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"development/#fork-and-clone-the-repository","title":"Fork and clone the repository","text":"<p>Fork rusty-dot on GitHub, then clone your fork:</p> <pre><code>git clone https://github.com/&lt;your-username&gt;/rusty-dot.git\ncd rusty-dot\ngit remote add upstream https://github.com/Adamtaranto/rusty-dot.git\n</code></pre>"},{"location":"development/#install-in-development-mode","title":"Install in development mode","text":"<p>maturin is the build backend for the Rust extension. Install it and then build the package in editable mode:</p> <pre><code>pip install maturin\n# Build Rust extension + install package in editable mode\nmaturin develop --extras dev,docs\n</code></pre> <p>The <code>--extras dev,docs</code> flag installs all optional development and documentation dependencies declared in <code>pyproject.toml</code>.</p> <p>Verify the install:</p> <pre><code>import rusty_dot\nprint(rusty_dot.__version__)\n</code></pre> <p>Note</p> <p>Always re-run <code>maturin develop</code> after modifying any Rust source files (<code>src/*.rs</code>). Pure Python changes in <code>python/rusty_dot/</code> take effect immediately without a rebuild.</p>"},{"location":"development/#installing-pre-commit-hooks","title":"Installing pre-commit hooks","text":"<p>rusty-dot uses pre-commit to enforce code quality on every commit. Install the hooks once after cloning:</p> <pre><code>pip install pre-commit   # already included in the dev extras\npre-commit install                 # install commit-stage hooks\npre-commit install --hook-type pre-push   # install push-stage hooks\n</code></pre> <p>The hooks include:</p> Hook Stage What it checks <code>check-ast</code> / <code>check-yaml</code> / <code>check-toml</code> commit File syntax <code>trailing-whitespace</code> / <code>end-of-file-fixer</code> commit Whitespace <code>cargo fmt --check</code> commit Rust formatting <code>cargo check</code> commit Rust compilation <code>cargo clippy -- -D warnings</code> commit Rust linting <code>ruff format</code> / <code>ruff check</code> commit Python formatting &amp; linting <code>pydocstyle</code> (<code>.pyi</code> stubs only) commit Docstring style <code>cargo test --lib</code> push Rust unit tests <code>pytest tests/ -x -q</code> push Python test suite <p>Run all hooks manually at any time:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"development/#running-python-tests","title":"Running Python tests","text":"<pre><code>pytest tests/ -v\n</code></pre> <p>To run a specific test file or test function:</p> <pre><code>pytest tests/test_index.py -v\npytest tests/test_index.py::test_get_paf_all_returns_paf_lines -v\n</code></pre>"},{"location":"development/#python-code-style-ruff","title":"Python code style \u2014 ruff","text":"<p>rusty-dot uses ruff for Python linting and formatting (configured in <code>pyproject.toml</code>).</p> <p>Check for issues:</p> <pre><code>ruff check python/ tests/\n</code></pre> <p>Auto-fix fixable issues:</p> <pre><code>ruff check --fix python/ tests/\n</code></pre> <p>Format code:</p> <pre><code>ruff format python/ tests/\n</code></pre>"},{"location":"development/#rust-code-quality","title":"Rust code quality","text":""},{"location":"development/#format","title":"Format","text":"<pre><code>cargo fmt\n</code></pre> <p>Check formatting without modifying files (also used by the pre-commit hook):</p> <pre><code>cargo fmt --all -- --check\n</code></pre>"},{"location":"development/#lint-clippy","title":"Lint (Clippy)","text":"<pre><code>cargo clippy -- -D warnings\n</code></pre>"},{"location":"development/#compile-check","title":"Compile check","text":"<p>Quickly verify the crate compiles without producing a binary:</p> <pre><code>cargo check\n</code></pre>"},{"location":"development/#rust-unit-tests","title":"Rust unit tests","text":"<p>Run the Rust-side library tests:</p> <pre><code>cargo test --lib\n</code></pre> <p>Run all Rust tests (including integration tests, if any):</p> <pre><code>cargo test\n</code></pre>"},{"location":"development/#building-the-documentation-locally","title":"Building the documentation locally","text":"<p>Install the docs dependencies (included in <code>pip install maturin --extras dev,docs</code>):</p> <pre><code>mkdocs serve\n</code></pre> <p>Open http://127.0.0.1:8000 in your browser. The site rebuilds automatically when you save a documentation file.</p> <p>To build a static site:</p> <pre><code>mkdocs build\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or later</li> <li>A working Rust toolchain (for building from source)</li> <li>maturin \u2265 1.0</li> </ul>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<p>Clone the repository and build the Rust extension with maturin:</p> <pre><code>git clone https://github.com/Adamtaranto/rusty-dot.git\ncd rusty-dot\npip install maturin\nmaturin develop --release\n</code></pre> <p>The <code>--release</code> flag enables full Rust compiler optimisations, which is strongly recommended for any non-trivial dataset.</p>"},{"location":"installation/#install-python-dependencies","title":"Install Python dependencies","text":"<p>rusty-dot depends on:</p> Package Purpose <code>matplotlib \u2265 3.5</code> Dotplot visualisation <code>numpy \u2265 1.21</code> Array operations used by matplotlib <p>These are declared as package dependencies and will be installed automatically by pip.</p>"},{"location":"installation/#optional-documentation-dependencies","title":"Optional: documentation dependencies","text":"<p>To build the documentation locally:</p> <pre><code>pip install rusty-dot[docs]\nmkdocs serve\n</code></pre>"},{"location":"installation/#verify-the-installation","title":"Verify the installation","text":"<pre><code>import rusty_dot\nprint(rusty_dot.__version__)  # 0.1.0\n\nfrom rusty_dot import SequenceIndex\nidx = SequenceIndex(k=10)\nidx.add_sequence(\"test\", \"ACGTACGTACGT\")\nprint(idx)  # SequenceIndex(k=10, sequences=1)\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>rusty-dot exposes its functionality through the following classes and functions.</p>"},{"location":"api/#classes","title":"Classes","text":"Class Module Description <code>SequenceIndex</code> <code>rusty_dot</code> Rust-backed FM-index for sequence comparison <code>DotPlotter</code> <code>rusty_dot.dotplot</code> All-vs-all dotplot visualisation <code>CrossIndex</code> <code>rusty_dot.paf_io</code> Multi-group cross-index for cross-group pairwise comparisons; DotPlotter-compatible <code>PafRecord</code> <code>rusty_dot.paf_io</code> Single PAF alignment record <code>PafAlignment</code> <code>rusty_dot.paf_io</code> Collection of PAF records with reordering utilities; DotPlotter-compatible"},{"location":"api/#functions","title":"Functions","text":"Function Module Description <code>py_read_fasta</code> <code>rusty_dot</code> Read a FASTA or gzipped FASTA file <code>py_build_kmer_set</code> <code>rusty_dot</code> Build the k-mer set for a sequence <code>py_find_kmer_coords</code> <code>rusty_dot</code> Find k-mer positions in a sequence via FM-index <code>py_merge_runs</code> <code>rusty_dot</code> Unified strand-aware merge: forward and both RC patterns <code>py_merge_kmer_runs</code> <code>rusty_dot</code> Merge forward-strand (<code>+</code>) co-linear k-mer hits into blocks <code>py_merge_rev_runs</code> <code>rusty_dot</code> Merge RC anti-diagonal k-mer hits (standard inverted repeat) <code>py_merge_rev_fwd_runs</code> <code>rusty_dot</code> Merge RC co-diagonal k-mer hits (both arms same direction) <code>py_coords_to_paf</code> <code>rusty_dot</code> Convert coordinate tuples to PAF lines <code>py_save_index</code> <code>rusty_dot</code> Serialise an index collection to disk <code>py_load_index</code> <code>rusty_dot</code> Load a serialised index from disk <code>parse_paf_file</code> <code>rusty_dot.paf_io</code> Yield PAF records from a file <code>compute_gravity_contigs</code> <code>rusty_dot.paf_io</code> Sort contigs by gravity centre"},{"location":"api/cross_index/","title":"CrossIndex","text":"<p><code>CrossIndex</code> manages sequences divided into named groups and computes cross-group pairwise comparisons.  It is compatible with :class:<code>~rusty_dot.dotplot.DotPlotter</code>.</p>"},{"location":"api/cross_index/#alignment-scope-by-number-of-groups","title":"Alignment scope by number of groups","text":"<ul> <li>2 groups \u2014 alignments between the two groups only.</li> <li>3+ groups \u2014 all non-self ordered pairs of groups.   Use the <code>group_pairs</code> argument of <code>get_paf</code> to restrict to specific pairs.</li> </ul>"},{"location":"api/cross_index/#dotplotter-usage","title":"DotPlotter usage","text":"<pre><code>from rusty_dot.paf_io import CrossIndex\nfrom rusty_dot.dotplot import DotPlotter\n\ncross = CrossIndex(k=15)\ncross.load_fasta(\"assembly_a.fasta\", group=\"a\")\ncross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\nplotter = DotPlotter(cross)\nplotter.plot(\n    query_names=cross.sequence_names(group=\"a\"),\n    target_names=cross.sequence_names(group=\"b\"),\n    output_path=\"cross_plot.png\",\n)\n</code></pre>"},{"location":"api/cross_index/#class","title":"Class","text":""},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex","title":"<code>CrossIndex</code>","text":"<p>Multi-group sequence index for cross-group pairwise comparisons.</p> <p>Sequences are organised into named groups (e.g. <code>'assembly_a'</code>, <code>'assembly_b'</code>).  Each sequence is stored in a shared :class:<code>~rusty_dot.SequenceIndex</code> under a <code>group:name</code> internal key, which keeps names unique even when the same sequence identifier appears in multiple groups.</p> <p>Alignment scope by number of groups</p> <ul> <li>2 groups \u2014 alignments are computed between the two groups only.</li> <li>3+ groups \u2014 alignments are computed for every non-self ordered pair   of groups.  Use the group_pairs argument of :meth:<code>get_paf</code> to   restrict to specific pairs.</li> </ul> <p>DotPlotter compatibility</p> <p><code>CrossIndex</code> exposes :meth:<code>get_sequence_length</code>, :meth:<code>compare_sequences_stranded</code>, and :meth:<code>sequence_names</code> so that it can be passed directly to :class:<code>~rusty_dot.dotplot.DotPlotter</code>::</p> <pre><code>cross = CrossIndex(k=15)\ncross.load_fasta(\"assembly_a.fasta\", group=\"a\")\ncross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\nfrom rusty_dot.dotplot import DotPlotter\nplotter = DotPlotter(cross)\nplotter.plot(\n    query_names=cross.sequence_names(group=\"a\"),\n    target_names=cross.sequence_names(group=\"b\"),\n    output_path=\"cross_plot.png\",\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>K-mer length to use for indexing and comparison.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rusty_dot.paf_io import CrossIndex\n&gt;&gt;&gt; cross = CrossIndex(k=10)\n&gt;&gt;&gt; cross.load_fasta(\"genome_a.fasta\", group=\"a\")\n&gt;&gt;&gt; cross.load_fasta(\"genome_b.fasta\", group=\"b\")\n&gt;&gt;&gt; paf_lines = cross.get_paf()\n</code></pre> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>class CrossIndex:\n    \"\"\"Multi-group sequence index for cross-group pairwise comparisons.\n\n    Sequences are organised into named groups (e.g. ``'assembly_a'``,\n    ``'assembly_b'``).  Each sequence is stored in a shared\n    :class:`~rusty_dot.SequenceIndex` under a ``group:name`` internal key,\n    which keeps names unique even when the same sequence identifier appears\n    in multiple groups.\n\n    **Alignment scope by number of groups**\n\n    * **2 groups** \u2014 alignments are computed between the two groups only.\n    * **3+ groups** \u2014 alignments are computed for every non-self ordered pair\n      of groups.  Use the *group_pairs* argument of :meth:`get_paf` to\n      restrict to specific pairs.\n\n    **DotPlotter compatibility**\n\n    ``CrossIndex`` exposes :meth:`get_sequence_length`,\n    :meth:`compare_sequences_stranded`, and :meth:`sequence_names` so that it\n    can be passed directly to :class:`~rusty_dot.dotplot.DotPlotter`::\n\n        cross = CrossIndex(k=15)\n        cross.load_fasta(\"assembly_a.fasta\", group=\"a\")\n        cross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\n        from rusty_dot.dotplot import DotPlotter\n        plotter = DotPlotter(cross)\n        plotter.plot(\n            query_names=cross.sequence_names(group=\"a\"),\n            target_names=cross.sequence_names(group=\"b\"),\n            output_path=\"cross_plot.png\",\n        )\n\n    Parameters\n    ----------\n    k : int\n        K-mer length to use for indexing and comparison.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from rusty_dot.paf_io import CrossIndex\n    &gt;&gt;&gt; cross = CrossIndex(k=10)\n    &gt;&gt;&gt; cross.load_fasta(\"genome_a.fasta\", group=\"a\")\n    &gt;&gt;&gt; cross.load_fasta(\"genome_b.fasta\", group=\"b\")\n    &gt;&gt;&gt; paf_lines = cross.get_paf()\n    \"\"\"\n\n    def __init__(self, k: int) -&gt; None:\n        \"\"\"Initialise an empty CrossIndex.\n\n        Parameters\n        ----------\n        k : int\n            K-mer length to use when building the sequence index.\n        \"\"\"\n        self._k: int = k\n        self._index: SequenceIndex = SequenceIndex(k=k)\n        # group_label -&gt; ordered list of original (un-prefixed) sequence names\n        self._groups: dict[str, list[str]] = {}\n        # Cached PAF records from the last :meth:`run_merge` call\n        self._paf_records: list[PafRecord] = []\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n\n    @staticmethod\n    def _make_internal(group: str, name: str) -&gt; str:\n        \"\"\"Format an internal (prefixed) name for use in SequenceIndex.\"\"\"\n        return f'{group}:{name}'\n\n    @staticmethod\n    def _split_internal(internal: str) -&gt; tuple[str, str]:\n        \"\"\"Split ``'group:name'`` into ``(group, name)``.\"\"\"\n        group, _, name = internal.partition(':')\n        return group, name\n\n    # ------------------------------------------------------------------\n    # Adding sequences\n    # ------------------------------------------------------------------\n\n    def add_sequence(self, name: str, seq: str, group: str = 'a') -&gt; None:\n        \"\"\"Add a single sequence to the specified group.\n\n        Parameters\n        ----------\n        name : str\n            Sequence identifier (must be unique within the group).\n        seq : str\n            DNA sequence string.\n        group : str, optional\n            Group label.  Any non-empty string is accepted; ``':'`` is\n            forbidden because it is used as an internal separator.\n            Default is ``'a'``.\n\n        Raises\n        ------\n        ValueError\n            If *group* contains ``':'``.\n        \"\"\"\n        if ':' in group:\n            raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n        internal = self._make_internal(group, name)\n        self._index.add_sequence(internal, seq)\n        if group not in self._groups:\n            self._groups[group] = []\n        self._groups[group].append(name)\n\n    def load_fasta(self, path: str, group: str = 'a') -&gt; list[str]:\n        \"\"\"Load sequences from a FASTA file into the specified group.\n\n        Parameters\n        ----------\n        path : str\n            Path to a FASTA (``.fa`` / ``.fasta``) or gzipped FASTA file.\n        group : str, optional\n            Group label.  Default is ``'a'``.\n\n        Returns\n        -------\n        list[str]\n            The original (un-prefixed) sequence names that were loaded, in\n            file order.\n\n        Raises\n        ------\n        ValueError\n            If *group* contains ``':'``, or if the file cannot be parsed, or\n            if the FASTA file contains duplicate sequence names.\n        \"\"\"\n        if ':' in group:\n            raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n        from rusty_dot._rusty_dot import py_read_fasta\n\n        seqs = py_read_fasta(path)\n        if group not in self._groups:\n            self._groups[group] = []\n        names: list[str] = []\n        for name, seq in seqs.items():\n            internal = self._make_internal(group, name)\n            self._index.add_sequence(internal, seq)\n            self._groups[group].append(name)\n            names.append(name)\n        return names\n\n    # ------------------------------------------------------------------\n    # Properties and name helpers\n    # ------------------------------------------------------------------\n\n    @property\n    def group_names(self) -&gt; list[str]:\n        \"\"\"Return the list of group labels in insertion order.\n\n        Returns\n        -------\n        list[str]\n            Group labels.\n        \"\"\"\n        return list(self._groups.keys())\n\n    def sequence_names(self, group: str | None = None) -&gt; list[str]:\n        \"\"\"Return internal (``group:name``) identifiers suitable for DotPlotter.\n\n        Parameters\n        ----------\n        group : str or None, optional\n            If given, return only names from that group.  If ``None``\n            (default), return names from all groups.\n\n        Returns\n        -------\n        list[str]\n            Internal ``group:name`` strings in current :attr:`contig_order`.\n        \"\"\"\n        if group is not None:\n            return [self._make_internal(group, n) for n in self._groups.get(group, [])]\n        result: list[str] = []\n        for g, names in self._groups.items():\n            result.extend(self._make_internal(g, n) for n in names)\n        return result\n\n    @property\n    def contig_order(self) -&gt; dict[str, list[str]]:\n        \"\"\"Current contig order per group as original (un-prefixed) names.\n\n        Returns\n        -------\n        dict[str, list[str]]\n            Mapping of group label \u2192 ordered list of sequence names.\n            Updated in-place by :meth:`reorder_by_length` and\n            :meth:`reorder_for_colinearity`.\n        \"\"\"\n        return {g: list(names) for g, names in self._groups.items()}\n\n    # ------------------------------------------------------------------\n    # Backward-compatible properties (two-group a/b model)\n    # ------------------------------------------------------------------\n\n    @property\n    def query_names(self) -&gt; list[str]:\n        \"\"\"Un-prefixed names for group ``'a'`` (backward compatible).\n\n        Returns\n        -------\n        list[str]\n        \"\"\"\n        return list(self._groups.get('a', []))\n\n    @property\n    def target_names(self) -&gt; list[str]:\n        \"\"\"Un-prefixed names for group ``'b'`` (backward compatible).\n\n        Returns\n        -------\n        list[str]\n        \"\"\"\n        return list(self._groups.get('b', []))\n\n    # ------------------------------------------------------------------\n    # DotPlotter-compatible interface\n    # ------------------------------------------------------------------\n\n    def get_sequence_length(self, name: str) -&gt; int:\n        \"\"\"Return the length of the sequence identified by its internal name.\n\n        Parameters\n        ----------\n        name : str\n            Internal (``group:name``) identifier.\n\n        Returns\n        -------\n        int\n            Sequence length in bases.\n        \"\"\"\n        return self._index.get_sequence_length(name)\n\n    def compare_sequences_stranded(\n        self, name1: str, name2: str, merge: bool = True\n    ) -&gt; list:\n        \"\"\"Compare two sequences by their internal names, returning stranded matches.\n\n        Parameters\n        ----------\n        name1 : str\n            Internal name of the query sequence.\n        name2 : str\n            Internal name of the target sequence.\n        merge : bool, optional\n            Whether to merge consecutive co-linear k-mer runs.\n            Default is ``True``.\n\n        Returns\n        -------\n        list of (int, int, int, int, str)\n            List of ``(query_start, query_end, target_start, target_end, strand)``\n            tuples.\n        \"\"\"\n        return self._index.compare_sequences_stranded(name1, name2, merge)\n\n    # ------------------------------------------------------------------\n    # Contig reordering\n    # ------------------------------------------------------------------\n\n    def reorder_by_length(self, group: str | None = None) -&gt; None:\n        \"\"\"Reorder contigs within one or all groups by descending sequence length.\n\n        Updates :attr:`contig_order` in-place.\n\n        Parameters\n        ----------\n        group : str or None, optional\n            Group to reorder.  If ``None`` (default), all groups are reordered.\n        \"\"\"\n        groups_to_sort = [group] if group is not None else list(self._groups.keys())\n        for g in groups_to_sort:\n            self._groups[g].sort(\n                key=lambda n: self._index.get_sequence_length(\n                    self._make_internal(g, n)\n                ),\n                reverse=True,\n            )\n\n    def reorder_for_colinearity(self, query_group: str, target_group: str) -&gt; None:\n        \"\"\"Reorder sequences in two groups to maximise dotplot collinearity.\n\n        Uses the gravity-centre algorithm via\n        :meth:`~rusty_dot.SequenceIndex.optimal_contig_order`.  Updates\n        :attr:`contig_order` in-place for both groups.\n\n        Parameters\n        ----------\n        query_group : str\n            Group label for the query (y-axis / rows).\n        target_group : str\n            Group label for the target (x-axis / columns).\n\n        Raises\n        ------\n        KeyError\n            If either group label is not present in the index.\n        \"\"\"\n        q_internal = [\n            self._make_internal(query_group, n) for n in self._groups[query_group]\n        ]\n        t_internal = [\n            self._make_internal(target_group, n) for n in self._groups[target_group]\n        ]\n        sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n            q_internal, t_internal\n        )\n        self._groups[query_group] = [self._split_internal(n)[1] for n in sorted_q_int]\n        self._groups[target_group] = [self._split_internal(n)[1] for n in sorted_t_int]\n\n    # ------------------------------------------------------------------\n    # PAF output\n    # ------------------------------------------------------------------\n\n    def _get_default_group_pairs(self) -&gt; list[tuple[str, str]]:\n        \"\"\"Return default group pairs for alignment.\n\n        * 2 groups \u2192 one pair between the two groups.\n        * 3+ groups \u2192 all non-self ordered pairs.\n        \"\"\"\n        groups = list(self._groups.keys())\n        if len(groups) == 2:\n            return [(groups[0], groups[1])]\n        return [\n            (a, b) for i, a in enumerate(groups) for j, b in enumerate(groups) if i != j\n        ]\n\n    def get_paf(\n        self,\n        group_pairs: list[tuple[str, str]] | None = None,\n        merge: bool = True,\n    ) -&gt; list[str]:\n        \"\"\"Return PAF lines for cross-group sequence comparisons.\n\n        Parameters\n        ----------\n        group_pairs : list of (str, str) or None, optional\n            Explicit list of ``(query_group, target_group)`` pairs to compare.\n            If ``None`` (default):\n\n            * 2 groups \u2192 the single cross-group pair.\n            * 3+ groups \u2192 all non-self ordered pairs.\n        merge : bool, optional\n            Whether to merge consecutive co-linear k-mer runs before\n            generating PAF lines.  Default is ``True``.\n\n        Returns\n        -------\n        list[str]\n            PAF-formatted lines (12 tab-separated columns each).\n        \"\"\"\n        if group_pairs is None:\n            group_pairs = self._get_default_group_pairs()\n\n        paf_lines: list[str] = []\n        for query_group, target_group in group_pairs:\n            _log.info(\n                'CrossIndex: computing %d x %d pairwise alignments '\n                'between group %r (%d sequences) and group %r (%d sequences)',\n                len(self._groups.get(query_group, [])),\n                len(self._groups.get(target_group, [])),\n                query_group,\n                len(self._groups.get(query_group, [])),\n                target_group,\n                len(self._groups.get(target_group, [])),\n            )\n            for q_orig in self._groups.get(query_group, []):\n                for t_orig in self._groups.get(target_group, []):\n                    q_int = self._make_internal(query_group, q_orig)\n                    t_int = self._make_internal(target_group, t_orig)\n                    lines = self._index.get_paf(q_int, t_int, merge)\n                    for line in lines:\n                        fields = line.split('\\t')\n                        fields[0] = q_orig\n                        fields[5] = t_orig\n                        paf_lines.append('\\t'.join(fields))\n        return paf_lines\n\n    def run_merge(\n        self,\n        group_pairs: list[tuple[str, str]] | None = None,\n    ) -&gt; None:\n        \"\"\"Compute merged alignments and store the result as :attr:`_paf_records`.\n\n        Runs :meth:`get_paf` with ``merge=True`` and populates\n        ``self._paf_records`` so that the results can be inspected or passed\n        to a :class:`PafAlignment`.\n\n        Parameters\n        ----------\n        group_pairs : list of (str, str) or None, optional\n            Group pairs to compare (same semantics as :meth:`get_paf`).\n            Defaults to all cross-group pairs.\n        \"\"\"\n        paf_lines = self.get_paf(group_pairs=group_pairs, merge=True)\n        self._paf_records = [PafRecord.from_line(line) for line in paf_lines]\n\n    # ------------------------------------------------------------------\n    # Backward-compatible API (two-group a/b model)\n    # ------------------------------------------------------------------\n\n    def get_paf_all(self, merge: bool = True) -&gt; list[str]:\n        \"\"\"Return PAF lines for all cross-group comparisons.\n\n        Backward-compatible wrapper around :meth:`get_paf`.  When a group\n        ``'b'`` is present, computes ``a`` vs ``b`` alignments; otherwise\n        performs all-vs-all within group ``'a'``.\n\n        Parameters\n        ----------\n        merge : bool, optional\n            Whether to merge consecutive co-linear k-mer runs.\n            Default is ``True``.\n\n        Returns\n        -------\n        list[str]\n            PAF-formatted lines.\n        \"\"\"\n        if 'b' in self._groups and self._groups['b']:\n            return self.get_paf(group_pairs=[('a', 'b')], merge=merge)\n        # Single group or no group 'b': all-vs-all within group 'a'\n        names_a = self._groups.get('a', [])\n        _log.info(\n            'CrossIndex: computing all-vs-all pairwise alignments '\n            'within group a (%d sequences)',\n            len(names_a),\n        )\n        paf_lines: list[str] = []\n        for i, q_orig in enumerate(names_a):\n            for j, t_orig in enumerate(names_a):\n                if i == j:\n                    continue\n                q_int = self._make_internal('a', q_orig)\n                t_int = self._make_internal('a', t_orig)\n                lines = self._index.get_paf(q_int, t_int, merge)\n                for line in lines:\n                    fields = line.split('\\t')\n                    fields[0] = q_orig\n                    fields[5] = t_orig\n                    paf_lines.append('\\t'.join(fields))\n        return paf_lines\n\n    def reorder_contigs(\n        self,\n        query_names: list[str] | None = None,\n        target_names: list[str] | None = None,\n    ) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Sort contigs for maximum collinearity (backward-compatible, requires groups a and b).\n\n        Parameters\n        ----------\n        query_names : list[str] or None, optional\n            Original (un-prefixed) names for group ``'a'`` to reorder.\n            Defaults to all group-a sequences.\n        target_names : list[str] or None, optional\n            Original (un-prefixed) names for group ``'b'`` to reorder.\n            Defaults to all group-b sequences.\n\n        Returns\n        -------\n        tuple[list[str], list[str]]\n            ``(sorted_query_names, sorted_target_names)`` \u2014 both using original\n            un-prefixed names.\n\n        Raises\n        ------\n        ValueError\n            If group ``'b'`` is empty.  Use :meth:`reorder_for_colinearity` for\n            explicit group names.\n        \"\"\"\n        if 'b' not in self._groups or not self._groups['b']:\n            raise ValueError(\n                \"reorder_contigs requires group 'b' sequences; \"\n                'use reorder_for_colinearity for explicit group names.'\n            )\n        q_names = (\n            query_names if query_names is not None else list(self._groups.get('a', []))\n        )\n        t_names = (\n            target_names\n            if target_names is not None\n            else list(self._groups.get('b', []))\n        )\n        q_internal = [self._make_internal('a', n) for n in q_names]\n        t_internal = [self._make_internal('b', n) for n in t_names]\n        sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n            q_internal, t_internal\n        )\n        sorted_q = [self._split_internal(n)[1] for n in sorted_q_int]\n        sorted_t = [self._split_internal(n)[1] for n in sorted_t_int]\n        return sorted_q, sorted_t\n\n    # ------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise machine-readable representation.\n\n        Returns\n        -------\n        str\n            ``CrossIndex(k=&lt;k&gt;, groups={&lt;label&gt;=&lt;n&gt;, ...})``.\n        \"\"\"\n        group_info = ', '.join(f'{g}={len(names)}' for g, names in self._groups.items())\n        return f'CrossIndex(k={self._k}, groups={{{group_info}}})'\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a human-readable stats summary.\n\n        Returns\n        -------\n        str\n            Multi-line summary of groups, sequence counts, and cached PAF\n            record count.\n        \"\"\"\n        n_total = sum(len(v) for v in self._groups.values())\n        lines = [f'CrossIndex (k={self._k})']\n        lines.append(f'  Total sequences : {n_total}')\n        for g, names in self._groups.items():\n            lines.append(f'  Group {g!r:12s}: {len(names):&gt;6d} sequences')\n        lines.append(f'  PAF records     : {len(self._paf_records)}')\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex-attributes","title":"Attributes","text":""},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.group_names","title":"<code>group_names</code>  <code>property</code>","text":"<p>Return the list of group labels in insertion order.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Group labels.</p>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.contig_order","title":"<code>contig_order</code>  <code>property</code>","text":"<p>Current contig order per group as original (un-prefixed) names.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of group label \u2192 ordered list of sequence names. Updated in-place by :meth:<code>reorder_by_length</code> and :meth:<code>reorder_for_colinearity</code>.</p>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.query_names","title":"<code>query_names</code>  <code>property</code>","text":"<p>Un-prefixed names for group <code>'a'</code> (backward compatible).</p> <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.target_names","title":"<code>target_names</code>  <code>property</code>","text":"<p>Un-prefixed names for group <code>'b'</code> (backward compatible).</p> <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex-functions","title":"Functions","text":""},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.__init__","title":"<code>__init__(k)</code>","text":"<p>Initialise an empty CrossIndex.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>K-mer length to use when building the sequence index.</p> required Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __init__(self, k: int) -&gt; None:\n    \"\"\"Initialise an empty CrossIndex.\n\n    Parameters\n    ----------\n    k : int\n        K-mer length to use when building the sequence index.\n    \"\"\"\n    self._k: int = k\n    self._index: SequenceIndex = SequenceIndex(k=k)\n    # group_label -&gt; ordered list of original (un-prefixed) sequence names\n    self._groups: dict[str, list[str]] = {}\n    # Cached PAF records from the last :meth:`run_merge` call\n    self._paf_records: list[PafRecord] = []\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.add_sequence","title":"<code>add_sequence(name, seq, group='a')</code>","text":"<p>Add a single sequence to the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Sequence identifier (must be unique within the group).</p> required <code>seq</code> <code>str</code> <p>DNA sequence string.</p> required <code>group</code> <code>str</code> <p>Group label.  Any non-empty string is accepted; <code>':'</code> is forbidden because it is used as an internal separator. Default is <code>'a'</code>.</p> <code>'a'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If group contains <code>':'</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def add_sequence(self, name: str, seq: str, group: str = 'a') -&gt; None:\n    \"\"\"Add a single sequence to the specified group.\n\n    Parameters\n    ----------\n    name : str\n        Sequence identifier (must be unique within the group).\n    seq : str\n        DNA sequence string.\n    group : str, optional\n        Group label.  Any non-empty string is accepted; ``':'`` is\n        forbidden because it is used as an internal separator.\n        Default is ``'a'``.\n\n    Raises\n    ------\n    ValueError\n        If *group* contains ``':'``.\n    \"\"\"\n    if ':' in group:\n        raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n    internal = self._make_internal(group, name)\n    self._index.add_sequence(internal, seq)\n    if group not in self._groups:\n        self._groups[group] = []\n    self._groups[group].append(name)\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.load_fasta","title":"<code>load_fasta(path, group='a')</code>","text":"<p>Load sequences from a FASTA file into the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a FASTA (<code>.fa</code> / <code>.fasta</code>) or gzipped FASTA file.</p> required <code>group</code> <code>str</code> <p>Group label.  Default is <code>'a'</code>.</p> <code>'a'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The original (un-prefixed) sequence names that were loaded, in file order.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If group contains <code>':'</code>, or if the file cannot be parsed, or if the FASTA file contains duplicate sequence names.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def load_fasta(self, path: str, group: str = 'a') -&gt; list[str]:\n    \"\"\"Load sequences from a FASTA file into the specified group.\n\n    Parameters\n    ----------\n    path : str\n        Path to a FASTA (``.fa`` / ``.fasta``) or gzipped FASTA file.\n    group : str, optional\n        Group label.  Default is ``'a'``.\n\n    Returns\n    -------\n    list[str]\n        The original (un-prefixed) sequence names that were loaded, in\n        file order.\n\n    Raises\n    ------\n    ValueError\n        If *group* contains ``':'``, or if the file cannot be parsed, or\n        if the FASTA file contains duplicate sequence names.\n    \"\"\"\n    if ':' in group:\n        raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n    from rusty_dot._rusty_dot import py_read_fasta\n\n    seqs = py_read_fasta(path)\n    if group not in self._groups:\n        self._groups[group] = []\n    names: list[str] = []\n    for name, seq in seqs.items():\n        internal = self._make_internal(group, name)\n        self._index.add_sequence(internal, seq)\n        self._groups[group].append(name)\n        names.append(name)\n    return names\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.sequence_names","title":"<code>sequence_names(group=None)</code>","text":"<p>Return internal (<code>group:name</code>) identifiers suitable for DotPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str or None</code> <p>If given, return only names from that group.  If <code>None</code> (default), return names from all groups.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Internal <code>group:name</code> strings in current :attr:<code>contig_order</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def sequence_names(self, group: str | None = None) -&gt; list[str]:\n    \"\"\"Return internal (``group:name``) identifiers suitable for DotPlotter.\n\n    Parameters\n    ----------\n    group : str or None, optional\n        If given, return only names from that group.  If ``None``\n        (default), return names from all groups.\n\n    Returns\n    -------\n    list[str]\n        Internal ``group:name`` strings in current :attr:`contig_order`.\n    \"\"\"\n    if group is not None:\n        return [self._make_internal(group, n) for n in self._groups.get(group, [])]\n    result: list[str] = []\n    for g, names in self._groups.items():\n        result.extend(self._make_internal(g, n) for n in names)\n    return result\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.get_sequence_length","title":"<code>get_sequence_length(name)</code>","text":"<p>Return the length of the sequence identified by its internal name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Internal (<code>group:name</code>) identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Sequence length in bases.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_sequence_length(self, name: str) -&gt; int:\n    \"\"\"Return the length of the sequence identified by its internal name.\n\n    Parameters\n    ----------\n    name : str\n        Internal (``group:name``) identifier.\n\n    Returns\n    -------\n    int\n        Sequence length in bases.\n    \"\"\"\n    return self._index.get_sequence_length(name)\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.compare_sequences_stranded","title":"<code>compare_sequences_stranded(name1, name2, merge=True)</code>","text":"<p>Compare two sequences by their internal names, returning stranded matches.</p> <p>Parameters:</p> Name Type Description Default <code>name1</code> <code>str</code> <p>Internal name of the query sequence.</p> required <code>name2</code> <code>str</code> <p>Internal name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list of (int, int, int, int, str)</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> tuples.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def compare_sequences_stranded(\n    self, name1: str, name2: str, merge: bool = True\n) -&gt; list:\n    \"\"\"Compare two sequences by their internal names, returning stranded matches.\n\n    Parameters\n    ----------\n    name1 : str\n        Internal name of the query sequence.\n    name2 : str\n        Internal name of the target sequence.\n    merge : bool, optional\n        Whether to merge consecutive co-linear k-mer runs.\n        Default is ``True``.\n\n    Returns\n    -------\n    list of (int, int, int, int, str)\n        List of ``(query_start, query_end, target_start, target_end, strand)``\n        tuples.\n    \"\"\"\n    return self._index.compare_sequences_stranded(name1, name2, merge)\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.reorder_by_length","title":"<code>reorder_by_length(group=None)</code>","text":"<p>Reorder contigs within one or all groups by descending sequence length.</p> <p>Updates :attr:<code>contig_order</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str or None</code> <p>Group to reorder.  If <code>None</code> (default), all groups are reordered.</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_by_length(self, group: str | None = None) -&gt; None:\n    \"\"\"Reorder contigs within one or all groups by descending sequence length.\n\n    Updates :attr:`contig_order` in-place.\n\n    Parameters\n    ----------\n    group : str or None, optional\n        Group to reorder.  If ``None`` (default), all groups are reordered.\n    \"\"\"\n    groups_to_sort = [group] if group is not None else list(self._groups.keys())\n    for g in groups_to_sort:\n        self._groups[g].sort(\n            key=lambda n: self._index.get_sequence_length(\n                self._make_internal(g, n)\n            ),\n            reverse=True,\n        )\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.reorder_for_colinearity","title":"<code>reorder_for_colinearity(query_group, target_group)</code>","text":"<p>Reorder sequences in two groups to maximise dotplot collinearity.</p> <p>Uses the gravity-centre algorithm via :meth:<code>~rusty_dot.SequenceIndex.optimal_contig_order</code>.  Updates :attr:<code>contig_order</code> in-place for both groups.</p> <p>Parameters:</p> Name Type Description Default <code>query_group</code> <code>str</code> <p>Group label for the query (y-axis / rows).</p> required <code>target_group</code> <code>str</code> <p>Group label for the target (x-axis / columns).</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If either group label is not present in the index.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_for_colinearity(self, query_group: str, target_group: str) -&gt; None:\n    \"\"\"Reorder sequences in two groups to maximise dotplot collinearity.\n\n    Uses the gravity-centre algorithm via\n    :meth:`~rusty_dot.SequenceIndex.optimal_contig_order`.  Updates\n    :attr:`contig_order` in-place for both groups.\n\n    Parameters\n    ----------\n    query_group : str\n        Group label for the query (y-axis / rows).\n    target_group : str\n        Group label for the target (x-axis / columns).\n\n    Raises\n    ------\n    KeyError\n        If either group label is not present in the index.\n    \"\"\"\n    q_internal = [\n        self._make_internal(query_group, n) for n in self._groups[query_group]\n    ]\n    t_internal = [\n        self._make_internal(target_group, n) for n in self._groups[target_group]\n    ]\n    sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n        q_internal, t_internal\n    )\n    self._groups[query_group] = [self._split_internal(n)[1] for n in sorted_q_int]\n    self._groups[target_group] = [self._split_internal(n)[1] for n in sorted_t_int]\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.get_paf","title":"<code>get_paf(group_pairs=None, merge=True)</code>","text":"<p>Return PAF lines for cross-group sequence comparisons.</p> <p>Parameters:</p> Name Type Description Default <code>group_pairs</code> <code>list of (str, str) or None</code> <p>Explicit list of <code>(query_group, target_group)</code> pairs to compare. If <code>None</code> (default):</p> <ul> <li>2 groups \u2192 the single cross-group pair.</li> <li>3+ groups \u2192 all non-self ordered pairs.</li> </ul> <code>None</code> <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF-formatted lines (12 tab-separated columns each).</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_paf(\n    self,\n    group_pairs: list[tuple[str, str]] | None = None,\n    merge: bool = True,\n) -&gt; list[str]:\n    \"\"\"Return PAF lines for cross-group sequence comparisons.\n\n    Parameters\n    ----------\n    group_pairs : list of (str, str) or None, optional\n        Explicit list of ``(query_group, target_group)`` pairs to compare.\n        If ``None`` (default):\n\n        * 2 groups \u2192 the single cross-group pair.\n        * 3+ groups \u2192 all non-self ordered pairs.\n    merge : bool, optional\n        Whether to merge consecutive co-linear k-mer runs before\n        generating PAF lines.  Default is ``True``.\n\n    Returns\n    -------\n    list[str]\n        PAF-formatted lines (12 tab-separated columns each).\n    \"\"\"\n    if group_pairs is None:\n        group_pairs = self._get_default_group_pairs()\n\n    paf_lines: list[str] = []\n    for query_group, target_group in group_pairs:\n        _log.info(\n            'CrossIndex: computing %d x %d pairwise alignments '\n            'between group %r (%d sequences) and group %r (%d sequences)',\n            len(self._groups.get(query_group, [])),\n            len(self._groups.get(target_group, [])),\n            query_group,\n            len(self._groups.get(query_group, [])),\n            target_group,\n            len(self._groups.get(target_group, [])),\n        )\n        for q_orig in self._groups.get(query_group, []):\n            for t_orig in self._groups.get(target_group, []):\n                q_int = self._make_internal(query_group, q_orig)\n                t_int = self._make_internal(target_group, t_orig)\n                lines = self._index.get_paf(q_int, t_int, merge)\n                for line in lines:\n                    fields = line.split('\\t')\n                    fields[0] = q_orig\n                    fields[5] = t_orig\n                    paf_lines.append('\\t'.join(fields))\n    return paf_lines\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.run_merge","title":"<code>run_merge(group_pairs=None)</code>","text":"<p>Compute merged alignments and store the result as :attr:<code>_paf_records</code>.</p> <p>Runs :meth:<code>get_paf</code> with <code>merge=True</code> and populates <code>self._paf_records</code> so that the results can be inspected or passed to a :class:<code>PafAlignment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>group_pairs</code> <code>list of (str, str) or None</code> <p>Group pairs to compare (same semantics as :meth:<code>get_paf</code>). Defaults to all cross-group pairs.</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def run_merge(\n    self,\n    group_pairs: list[tuple[str, str]] | None = None,\n) -&gt; None:\n    \"\"\"Compute merged alignments and store the result as :attr:`_paf_records`.\n\n    Runs :meth:`get_paf` with ``merge=True`` and populates\n    ``self._paf_records`` so that the results can be inspected or passed\n    to a :class:`PafAlignment`.\n\n    Parameters\n    ----------\n    group_pairs : list of (str, str) or None, optional\n        Group pairs to compare (same semantics as :meth:`get_paf`).\n        Defaults to all cross-group pairs.\n    \"\"\"\n    paf_lines = self.get_paf(group_pairs=group_pairs, merge=True)\n    self._paf_records = [PafRecord.from_line(line) for line in paf_lines]\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.get_paf_all","title":"<code>get_paf_all(merge=True)</code>","text":"<p>Return PAF lines for all cross-group comparisons.</p> <p>Backward-compatible wrapper around :meth:<code>get_paf</code>.  When a group <code>'b'</code> is present, computes <code>a</code> vs <code>b</code> alignments; otherwise performs all-vs-all within group <code>'a'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF-formatted lines.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_paf_all(self, merge: bool = True) -&gt; list[str]:\n    \"\"\"Return PAF lines for all cross-group comparisons.\n\n    Backward-compatible wrapper around :meth:`get_paf`.  When a group\n    ``'b'`` is present, computes ``a`` vs ``b`` alignments; otherwise\n    performs all-vs-all within group ``'a'``.\n\n    Parameters\n    ----------\n    merge : bool, optional\n        Whether to merge consecutive co-linear k-mer runs.\n        Default is ``True``.\n\n    Returns\n    -------\n    list[str]\n        PAF-formatted lines.\n    \"\"\"\n    if 'b' in self._groups and self._groups['b']:\n        return self.get_paf(group_pairs=[('a', 'b')], merge=merge)\n    # Single group or no group 'b': all-vs-all within group 'a'\n    names_a = self._groups.get('a', [])\n    _log.info(\n        'CrossIndex: computing all-vs-all pairwise alignments '\n        'within group a (%d sequences)',\n        len(names_a),\n    )\n    paf_lines: list[str] = []\n    for i, q_orig in enumerate(names_a):\n        for j, t_orig in enumerate(names_a):\n            if i == j:\n                continue\n            q_int = self._make_internal('a', q_orig)\n            t_int = self._make_internal('a', t_orig)\n            lines = self._index.get_paf(q_int, t_int, merge)\n            for line in lines:\n                fields = line.split('\\t')\n                fields[0] = q_orig\n                fields[5] = t_orig\n                paf_lines.append('\\t'.join(fields))\n    return paf_lines\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.reorder_contigs","title":"<code>reorder_contigs(query_names=None, target_names=None)</code>","text":"<p>Sort contigs for maximum collinearity (backward-compatible, requires groups a and b).</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str] or None</code> <p>Original (un-prefixed) names for group <code>'a'</code> to reorder. Defaults to all group-a sequences.</p> <code>None</code> <code>target_names</code> <code>list[str] or None</code> <p>Original (un-prefixed) names for group <code>'b'</code> to reorder. Defaults to all group-b sequences.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> \u2014 both using original un-prefixed names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If group <code>'b'</code> is empty.  Use :meth:<code>reorder_for_colinearity</code> for explicit group names.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_contigs(\n    self,\n    query_names: list[str] | None = None,\n    target_names: list[str] | None = None,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Sort contigs for maximum collinearity (backward-compatible, requires groups a and b).\n\n    Parameters\n    ----------\n    query_names : list[str] or None, optional\n        Original (un-prefixed) names for group ``'a'`` to reorder.\n        Defaults to all group-a sequences.\n    target_names : list[str] or None, optional\n        Original (un-prefixed) names for group ``'b'`` to reorder.\n        Defaults to all group-b sequences.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)`` \u2014 both using original\n        un-prefixed names.\n\n    Raises\n    ------\n    ValueError\n        If group ``'b'`` is empty.  Use :meth:`reorder_for_colinearity` for\n        explicit group names.\n    \"\"\"\n    if 'b' not in self._groups or not self._groups['b']:\n        raise ValueError(\n            \"reorder_contigs requires group 'b' sequences; \"\n            'use reorder_for_colinearity for explicit group names.'\n        )\n    q_names = (\n        query_names if query_names is not None else list(self._groups.get('a', []))\n    )\n    t_names = (\n        target_names\n        if target_names is not None\n        else list(self._groups.get('b', []))\n    )\n    q_internal = [self._make_internal('a', n) for n in q_names]\n    t_internal = [self._make_internal('b', n) for n in t_names]\n    sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n        q_internal, t_internal\n    )\n    sorted_q = [self._split_internal(n)[1] for n in sorted_q_int]\n    sorted_t = [self._split_internal(n)[1] for n in sorted_t_int]\n    return sorted_q, sorted_t\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise machine-readable representation.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>CrossIndex(k=&lt;k&gt;, groups={&lt;label&gt;=&lt;n&gt;, ...})</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise machine-readable representation.\n\n    Returns\n    -------\n    str\n        ``CrossIndex(k=&lt;k&gt;, groups={&lt;label&gt;=&lt;n&gt;, ...})``.\n    \"\"\"\n    group_info = ', '.join(f'{g}={len(names)}' for g, names in self._groups.items())\n    return f'CrossIndex(k={self._k}, groups={{{group_info}}})'\n</code></pre>"},{"location":"api/cross_index/#rusty_dot.paf_io.CrossIndex.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable stats summary.</p> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line summary of groups, sequence counts, and cached PAF record count.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a human-readable stats summary.\n\n    Returns\n    -------\n    str\n        Multi-line summary of groups, sequence counts, and cached PAF\n        record count.\n    \"\"\"\n    n_total = sum(len(v) for v in self._groups.values())\n    lines = [f'CrossIndex (k={self._k})']\n    lines.append(f'  Total sequences : {n_total}')\n    for g, names in self._groups.items():\n        lines.append(f'  Group {g!r:12s}: {len(names):&gt;6d} sequences')\n    lines.append(f'  PAF records     : {len(self._paf_records)}')\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/dotplot/","title":"DotPlotter","text":"<p>The <code>DotPlotter</code> class generates all-vs-all dotplot figures from a populated <code>SequenceIndex</code>.</p>"},{"location":"api/dotplot/#class","title":"Class","text":""},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter","title":"<code>DotPlotter</code>","text":"<p>Generate all-vs-all dotplots for sets of DNA sequences.</p> <p>Accepts a :class:<code>~rusty_dot.SequenceIndex</code> (single sequence collection), a :class:<code>~rusty_dot.paf_io.CrossIndex</code> (multi-group collection), or a :class:<code>~rusty_dot.paf_io.PafAlignment</code> loaded from an external aligner such as minimap2.</p> <p>When a <code>PafAlignment</code> is passed as index, sequence lengths are read from the PAF records and alignments are rendered directly \u2014 no k-mer index is required::</p> <pre><code>from rusty_dot.paf_io import PafAlignment\nfrom rusty_dot.dotplot import DotPlotter\n\naln = PafAlignment.from_file(\"alignments.paf\")\nq_order, t_order = aln.reorder_contigs()\n\nplotter = DotPlotter(aln)\nplotter.plot(\n    query_names=q_order,\n    target_names=t_order,\n    output_path=\"dotplot.png\",\n)\n</code></pre> <p>When using a <code>CrossIndex</code>, pass group-specific names via <code>query_names</code> and <code>target_names</code>::</p> <pre><code>cross = CrossIndex(k=15)\ncross.load_fasta(\"assembly_a.fasta\", group=\"a\")\ncross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\nplotter = DotPlotter(cross)\nplotter.plot(\n    query_names=cross.sequence_names(group=\"a\"),\n    target_names=cross.sequence_names(group=\"b\"),\n    output_path=\"cross_plot.png\",\n)\n</code></pre> <p>To colour alignments by sequence identity, supply a :class:<code>~rusty_dot.paf_io.PafAlignment</code> and set <code>color_by_identity=True</code>::</p> <pre><code>from rusty_dot.paf_io import PafAlignment\naln = PafAlignment.from_file(\"alignments.paf\")\nplotter = DotPlotter(aln)\nfig = plotter.plot(color_by_identity=True, identity_palette=\"viridis\")\ncbar = plotter.plot_identity_colorbar(palette=\"viridis\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>SequenceIndex, CrossIndex, or PafAlignment</code> <p>A populated index or alignment collection.  When a :class:<code>~rusty_dot.paf_io.PafAlignment</code> is supplied, it is used both to resolve sequence lengths and as the source of alignment segments.</p> required <code>paf_alignment</code> <code>PafAlignment</code> <p>Pre-loaded PAF alignments used as the data source when <code>color_by_identity=True</code> and index is a <code>SequenceIndex</code> or <code>CrossIndex</code>.  When index is already a <code>PafAlignment</code> this argument is ignored.  When <code>None</code> (default) and index is not a <code>PafAlignment</code>, k-mer matches from index are used for plotting.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rusty_dot import SequenceIndex\n&gt;&gt;&gt; from rusty_dot.dotplot import DotPlotter\n&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\" * 10)\n&gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\" * 10)\n&gt;&gt;&gt; plotter = DotPlotter(idx)\n&gt;&gt;&gt; fig = plotter.plot(output_path=\"dotplot.png\")  # save to file\n&gt;&gt;&gt; fig = plotter.plot()  # display inline in Jupyter, no file saved\n</code></pre> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>class DotPlotter:\n    \"\"\"Generate all-vs-all dotplots for sets of DNA sequences.\n\n    Accepts a :class:`~rusty_dot.SequenceIndex` (single sequence collection),\n    a :class:`~rusty_dot.paf_io.CrossIndex` (multi-group collection), or a\n    :class:`~rusty_dot.paf_io.PafAlignment` loaded from an external aligner\n    such as minimap2.\n\n    When a ``PafAlignment`` is passed as *index*, sequence lengths are read\n    from the PAF records and alignments are rendered directly \u2014 no k-mer index\n    is required::\n\n        from rusty_dot.paf_io import PafAlignment\n        from rusty_dot.dotplot import DotPlotter\n\n        aln = PafAlignment.from_file(\"alignments.paf\")\n        q_order, t_order = aln.reorder_contigs()\n\n        plotter = DotPlotter(aln)\n        plotter.plot(\n            query_names=q_order,\n            target_names=t_order,\n            output_path=\"dotplot.png\",\n        )\n\n    When using a ``CrossIndex``, pass group-specific names via\n    ``query_names`` and ``target_names``::\n\n        cross = CrossIndex(k=15)\n        cross.load_fasta(\"assembly_a.fasta\", group=\"a\")\n        cross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\n        plotter = DotPlotter(cross)\n        plotter.plot(\n            query_names=cross.sequence_names(group=\"a\"),\n            target_names=cross.sequence_names(group=\"b\"),\n            output_path=\"cross_plot.png\",\n        )\n\n    To colour alignments by sequence identity, supply a\n    :class:`~rusty_dot.paf_io.PafAlignment` and set\n    ``color_by_identity=True``::\n\n        from rusty_dot.paf_io import PafAlignment\n        aln = PafAlignment.from_file(\"alignments.paf\")\n        plotter = DotPlotter(aln)\n        fig = plotter.plot(color_by_identity=True, identity_palette=\"viridis\")\n        cbar = plotter.plot_identity_colorbar(palette=\"viridis\")\n\n    Parameters\n    ----------\n    index : SequenceIndex, CrossIndex, or PafAlignment\n        A populated index or alignment collection.  When a\n        :class:`~rusty_dot.paf_io.PafAlignment` is supplied, it is used both\n        to resolve sequence lengths and as the source of alignment segments.\n    paf_alignment : PafAlignment, optional\n        Pre-loaded PAF alignments used as the data source when\n        ``color_by_identity=True`` and *index* is a ``SequenceIndex`` or\n        ``CrossIndex``.  When *index* is already a ``PafAlignment`` this\n        argument is ignored.  When ``None`` (default) and *index* is not a\n        ``PafAlignment``, k-mer matches from *index* are used for plotting.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from rusty_dot import SequenceIndex\n    &gt;&gt;&gt; from rusty_dot.dotplot import DotPlotter\n    &gt;&gt;&gt; idx = SequenceIndex(k=10)\n    &gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\" * 10)\n    &gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\" * 10)\n    &gt;&gt;&gt; plotter = DotPlotter(idx)\n    &gt;&gt;&gt; fig = plotter.plot(output_path=\"dotplot.png\")  # save to file\n    &gt;&gt;&gt; fig = plotter.plot()  # display inline in Jupyter, no file saved\n    \"\"\"\n\n    def __init__(\n        self,\n        index: Union[SequenceIndex, 'CrossIndex', 'PafAlignment'],\n        paf_alignment: Optional['PafAlignment'] = None,\n    ) -&gt; None:\n        \"\"\"Initialise the DotPlotter.\n\n        Parameters\n        ----------\n        index : SequenceIndex, CrossIndex, or PafAlignment\n            A populated index or alignment collection.  When a\n            :class:`~rusty_dot.paf_io.PafAlignment` is supplied, it is used\n            both to resolve sequence lengths and as the source of alignment\n            segments.\n        paf_alignment : PafAlignment, optional\n            Pre-loaded PAF alignments.  Used for identity-based colouring\n            when *index* is a ``SequenceIndex`` or ``CrossIndex``.  When\n            *index* is already a ``PafAlignment`` this argument is ignored.\n            When ``None`` (default), k-mer matches from *index* are used.\n        \"\"\"\n        self.index = index\n        # When a PafAlignment is passed as the primary index, use it for\n        # rendering alignment segments (the explicit paf_alignment kwarg is\n        # then redundant and is ignored to avoid confusion).\n        if isinstance(index, PafAlignment):\n            self.paf_alignment: Optional[PafAlignment] = index\n        else:\n            self.paf_alignment = paf_alignment\n\n    def _index_is_paf(self) -&gt; bool:\n        \"\"\"Return ``True`` when *index* is a :class:`~rusty_dot.paf_io.PafAlignment`.\n\n        Helper used by :meth:`_plot_panel` to decide whether to draw from PAF\n        records or from the k-mer engine.\n        \"\"\"\n        return isinstance(self.index, PafAlignment)\n\n    def plot(\n        self,\n        query_names: Optional[list[str]] = None,\n        target_names: Optional[list[str]] = None,\n        output_path: Optional[Union[str, Path]] = None,\n        figsize_per_panel: float = 4.0,\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        rc_color: str = 'red',\n        merge: bool = True,\n        title: Optional[str] = None,\n        dpi: int = 150,\n        scale_sequences: bool = True,\n        format: Optional[str] = None,\n        min_length: int = 0,\n        color_by_identity: bool = False,\n        identity_palette: str = 'viridis',\n        annotation: Optional['GffAnnotation'] = None,\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"Plot an all-vs-all dotplot grid.\n\n        If both ``query_names`` and ``target_names`` are provided, the plot\n        will show each query sequence (rows) against each target sequence\n        (columns). If only one set is provided, or neither, all pairwise\n        combinations within the available sequences are plotted.\n\n        The figure is always returned so it can be displayed inline in a\n        Jupyter notebook.  When ``output_path`` is provided the figure is\n        also saved to disk.\n\n        Parameters\n        ----------\n        query_names : list[str], optional\n            Sequence names for the y-axis (rows). If ``None``, uses all\n            sequences in the index.\n        target_names : list[str], optional\n            Sequence names for the x-axis (columns). If ``None``, uses all\n            sequences in the index.\n        output_path : str or Path, optional\n            Output image file path.  When ``None`` (default) the figure is\n            not saved to disk.  Use a ``.svg`` extension (or set\n            ``format='svg'``) to produce an SVG vector image.\n        figsize_per_panel : float, optional\n            Base size in inches for each subplot panel when\n            ``scale_sequences=False``.  When ``scale_sequences=True`` this\n            value sets the size of the *longest* sequence axis and all\n            other axes are scaled proportionally.  Default is ``4.0``.\n        dot_size : float, optional\n            Size of each dot in the scatter plot. Default is ``0.5``.\n        dot_color : str, optional\n            Colour for forward-strand (``+``) match lines. Default is ``\"blue\"``.\n        rc_color : str, optional\n            Colour for reverse-complement (``-``) strand match lines.\n            Default is ``\"red\"``.\n        merge : bool, optional\n            Whether to merge sequential k-mer runs before plotting.\n            Default is ``True``.\n        title : str, optional\n            Overall figure title. If ``None``, no title is added.\n        dpi : int, optional\n            Resolution of the output image. Default is ``150``.\n        scale_sequences : bool, optional\n            When ``True`` (default), subplot widths and heights are\n            proportional to the lengths of the corresponding sequences so that\n            relative sequence sizes are preserved.  When ``False``, every\n            panel has the same fixed size.\n        format : str, optional\n            Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n            When ``None`` (default), the format is inferred from the\n            ``output_path`` file extension.\n        min_length : int, optional\n            Minimum alignment length to display.  Matches shorter than this\n            value are not drawn.  Applies to merged k-mer runs and pre-computed\n            PAF alignments.  Default is ``0`` (no filtering).\n        color_by_identity : bool, optional\n            When ``True``, alignments are coloured by sequence identity using\n            the *identity_palette* colormap.  Requires a\n            :class:`~rusty_dot.paf_io.PafAlignment` to be supplied as\n            ``paf_alignment`` to :meth:`__init__`; if no PAF alignment is\n            available a warning is logged and the default strand colours are\n            used instead.  Default is ``False``.\n        identity_palette : str, optional\n            Matplotlib colormap name used to map identity values (0\u20131) to\n            colours when ``color_by_identity=True``.  Default is\n            ``'viridis'``.\n        annotation : GffAnnotation, optional\n            Feature annotations to overlay on self-vs-self diagonal panels.\n            Each feature is drawn as a coloured square at its genomic\n            position.  Sequence names in *annotation* that are absent from\n            the index emit a warning.  Default is ``None``.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The generated figure.  In a Jupyter notebook the figure is\n            displayed inline automatically; call ``matplotlib.pyplot.close``\n            on the returned object when it is no longer needed.\n        \"\"\"\n        all_names = self.index.sequence_names()\n        if not all_names:\n            raise ValueError('No sequences in the index.')\n\n        if query_names is None:\n            query_names = sorted(all_names)\n        if target_names is None:\n            target_names = sorted(all_names)\n\n        # Warn about annotation sequences missing from the index.\n        if annotation is not None:\n            index_seqs = set(all_names)\n            for ann_seq in annotation.sequence_names():\n                if ann_seq not in index_seqs:\n                    _log.warning(\n                        'Annotation contains features for sequence %r which is '\n                        'not present in the index. These features will not be '\n                        'plotted.',\n                        ann_seq,\n                    )\n\n        nrows = len(query_names)\n        ncols = len(target_names)\n\n        if scale_sequences:\n            q_lens = [self.index.get_sequence_length(n) for n in query_names]\n            t_lens = [self.index.get_sequence_length(n) for n in target_names]\n            max_len = max(max(q_lens), max(t_lens), 1)\n            col_widths = [figsize_per_panel * (seq_len / max_len) for seq_len in t_lens]\n            row_heights = [\n                figsize_per_panel * (seq_len / max_len) for seq_len in q_lens\n            ]\n            fig_w = sum(col_widths)\n            fig_h = sum(row_heights)\n            fig, axes = plt.subplots(\n                nrows,\n                ncols,\n                figsize=(fig_w, fig_h),\n                squeeze=False,\n                gridspec_kw={\n                    'width_ratios': col_widths,\n                    'height_ratios': row_heights,\n                },\n            )\n        else:\n            fig_w = figsize_per_panel * ncols\n            fig_h = figsize_per_panel * nrows\n            fig, axes = plt.subplots(\n                nrows,\n                ncols,\n                figsize=(fig_w, fig_h),\n                squeeze=False,\n            )\n\n        for row_idx, q_name in enumerate(query_names):\n            for col_idx, t_name in enumerate(target_names):\n                ax = axes[row_idx][col_idx]\n                self._plot_panel(\n                    ax,\n                    q_name,\n                    t_name,\n                    dot_size=dot_size,\n                    dot_color=dot_color,\n                    rc_color=rc_color,\n                    merge=merge,\n                    min_length=min_length,\n                    # Sequence name labels: y-label on leftmost column only;\n                    # column (x) labels are shown as titles on the top row.\n                    show_xlabel=False,\n                    show_ylabel=(col_idx == 0),\n                    color_by_identity=color_by_identity,\n                    identity_palette=identity_palette,\n                )\n\n                # Column label at top of each column (top row only), rotated.\n                if row_idx == 0:\n                    ax.set_title(\n                        t_name, fontsize=8, rotation=45, ha='left', va='bottom'\n                    )\n\n                # Suppress redundant tick labels on internal panels.\n                if row_idx &lt; nrows - 1:\n                    ax.tick_params(axis='x', labelbottom=False)\n                if col_idx &gt; 0:\n                    ax.tick_params(axis='y', labelleft=False)\n\n                # Annotation squares on self-vs-self (diagonal) panels.\n                if annotation is not None and q_name == t_name:\n                    self._draw_annotation_squares(ax, q_name, annotation)\n\n        if title:\n            fig.suptitle(title, fontsize=14, y=1.01)\n\n        plt.tight_layout()\n        if output_path is not None:\n            plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n        return fig\n\n    def _plot_panel(\n        self,\n        ax: plt.Axes,\n        query_name: str,\n        target_name: str,\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        rc_color: str = 'red',\n        merge: bool = True,\n        min_length: int = 0,\n        show_xlabel: bool = True,\n        show_ylabel: bool = True,\n        color_by_identity: bool = False,\n        identity_palette: str = 'viridis',\n    ) -&gt; None:\n        \"\"\"Render a single comparison panel onto the given Axes.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n            The axes to draw on.\n        query_name : str\n            Name of the query sequence (y-axis).\n        target_name : str\n            Name of the target sequence (x-axis).\n        dot_size : float, optional\n            Marker size. Default is ``0.5``.\n        dot_color : str, optional\n            Marker colour for forward-strand (``+``) matches. Default is ``\"blue\"``.\n        rc_color : str, optional\n            Marker colour for reverse-complement (``-``) matches. Default is ``\"red\"``.\n        merge : bool, optional\n            Whether to merge sequential runs. Default is ``True``.\n        min_length : int, optional\n            Minimum alignment length to display.  Matches shorter than this\n            value are skipped.  Default is ``0`` (no filtering).\n        show_xlabel : bool, optional\n            Whether to render the target sequence name as an x-axis label.\n            Default is ``True``.\n        show_ylabel : bool, optional\n            Whether to render the query sequence name as a y-axis label.\n            Default is ``True``.\n        color_by_identity : bool, optional\n            When ``True``, colour alignments by sequence identity using\n            *identity_palette*.  Requires ``self.paf_alignment`` to be set;\n            if not, a warning is logged and strand colours are used instead.\n            Default is ``False``.\n        identity_palette : str, optional\n            Matplotlib colormap name for identity-based colouring.\n            Default is ``'viridis'``.\n        \"\"\"\n        q_len = self.index.get_sequence_length(query_name)\n        t_len = self.index.get_sequence_length(target_name)\n\n        # Determine rendering mode:\n        # \u2022 When index is a PafAlignment (no k-mer index), always draw from\n        #   PAF records using strand colours unless color_by_identity is set.\n        # \u2022 When index has a k-mer engine but color_by_identity is requested\n        #   without a PafAlignment, fall back to k-mer matches with a warning.\n        use_paf = color_by_identity or self._index_is_paf()\n\n        if use_paf and self.paf_alignment is None:\n            _log.warning(\n                'color_by_identity=True requires a PafAlignment; k-mer matches '\n                'are always 100% identity. Pass paf_alignment= to DotPlotter '\n                'to enable identity colouring.'\n            )\n            use_paf = False\n\n        if use_paf:\n            # Use PAF records for this sequence pair.\n            cmap = plt.get_cmap(identity_palette) if color_by_identity else None\n            norm = mcolors.Normalize(vmin=0, vmax=1) if color_by_identity else None\n            records = [\n                r\n                for r in self.paf_alignment.records  # type: ignore[union-attr]\n                if r.query_name == query_name and r.target_name == target_name\n            ]\n            for rec in records:\n                if min_length &gt; 0 and rec.query_aligned_len &lt; min_length:\n                    continue\n                if color_by_identity:\n                    identity = (\n                        rec.residue_matches / rec.alignment_block_len\n                        if rec.alignment_block_len &gt; 0\n                        else 1.0\n                    )\n                    color = cmap(norm(identity))  # type: ignore[misc]\n                else:\n                    color = rc_color if rec.strand == '-' else dot_color\n                if rec.strand == '-':\n                    xs = [rec.target_end, rec.target_start]\n                else:\n                    xs = [rec.target_start, rec.target_end]\n                ax.plot(\n                    xs,\n                    [rec.query_start, rec.query_end],\n                    color=color,\n                    linewidth=dot_size,\n                    alpha=0.7,\n                )\n        else:\n            # Draw match lines/dots from k-mer index; RC matches are drawn as\n            # anti-diagonal lines.\n            matches = self.index.compare_sequences_stranded(\n                query_name, target_name, merge\n            )\n            for q_start, q_end, t_start, t_end, strand in matches:\n                if min_length &gt; 0 and (q_end - q_start) &lt; min_length:\n                    continue\n                if strand == '-':\n                    # Reverse complement: as query advances (q_start\u2192q_end) the\n                    # target position retreats (t_end\u2192t_start).\n                    xs = [t_end, t_start]\n                    color = rc_color\n                else:\n                    xs = [t_start, t_end]\n                    color = dot_color\n                ax.plot(\n                    xs,\n                    [q_start, q_end],\n                    color=color,\n                    linewidth=dot_size,\n                    alpha=0.7,\n                )\n\n        ax.set_xlim(0, t_len)\n        ax.set_ylim(0, q_len)\n        ax.invert_yaxis()\n        if show_xlabel:\n            ax.set_xlabel(target_name, fontsize=8)\n        if show_ylabel:\n            ax.set_ylabel(query_name, fontsize=8)\n        ax.tick_params(axis='both', labelsize=6)\n        ax.set_aspect('auto')\n\n    def _draw_annotation_squares(\n        self,\n        ax: plt.Axes,\n        seq_name: str,\n        annotation: 'GffAnnotation',\n    ) -&gt; None:\n        \"\"\"Overlay annotation feature squares on a self-vs-self panel.\n\n        Each feature ``[start, end)`` is drawn as a filled square at position\n        ``(start, start)`` to ``(end, end)`` in the dotplot coordinate system.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n            The axes of the self-vs-self panel.\n        seq_name : str\n            Sequence name whose features should be drawn.\n        annotation : GffAnnotation\n            The annotation object providing features and colours.\n        \"\"\"\n        features = annotation.get_features_for_sequence(seq_name)\n        for feat in features:\n            width = feat.end - feat.start\n            rect = mpatches.Rectangle(\n                (feat.start, feat.start),\n                width,\n                width,\n                facecolor=annotation.get_color(feat.feature_type),\n                edgecolor='none',\n                alpha=0.35,\n            )\n            ax.add_patch(rect)\n\n    def plot_annotation_legend(\n        self,\n        annotation: 'GffAnnotation',\n        output_path: Optional[Union[str, Path]] = None,\n        figsize: tuple[float, float] = (3.0, 4.0),\n        dpi: int = 150,\n        format: Optional[str] = None,\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"Render the annotation feature-type legend as a standalone figure.\n\n        Produces a figure containing only a colour legend that maps each\n        feature type to its assigned colour.  This is intended to be\n        displayed alongside dotplots produced with an *annotation* argument.\n\n        Parameters\n        ----------\n        annotation : GffAnnotation\n            The annotation object whose feature-type colours are displayed.\n        output_path : str or Path, optional\n            Output image file path.  When ``None`` (default) the figure is\n            not saved to disk.\n        figsize : tuple[float, float], optional\n            Figure size as ``(width, height)`` in inches.\n            Default is ``(3.0, 4.0)``.\n        dpi : int, optional\n            Output image resolution. Default is ``150``.\n        format : str, optional\n            Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n            When ``None`` (default), the format is inferred from the\n            ``output_path`` file extension.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            A figure containing only the legend.\n        \"\"\"\n        handles = [\n            mpatches.Patch(\n                facecolor=annotation.get_color(ft),\n                edgecolor='none',\n                label=ft,\n            )\n            for ft in annotation.feature_types()\n        ]\n        fig, ax = plt.subplots(figsize=figsize)\n        ax.set_visible(False)\n        fig.legend(handles=handles, loc='center', fontsize=10, frameon=True)\n        plt.tight_layout()\n        if output_path is not None:\n            plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n        return fig\n\n    def plot_single(\n        self,\n        query_name: str,\n        target_name: str,\n        output_path: Optional[Union[str, Path]] = None,\n        figsize: tuple[float, float] = (6.0, 6.0),\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        rc_color: str = 'red',\n        merge: bool = True,\n        title: Optional[str] = None,\n        dpi: int = 150,\n        format: Optional[str] = None,\n        min_length: int = 0,\n        color_by_identity: bool = False,\n        identity_palette: str = 'viridis',\n        annotation: Optional['GffAnnotation'] = None,\n        annotation_track_size: float = 0.4,\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"Plot a single pairwise dotplot.\n\n        When *annotation* is provided, a linear annotation track is drawn\n        below the x-axis (target sequence features) and to the left of the\n        y-axis (query sequence features).\n\n        Parameters\n        ----------\n        query_name : str\n            Name of the query sequence (y-axis).\n        target_name : str\n            Name of the target sequence (x-axis).\n        output_path : str or Path, optional\n            Output image file path.  When ``None`` (default) the figure is\n            not saved to disk.  Use a ``.svg`` extension (or set\n            ``format='svg'``) to produce an SVG vector image.\n        figsize : tuple[float, float], optional\n            Figure size as (width, height) in inches for the main dotplot\n            panel.  When annotation tracks are added the overall figure will\n            be slightly larger.  Default is ``(6, 6)``.\n        dot_size : float, optional\n            Marker/line size for each match. Default is ``0.5``.\n        dot_color : str, optional\n            Colour for forward-strand (``+``) matches. Default is ``\"blue\"``.\n        rc_color : str, optional\n            Colour for reverse-complement (``-``) matches. Default is ``\"red\"``.\n        merge : bool, optional\n            Whether to merge sequential k-mer runs. Default is ``True``.\n        title : str, optional\n            Plot title. If ``None``, a default title is used.\n        dpi : int, optional\n            Output image resolution. Default is ``150``.\n        format : str, optional\n            Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n            When ``None`` (default), the format is inferred from the\n            ``output_path`` file extension.\n        min_length : int, optional\n            Minimum alignment length to display.  Matches shorter than this\n            value are not drawn.  Applies to merged k-mer runs and pre-computed\n            PAF alignments.  Default is ``0`` (no filtering).\n        color_by_identity : bool, optional\n            When ``True``, alignments are coloured by sequence identity using\n            the *identity_palette* colormap.  Requires a\n            :class:`~rusty_dot.paf_io.PafAlignment` to be supplied as\n            ``paf_alignment`` to :meth:`__init__`; if no PAF alignment is\n            available a warning is logged and the default strand colours are\n            used instead.  Default is ``False``.\n        identity_palette : str, optional\n            Matplotlib colormap name used to map identity values (0\u20131) to\n            colours when ``color_by_identity=True``.  Default is\n            ``'viridis'``.\n        annotation : GffAnnotation, optional\n            Feature annotations to display as linear tracks flanking the\n            dotplot.  Target features are drawn below the x-axis; query\n            features are drawn to the left of the y-axis.  Sequence names\n            in *annotation* absent from the index emit a warning.\n            Default is ``None``.\n        annotation_track_size : float, optional\n            Height/width in inches of each annotation track.\n            Default is ``0.4``.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            The generated figure.  In a Jupyter notebook the figure is\n            displayed inline automatically; call ``matplotlib.pyplot.close``\n            on the returned object when it is no longer needed.\n        \"\"\"\n        import matplotlib.gridspec as gridspec\n\n        if annotation is not None:\n            # Warn about annotation sequences not in the index.\n            index_seqs = set(self.index.sequence_names())\n            for ann_seq in annotation.sequence_names():\n                if ann_seq not in index_seqs:\n                    _log.warning(\n                        'Annotation contains features for sequence %r which is '\n                        'not present in the index. These features will not be '\n                        'plotted.',\n                        ann_seq,\n                    )\n            x_feats = annotation.get_features_for_sequence(target_name)\n            y_feats = annotation.get_features_for_sequence(query_name)\n            has_tracks = True\n        else:\n            x_feats = []\n            y_feats = []\n            has_tracks = False\n\n        if has_tracks:\n            fw, fh = figsize\n            ts = annotation_track_size\n            # GridSpec layout:\n            #   rows: [main (fh), x-track (ts)]\n            #   cols: [y-track (ts), main (fw)]\n            total_w = fw + ts\n            total_h = fh + ts\n            fig = plt.figure(figsize=(total_w, total_h))\n            gs = gridspec.GridSpec(\n                2,\n                2,\n                width_ratios=[ts, fw],\n                height_ratios=[fh, ts],\n                hspace=0.02,\n                wspace=0.02,\n            )\n            main_ax = fig.add_subplot(gs[0, 1])\n            y_track_ax = fig.add_subplot(gs[0, 0], sharey=main_ax)\n            x_track_ax = fig.add_subplot(gs[1, 1], sharex=main_ax)\n            corner_ax = fig.add_subplot(gs[1, 0])\n            corner_ax.set_visible(False)\n        else:\n            fig, main_ax = plt.subplots(figsize=figsize)\n\n        self._plot_panel(\n            main_ax,\n            query_name,\n            target_name,\n            dot_size=dot_size,\n            dot_color=dot_color,\n            rc_color=rc_color,\n            merge=merge,\n            min_length=min_length,\n            color_by_identity=color_by_identity,\n            identity_palette=identity_palette,\n        )\n\n        if has_tracks:\n            t_len = self.index.get_sequence_length(target_name)\n\n            # Hide main-axis tick labels that duplicate the track labels.\n            plt.setp(main_ax.get_xticklabels(), visible=False)\n            plt.setp(main_ax.get_yticklabels(), visible=False)\n\n            # ---- x-annotation track (below x-axis: target features) ----\n            x_track_ax.set_xlim(0, t_len)\n            x_track_ax.set_ylim(0, 1)\n            x_track_ax.set_yticks([])\n            x_track_ax.tick_params(axis='x', labelsize=6)\n            x_track_ax.set_xlabel(target_name, fontsize=8)\n            for feat in x_feats:\n                rect = mpatches.Rectangle(\n                    (feat.start, 0.1),\n                    feat.end - feat.start,\n                    0.8,\n                    facecolor=annotation.get_color(feat.feature_type),  # type: ignore[union-attr]\n                    edgecolor='none',\n                )\n                x_track_ax.add_patch(rect)\n\n            # ---- y-annotation track (left of y-axis: query features) ----\n            # The main axes y-axis is inverted, so sharey keeps inversion.\n            y_track_ax.set_xlim(1, 0)  # reversed so features face main plot\n            y_track_ax.set_xticks([])\n            y_track_ax.tick_params(axis='y', labelsize=6)\n            y_track_ax.set_ylabel(query_name, fontsize=8)\n            for feat in y_feats:\n                rect = mpatches.Rectangle(\n                    (0.1, feat.start),\n                    0.8,\n                    feat.end - feat.start,\n                    facecolor=annotation.get_color(feat.feature_type),  # type: ignore[union-attr]\n                    edgecolor='none',\n                )\n                y_track_ax.add_patch(rect)\n\n        if title is None:\n            title = f'{query_name} vs {target_name}'\n        main_ax.set_title(title, fontsize=10)\n\n        if has_tracks:\n            fig.subplots_adjust(hspace=0.02, wspace=0.02)\n        else:\n            plt.tight_layout()\n        if output_path is not None:\n            plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n        return fig\n\n    def plot_identity_colorbar(\n        self,\n        palette: str = 'viridis',\n        figsize: tuple[float, float] = (1.5, 4.0),\n        output_path: Optional[Union[str, Path]] = None,\n        dpi: int = 150,\n        format: Optional[str] = None,\n    ) -&gt; matplotlib.figure.Figure:\n        \"\"\"Render the identity colour scale as a standalone figure.\n\n        Produces a figure containing only a vertical colorbar that maps\n        identity values (0\u2013100 %) to colours from *palette*.  This is\n        intended to be displayed alongside a dotplot produced with\n        ``color_by_identity=True``.\n\n        Parameters\n        ----------\n        palette : str, optional\n            Matplotlib colormap name.  Should match the *identity_palette*\n            used when calling :meth:`plot` or :meth:`plot_single`.\n            Default is ``'viridis'``.\n        figsize : tuple[float, float], optional\n            Figure size as ``(width, height)`` in inches.\n            Default is ``(1.5, 4.0)``.\n        output_path : str or Path, optional\n            Output image file path.  When ``None`` (default) the figure is\n            not saved to disk.\n        dpi : int, optional\n            Output image resolution. Default is ``150``.\n        format : str, optional\n            Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n            When ``None`` (default), the format is inferred from the\n            ``output_path`` file extension.\n\n        Returns\n        -------\n        matplotlib.figure.Figure\n            A figure containing only the colorbar.\n        \"\"\"\n        norm = mcolors.Normalize(vmin=0, vmax=1)\n        sm = plt.cm.ScalarMappable(cmap=plt.get_cmap(palette), norm=norm)\n        sm.set_array([])\n        fig, ax = plt.subplots(figsize=figsize)\n        cb = fig.colorbar(sm, ax=ax, orientation='vertical')\n        cb.set_label('Identity', fontsize=10)\n        cb.set_ticks([0, 0.25, 0.5, 0.75, 1.0])\n        cb.set_ticklabels(['0%', '25%', '50%', '75%', '100%'])\n        ax.set_visible(False)\n        plt.tight_layout()\n        if output_path is not None:\n            plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n        return fig\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter-functions","title":"Functions","text":""},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.__init__","title":"<code>__init__(index, paf_alignment=None)</code>","text":"<p>Initialise the DotPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>SequenceIndex, CrossIndex, or PafAlignment</code> <p>A populated index or alignment collection.  When a :class:<code>~rusty_dot.paf_io.PafAlignment</code> is supplied, it is used both to resolve sequence lengths and as the source of alignment segments.</p> required <code>paf_alignment</code> <code>PafAlignment</code> <p>Pre-loaded PAF alignments.  Used for identity-based colouring when index is a <code>SequenceIndex</code> or <code>CrossIndex</code>.  When index is already a <code>PafAlignment</code> this argument is ignored. When <code>None</code> (default), k-mer matches from index are used.</p> <code>None</code> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def __init__(\n    self,\n    index: Union[SequenceIndex, 'CrossIndex', 'PafAlignment'],\n    paf_alignment: Optional['PafAlignment'] = None,\n) -&gt; None:\n    \"\"\"Initialise the DotPlotter.\n\n    Parameters\n    ----------\n    index : SequenceIndex, CrossIndex, or PafAlignment\n        A populated index or alignment collection.  When a\n        :class:`~rusty_dot.paf_io.PafAlignment` is supplied, it is used\n        both to resolve sequence lengths and as the source of alignment\n        segments.\n    paf_alignment : PafAlignment, optional\n        Pre-loaded PAF alignments.  Used for identity-based colouring\n        when *index* is a ``SequenceIndex`` or ``CrossIndex``.  When\n        *index* is already a ``PafAlignment`` this argument is ignored.\n        When ``None`` (default), k-mer matches from *index* are used.\n    \"\"\"\n    self.index = index\n    # When a PafAlignment is passed as the primary index, use it for\n    # rendering alignment segments (the explicit paf_alignment kwarg is\n    # then redundant and is ignored to avoid confusion).\n    if isinstance(index, PafAlignment):\n        self.paf_alignment: Optional[PafAlignment] = index\n    else:\n        self.paf_alignment = paf_alignment\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot","title":"<code>plot(query_names=None, target_names=None, output_path=None, figsize_per_panel=4.0, dot_size=0.5, dot_color='blue', rc_color='red', merge=True, title=None, dpi=150, scale_sequences=True, format=None, min_length=0, color_by_identity=False, identity_palette='viridis', annotation=None)</code>","text":"<p>Plot an all-vs-all dotplot grid.</p> <p>If both <code>query_names</code> and <code>target_names</code> are provided, the plot will show each query sequence (rows) against each target sequence (columns). If only one set is provided, or neither, all pairwise combinations within the available sequences are plotted.</p> <p>The figure is always returned so it can be displayed inline in a Jupyter notebook.  When <code>output_path</code> is provided the figure is also saved to disk.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str]</code> <p>Sequence names for the y-axis (rows). If <code>None</code>, uses all sequences in the index.</p> <code>None</code> <code>target_names</code> <code>list[str]</code> <p>Sequence names for the x-axis (columns). If <code>None</code>, uses all sequences in the index.</p> <code>None</code> <code>output_path</code> <code>str or Path</code> <p>Output image file path.  When <code>None</code> (default) the figure is not saved to disk.  Use a <code>.svg</code> extension (or set <code>format='svg'</code>) to produce an SVG vector image.</p> <code>None</code> <code>figsize_per_panel</code> <code>float</code> <p>Base size in inches for each subplot panel when <code>scale_sequences=False</code>.  When <code>scale_sequences=True</code> this value sets the size of the longest sequence axis and all other axes are scaled proportionally.  Default is <code>4.0</code>.</p> <code>4.0</code> <code>dot_size</code> <code>float</code> <p>Size of each dot in the scatter plot. Default is <code>0.5</code>.</p> <code>0.5</code> <code>dot_color</code> <code>str</code> <p>Colour for forward-strand (<code>+</code>) match lines. Default is <code>\"blue\"</code>.</p> <code>'blue'</code> <code>rc_color</code> <code>str</code> <p>Colour for reverse-complement (<code>-</code>) strand match lines. Default is <code>\"red\"</code>.</p> <code>'red'</code> <code>merge</code> <code>bool</code> <p>Whether to merge sequential k-mer runs before plotting. Default is <code>True</code>.</p> <code>True</code> <code>title</code> <code>str</code> <p>Overall figure title. If <code>None</code>, no title is added.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Resolution of the output image. Default is <code>150</code>.</p> <code>150</code> <code>scale_sequences</code> <code>bool</code> <p>When <code>True</code> (default), subplot widths and heights are proportional to the lengths of the corresponding sequences so that relative sequence sizes are preserved.  When <code>False</code>, every panel has the same fixed size.</p> <code>True</code> <code>format</code> <code>str</code> <p>Output image format (e.g. <code>'png'</code>, <code>'svg'</code>, <code>'pdf'</code>). When <code>None</code> (default), the format is inferred from the <code>output_path</code> file extension.</p> <code>None</code> <code>min_length</code> <code>int</code> <p>Minimum alignment length to display.  Matches shorter than this value are not drawn.  Applies to merged k-mer runs and pre-computed PAF alignments.  Default is <code>0</code> (no filtering).</p> <code>0</code> <code>color_by_identity</code> <code>bool</code> <p>When <code>True</code>, alignments are coloured by sequence identity using the identity_palette colormap.  Requires a :class:<code>~rusty_dot.paf_io.PafAlignment</code> to be supplied as <code>paf_alignment</code> to :meth:<code>__init__</code>; if no PAF alignment is available a warning is logged and the default strand colours are used instead.  Default is <code>False</code>.</p> <code>False</code> <code>identity_palette</code> <code>str</code> <p>Matplotlib colormap name used to map identity values (0\u20131) to colours when <code>color_by_identity=True</code>.  Default is <code>'viridis'</code>.</p> <code>'viridis'</code> <code>annotation</code> <code>GffAnnotation</code> <p>Feature annotations to overlay on self-vs-self diagonal panels. Each feature is drawn as a coloured square at its genomic position.  Sequence names in annotation that are absent from the index emit a warning.  Default is <code>None</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The generated figure.  In a Jupyter notebook the figure is displayed inline automatically; call <code>matplotlib.pyplot.close</code> on the returned object when it is no longer needed.</p> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot(\n    self,\n    query_names: Optional[list[str]] = None,\n    target_names: Optional[list[str]] = None,\n    output_path: Optional[Union[str, Path]] = None,\n    figsize_per_panel: float = 4.0,\n    dot_size: float = 0.5,\n    dot_color: str = 'blue',\n    rc_color: str = 'red',\n    merge: bool = True,\n    title: Optional[str] = None,\n    dpi: int = 150,\n    scale_sequences: bool = True,\n    format: Optional[str] = None,\n    min_length: int = 0,\n    color_by_identity: bool = False,\n    identity_palette: str = 'viridis',\n    annotation: Optional['GffAnnotation'] = None,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"Plot an all-vs-all dotplot grid.\n\n    If both ``query_names`` and ``target_names`` are provided, the plot\n    will show each query sequence (rows) against each target sequence\n    (columns). If only one set is provided, or neither, all pairwise\n    combinations within the available sequences are plotted.\n\n    The figure is always returned so it can be displayed inline in a\n    Jupyter notebook.  When ``output_path`` is provided the figure is\n    also saved to disk.\n\n    Parameters\n    ----------\n    query_names : list[str], optional\n        Sequence names for the y-axis (rows). If ``None``, uses all\n        sequences in the index.\n    target_names : list[str], optional\n        Sequence names for the x-axis (columns). If ``None``, uses all\n        sequences in the index.\n    output_path : str or Path, optional\n        Output image file path.  When ``None`` (default) the figure is\n        not saved to disk.  Use a ``.svg`` extension (or set\n        ``format='svg'``) to produce an SVG vector image.\n    figsize_per_panel : float, optional\n        Base size in inches for each subplot panel when\n        ``scale_sequences=False``.  When ``scale_sequences=True`` this\n        value sets the size of the *longest* sequence axis and all\n        other axes are scaled proportionally.  Default is ``4.0``.\n    dot_size : float, optional\n        Size of each dot in the scatter plot. Default is ``0.5``.\n    dot_color : str, optional\n        Colour for forward-strand (``+``) match lines. Default is ``\"blue\"``.\n    rc_color : str, optional\n        Colour for reverse-complement (``-``) strand match lines.\n        Default is ``\"red\"``.\n    merge : bool, optional\n        Whether to merge sequential k-mer runs before plotting.\n        Default is ``True``.\n    title : str, optional\n        Overall figure title. If ``None``, no title is added.\n    dpi : int, optional\n        Resolution of the output image. Default is ``150``.\n    scale_sequences : bool, optional\n        When ``True`` (default), subplot widths and heights are\n        proportional to the lengths of the corresponding sequences so that\n        relative sequence sizes are preserved.  When ``False``, every\n        panel has the same fixed size.\n    format : str, optional\n        Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n        When ``None`` (default), the format is inferred from the\n        ``output_path`` file extension.\n    min_length : int, optional\n        Minimum alignment length to display.  Matches shorter than this\n        value are not drawn.  Applies to merged k-mer runs and pre-computed\n        PAF alignments.  Default is ``0`` (no filtering).\n    color_by_identity : bool, optional\n        When ``True``, alignments are coloured by sequence identity using\n        the *identity_palette* colormap.  Requires a\n        :class:`~rusty_dot.paf_io.PafAlignment` to be supplied as\n        ``paf_alignment`` to :meth:`__init__`; if no PAF alignment is\n        available a warning is logged and the default strand colours are\n        used instead.  Default is ``False``.\n    identity_palette : str, optional\n        Matplotlib colormap name used to map identity values (0\u20131) to\n        colours when ``color_by_identity=True``.  Default is\n        ``'viridis'``.\n    annotation : GffAnnotation, optional\n        Feature annotations to overlay on self-vs-self diagonal panels.\n        Each feature is drawn as a coloured square at its genomic\n        position.  Sequence names in *annotation* that are absent from\n        the index emit a warning.  Default is ``None``.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The generated figure.  In a Jupyter notebook the figure is\n        displayed inline automatically; call ``matplotlib.pyplot.close``\n        on the returned object when it is no longer needed.\n    \"\"\"\n    all_names = self.index.sequence_names()\n    if not all_names:\n        raise ValueError('No sequences in the index.')\n\n    if query_names is None:\n        query_names = sorted(all_names)\n    if target_names is None:\n        target_names = sorted(all_names)\n\n    # Warn about annotation sequences missing from the index.\n    if annotation is not None:\n        index_seqs = set(all_names)\n        for ann_seq in annotation.sequence_names():\n            if ann_seq not in index_seqs:\n                _log.warning(\n                    'Annotation contains features for sequence %r which is '\n                    'not present in the index. These features will not be '\n                    'plotted.',\n                    ann_seq,\n                )\n\n    nrows = len(query_names)\n    ncols = len(target_names)\n\n    if scale_sequences:\n        q_lens = [self.index.get_sequence_length(n) for n in query_names]\n        t_lens = [self.index.get_sequence_length(n) for n in target_names]\n        max_len = max(max(q_lens), max(t_lens), 1)\n        col_widths = [figsize_per_panel * (seq_len / max_len) for seq_len in t_lens]\n        row_heights = [\n            figsize_per_panel * (seq_len / max_len) for seq_len in q_lens\n        ]\n        fig_w = sum(col_widths)\n        fig_h = sum(row_heights)\n        fig, axes = plt.subplots(\n            nrows,\n            ncols,\n            figsize=(fig_w, fig_h),\n            squeeze=False,\n            gridspec_kw={\n                'width_ratios': col_widths,\n                'height_ratios': row_heights,\n            },\n        )\n    else:\n        fig_w = figsize_per_panel * ncols\n        fig_h = figsize_per_panel * nrows\n        fig, axes = plt.subplots(\n            nrows,\n            ncols,\n            figsize=(fig_w, fig_h),\n            squeeze=False,\n        )\n\n    for row_idx, q_name in enumerate(query_names):\n        for col_idx, t_name in enumerate(target_names):\n            ax = axes[row_idx][col_idx]\n            self._plot_panel(\n                ax,\n                q_name,\n                t_name,\n                dot_size=dot_size,\n                dot_color=dot_color,\n                rc_color=rc_color,\n                merge=merge,\n                min_length=min_length,\n                # Sequence name labels: y-label on leftmost column only;\n                # column (x) labels are shown as titles on the top row.\n                show_xlabel=False,\n                show_ylabel=(col_idx == 0),\n                color_by_identity=color_by_identity,\n                identity_palette=identity_palette,\n            )\n\n            # Column label at top of each column (top row only), rotated.\n            if row_idx == 0:\n                ax.set_title(\n                    t_name, fontsize=8, rotation=45, ha='left', va='bottom'\n                )\n\n            # Suppress redundant tick labels on internal panels.\n            if row_idx &lt; nrows - 1:\n                ax.tick_params(axis='x', labelbottom=False)\n            if col_idx &gt; 0:\n                ax.tick_params(axis='y', labelleft=False)\n\n            # Annotation squares on self-vs-self (diagonal) panels.\n            if annotation is not None and q_name == t_name:\n                self._draw_annotation_squares(ax, q_name, annotation)\n\n    if title:\n        fig.suptitle(title, fontsize=14, y=1.01)\n\n    plt.tight_layout()\n    if output_path is not None:\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n    return fig\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot_annotation_legend","title":"<code>plot_annotation_legend(annotation, output_path=None, figsize=(3.0, 4.0), dpi=150, format=None)</code>","text":"<p>Render the annotation feature-type legend as a standalone figure.</p> <p>Produces a figure containing only a colour legend that maps each feature type to its assigned colour.  This is intended to be displayed alongside dotplots produced with an annotation argument.</p> <p>Parameters:</p> Name Type Description Default <code>annotation</code> <code>GffAnnotation</code> <p>The annotation object whose feature-type colours are displayed.</p> required <code>output_path</code> <code>str or Path</code> <p>Output image file path.  When <code>None</code> (default) the figure is not saved to disk.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size as <code>(width, height)</code> in inches. Default is <code>(3.0, 4.0)</code>.</p> <code>(3.0, 4.0)</code> <code>dpi</code> <code>int</code> <p>Output image resolution. Default is <code>150</code>.</p> <code>150</code> <code>format</code> <code>str</code> <p>Output image format (e.g. <code>'png'</code>, <code>'svg'</code>, <code>'pdf'</code>). When <code>None</code> (default), the format is inferred from the <code>output_path</code> file extension.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A figure containing only the legend.</p> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot_annotation_legend(\n    self,\n    annotation: 'GffAnnotation',\n    output_path: Optional[Union[str, Path]] = None,\n    figsize: tuple[float, float] = (3.0, 4.0),\n    dpi: int = 150,\n    format: Optional[str] = None,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"Render the annotation feature-type legend as a standalone figure.\n\n    Produces a figure containing only a colour legend that maps each\n    feature type to its assigned colour.  This is intended to be\n    displayed alongside dotplots produced with an *annotation* argument.\n\n    Parameters\n    ----------\n    annotation : GffAnnotation\n        The annotation object whose feature-type colours are displayed.\n    output_path : str or Path, optional\n        Output image file path.  When ``None`` (default) the figure is\n        not saved to disk.\n    figsize : tuple[float, float], optional\n        Figure size as ``(width, height)`` in inches.\n        Default is ``(3.0, 4.0)``.\n    dpi : int, optional\n        Output image resolution. Default is ``150``.\n    format : str, optional\n        Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n        When ``None`` (default), the format is inferred from the\n        ``output_path`` file extension.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        A figure containing only the legend.\n    \"\"\"\n    handles = [\n        mpatches.Patch(\n            facecolor=annotation.get_color(ft),\n            edgecolor='none',\n            label=ft,\n        )\n        for ft in annotation.feature_types()\n    ]\n    fig, ax = plt.subplots(figsize=figsize)\n    ax.set_visible(False)\n    fig.legend(handles=handles, loc='center', fontsize=10, frameon=True)\n    plt.tight_layout()\n    if output_path is not None:\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n    return fig\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot_single","title":"<code>plot_single(query_name, target_name, output_path=None, figsize=(6.0, 6.0), dot_size=0.5, dot_color='blue', rc_color='red', merge=True, title=None, dpi=150, format=None, min_length=0, color_by_identity=False, identity_palette='viridis', annotation=None, annotation_track_size=0.4)</code>","text":"<p>Plot a single pairwise dotplot.</p> <p>When annotation is provided, a linear annotation track is drawn below the x-axis (target sequence features) and to the left of the y-axis (query sequence features).</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence (y-axis).</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence (x-axis).</p> required <code>output_path</code> <code>str or Path</code> <p>Output image file path.  When <code>None</code> (default) the figure is not saved to disk.  Use a <code>.svg</code> extension (or set <code>format='svg'</code>) to produce an SVG vector image.</p> <code>None</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size as (width, height) in inches for the main dotplot panel.  When annotation tracks are added the overall figure will be slightly larger.  Default is <code>(6, 6)</code>.</p> <code>(6.0, 6.0)</code> <code>dot_size</code> <code>float</code> <p>Marker/line size for each match. Default is <code>0.5</code>.</p> <code>0.5</code> <code>dot_color</code> <code>str</code> <p>Colour for forward-strand (<code>+</code>) matches. Default is <code>\"blue\"</code>.</p> <code>'blue'</code> <code>rc_color</code> <code>str</code> <p>Colour for reverse-complement (<code>-</code>) matches. Default is <code>\"red\"</code>.</p> <code>'red'</code> <code>merge</code> <code>bool</code> <p>Whether to merge sequential k-mer runs. Default is <code>True</code>.</p> <code>True</code> <code>title</code> <code>str</code> <p>Plot title. If <code>None</code>, a default title is used.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Output image resolution. Default is <code>150</code>.</p> <code>150</code> <code>format</code> <code>str</code> <p>Output image format (e.g. <code>'png'</code>, <code>'svg'</code>, <code>'pdf'</code>). When <code>None</code> (default), the format is inferred from the <code>output_path</code> file extension.</p> <code>None</code> <code>min_length</code> <code>int</code> <p>Minimum alignment length to display.  Matches shorter than this value are not drawn.  Applies to merged k-mer runs and pre-computed PAF alignments.  Default is <code>0</code> (no filtering).</p> <code>0</code> <code>color_by_identity</code> <code>bool</code> <p>When <code>True</code>, alignments are coloured by sequence identity using the identity_palette colormap.  Requires a :class:<code>~rusty_dot.paf_io.PafAlignment</code> to be supplied as <code>paf_alignment</code> to :meth:<code>__init__</code>; if no PAF alignment is available a warning is logged and the default strand colours are used instead.  Default is <code>False</code>.</p> <code>False</code> <code>identity_palette</code> <code>str</code> <p>Matplotlib colormap name used to map identity values (0\u20131) to colours when <code>color_by_identity=True</code>.  Default is <code>'viridis'</code>.</p> <code>'viridis'</code> <code>annotation</code> <code>GffAnnotation</code> <p>Feature annotations to display as linear tracks flanking the dotplot.  Target features are drawn below the x-axis; query features are drawn to the left of the y-axis.  Sequence names in annotation absent from the index emit a warning. Default is <code>None</code>.</p> <code>None</code> <code>annotation_track_size</code> <code>float</code> <p>Height/width in inches of each annotation track. Default is <code>0.4</code>.</p> <code>0.4</code> <p>Returns:</p> Type Description <code>Figure</code> <p>The generated figure.  In a Jupyter notebook the figure is displayed inline automatically; call <code>matplotlib.pyplot.close</code> on the returned object when it is no longer needed.</p> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot_single(\n    self,\n    query_name: str,\n    target_name: str,\n    output_path: Optional[Union[str, Path]] = None,\n    figsize: tuple[float, float] = (6.0, 6.0),\n    dot_size: float = 0.5,\n    dot_color: str = 'blue',\n    rc_color: str = 'red',\n    merge: bool = True,\n    title: Optional[str] = None,\n    dpi: int = 150,\n    format: Optional[str] = None,\n    min_length: int = 0,\n    color_by_identity: bool = False,\n    identity_palette: str = 'viridis',\n    annotation: Optional['GffAnnotation'] = None,\n    annotation_track_size: float = 0.4,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"Plot a single pairwise dotplot.\n\n    When *annotation* is provided, a linear annotation track is drawn\n    below the x-axis (target sequence features) and to the left of the\n    y-axis (query sequence features).\n\n    Parameters\n    ----------\n    query_name : str\n        Name of the query sequence (y-axis).\n    target_name : str\n        Name of the target sequence (x-axis).\n    output_path : str or Path, optional\n        Output image file path.  When ``None`` (default) the figure is\n        not saved to disk.  Use a ``.svg`` extension (or set\n        ``format='svg'``) to produce an SVG vector image.\n    figsize : tuple[float, float], optional\n        Figure size as (width, height) in inches for the main dotplot\n        panel.  When annotation tracks are added the overall figure will\n        be slightly larger.  Default is ``(6, 6)``.\n    dot_size : float, optional\n        Marker/line size for each match. Default is ``0.5``.\n    dot_color : str, optional\n        Colour for forward-strand (``+``) matches. Default is ``\"blue\"``.\n    rc_color : str, optional\n        Colour for reverse-complement (``-``) matches. Default is ``\"red\"``.\n    merge : bool, optional\n        Whether to merge sequential k-mer runs. Default is ``True``.\n    title : str, optional\n        Plot title. If ``None``, a default title is used.\n    dpi : int, optional\n        Output image resolution. Default is ``150``.\n    format : str, optional\n        Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n        When ``None`` (default), the format is inferred from the\n        ``output_path`` file extension.\n    min_length : int, optional\n        Minimum alignment length to display.  Matches shorter than this\n        value are not drawn.  Applies to merged k-mer runs and pre-computed\n        PAF alignments.  Default is ``0`` (no filtering).\n    color_by_identity : bool, optional\n        When ``True``, alignments are coloured by sequence identity using\n        the *identity_palette* colormap.  Requires a\n        :class:`~rusty_dot.paf_io.PafAlignment` to be supplied as\n        ``paf_alignment`` to :meth:`__init__`; if no PAF alignment is\n        available a warning is logged and the default strand colours are\n        used instead.  Default is ``False``.\n    identity_palette : str, optional\n        Matplotlib colormap name used to map identity values (0\u20131) to\n        colours when ``color_by_identity=True``.  Default is\n        ``'viridis'``.\n    annotation : GffAnnotation, optional\n        Feature annotations to display as linear tracks flanking the\n        dotplot.  Target features are drawn below the x-axis; query\n        features are drawn to the left of the y-axis.  Sequence names\n        in *annotation* absent from the index emit a warning.\n        Default is ``None``.\n    annotation_track_size : float, optional\n        Height/width in inches of each annotation track.\n        Default is ``0.4``.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        The generated figure.  In a Jupyter notebook the figure is\n        displayed inline automatically; call ``matplotlib.pyplot.close``\n        on the returned object when it is no longer needed.\n    \"\"\"\n    import matplotlib.gridspec as gridspec\n\n    if annotation is not None:\n        # Warn about annotation sequences not in the index.\n        index_seqs = set(self.index.sequence_names())\n        for ann_seq in annotation.sequence_names():\n            if ann_seq not in index_seqs:\n                _log.warning(\n                    'Annotation contains features for sequence %r which is '\n                    'not present in the index. These features will not be '\n                    'plotted.',\n                    ann_seq,\n                )\n        x_feats = annotation.get_features_for_sequence(target_name)\n        y_feats = annotation.get_features_for_sequence(query_name)\n        has_tracks = True\n    else:\n        x_feats = []\n        y_feats = []\n        has_tracks = False\n\n    if has_tracks:\n        fw, fh = figsize\n        ts = annotation_track_size\n        # GridSpec layout:\n        #   rows: [main (fh), x-track (ts)]\n        #   cols: [y-track (ts), main (fw)]\n        total_w = fw + ts\n        total_h = fh + ts\n        fig = plt.figure(figsize=(total_w, total_h))\n        gs = gridspec.GridSpec(\n            2,\n            2,\n            width_ratios=[ts, fw],\n            height_ratios=[fh, ts],\n            hspace=0.02,\n            wspace=0.02,\n        )\n        main_ax = fig.add_subplot(gs[0, 1])\n        y_track_ax = fig.add_subplot(gs[0, 0], sharey=main_ax)\n        x_track_ax = fig.add_subplot(gs[1, 1], sharex=main_ax)\n        corner_ax = fig.add_subplot(gs[1, 0])\n        corner_ax.set_visible(False)\n    else:\n        fig, main_ax = plt.subplots(figsize=figsize)\n\n    self._plot_panel(\n        main_ax,\n        query_name,\n        target_name,\n        dot_size=dot_size,\n        dot_color=dot_color,\n        rc_color=rc_color,\n        merge=merge,\n        min_length=min_length,\n        color_by_identity=color_by_identity,\n        identity_palette=identity_palette,\n    )\n\n    if has_tracks:\n        t_len = self.index.get_sequence_length(target_name)\n\n        # Hide main-axis tick labels that duplicate the track labels.\n        plt.setp(main_ax.get_xticklabels(), visible=False)\n        plt.setp(main_ax.get_yticklabels(), visible=False)\n\n        # ---- x-annotation track (below x-axis: target features) ----\n        x_track_ax.set_xlim(0, t_len)\n        x_track_ax.set_ylim(0, 1)\n        x_track_ax.set_yticks([])\n        x_track_ax.tick_params(axis='x', labelsize=6)\n        x_track_ax.set_xlabel(target_name, fontsize=8)\n        for feat in x_feats:\n            rect = mpatches.Rectangle(\n                (feat.start, 0.1),\n                feat.end - feat.start,\n                0.8,\n                facecolor=annotation.get_color(feat.feature_type),  # type: ignore[union-attr]\n                edgecolor='none',\n            )\n            x_track_ax.add_patch(rect)\n\n        # ---- y-annotation track (left of y-axis: query features) ----\n        # The main axes y-axis is inverted, so sharey keeps inversion.\n        y_track_ax.set_xlim(1, 0)  # reversed so features face main plot\n        y_track_ax.set_xticks([])\n        y_track_ax.tick_params(axis='y', labelsize=6)\n        y_track_ax.set_ylabel(query_name, fontsize=8)\n        for feat in y_feats:\n            rect = mpatches.Rectangle(\n                (0.1, feat.start),\n                0.8,\n                feat.end - feat.start,\n                facecolor=annotation.get_color(feat.feature_type),  # type: ignore[union-attr]\n                edgecolor='none',\n            )\n            y_track_ax.add_patch(rect)\n\n    if title is None:\n        title = f'{query_name} vs {target_name}'\n    main_ax.set_title(title, fontsize=10)\n\n    if has_tracks:\n        fig.subplots_adjust(hspace=0.02, wspace=0.02)\n    else:\n        plt.tight_layout()\n    if output_path is not None:\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n    return fig\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot_identity_colorbar","title":"<code>plot_identity_colorbar(palette='viridis', figsize=(1.5, 4.0), output_path=None, dpi=150, format=None)</code>","text":"<p>Render the identity colour scale as a standalone figure.</p> <p>Produces a figure containing only a vertical colorbar that maps identity values (0\u2013100 %) to colours from palette.  This is intended to be displayed alongside a dotplot produced with <code>color_by_identity=True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>palette</code> <code>str</code> <p>Matplotlib colormap name.  Should match the identity_palette used when calling :meth:<code>plot</code> or :meth:<code>plot_single</code>. Default is <code>'viridis'</code>.</p> <code>'viridis'</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size as <code>(width, height)</code> in inches. Default is <code>(1.5, 4.0)</code>.</p> <code>(1.5, 4.0)</code> <code>output_path</code> <code>str or Path</code> <p>Output image file path.  When <code>None</code> (default) the figure is not saved to disk.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Output image resolution. Default is <code>150</code>.</p> <code>150</code> <code>format</code> <code>str</code> <p>Output image format (e.g. <code>'png'</code>, <code>'svg'</code>, <code>'pdf'</code>). When <code>None</code> (default), the format is inferred from the <code>output_path</code> file extension.</p> <code>None</code> <p>Returns:</p> Type Description <code>Figure</code> <p>A figure containing only the colorbar.</p> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot_identity_colorbar(\n    self,\n    palette: str = 'viridis',\n    figsize: tuple[float, float] = (1.5, 4.0),\n    output_path: Optional[Union[str, Path]] = None,\n    dpi: int = 150,\n    format: Optional[str] = None,\n) -&gt; matplotlib.figure.Figure:\n    \"\"\"Render the identity colour scale as a standalone figure.\n\n    Produces a figure containing only a vertical colorbar that maps\n    identity values (0\u2013100 %) to colours from *palette*.  This is\n    intended to be displayed alongside a dotplot produced with\n    ``color_by_identity=True``.\n\n    Parameters\n    ----------\n    palette : str, optional\n        Matplotlib colormap name.  Should match the *identity_palette*\n        used when calling :meth:`plot` or :meth:`plot_single`.\n        Default is ``'viridis'``.\n    figsize : tuple[float, float], optional\n        Figure size as ``(width, height)`` in inches.\n        Default is ``(1.5, 4.0)``.\n    output_path : str or Path, optional\n        Output image file path.  When ``None`` (default) the figure is\n        not saved to disk.\n    dpi : int, optional\n        Output image resolution. Default is ``150``.\n    format : str, optional\n        Output image format (e.g. ``'png'``, ``'svg'``, ``'pdf'``).\n        When ``None`` (default), the format is inferred from the\n        ``output_path`` file extension.\n\n    Returns\n    -------\n    matplotlib.figure.Figure\n        A figure containing only the colorbar.\n    \"\"\"\n    norm = mcolors.Normalize(vmin=0, vmax=1)\n    sm = plt.cm.ScalarMappable(cmap=plt.get_cmap(palette), norm=norm)\n    sm.set_array([])\n    fig, ax = plt.subplots(figsize=figsize)\n    cb = fig.colorbar(sm, ax=ax, orientation='vertical')\n    cb.set_label('Identity', fontsize=10)\n    cb.set_ticks([0, 0.25, 0.5, 0.75, 1.0])\n    cb.set_ticklabels(['0%', '25%', '50%', '75%', '100%'])\n    ax.set_visible(False)\n    plt.tight_layout()\n    if output_path is not None:\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight', format=format)\n    return fig\n</code></pre>"},{"location":"api/functions/","title":"Low-Level Functions","text":"<p>These functions are implemented in Rust and exposed via PyO3. They provide fine-grained access to the underlying FM-index and k-mer machinery. For most use cases, the <code>SequenceIndex</code> class is more convenient.</p>"},{"location":"api/functions/#fasta-io","title":"FASTA I/O","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_read_fasta","title":"<code>py_read_fasta(path)</code>  <code>builtin</code>","text":"<p>Python binding: read sequences from a FASTA or gzipped FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the FASTA or FASTA.gz file.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping sequence name to sequence string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be opened, parsed, or contains duplicate sequence names.</p>"},{"location":"api/functions/#k-mer-operations","title":"K-mer Operations","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_build_kmer_set","title":"<code>py_build_kmer_set(seq, k)</code>  <code>builtin</code>","text":"<p>Python binding: build the set of unique k-mers in a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>The DNA sequence string (uppercase recommended).</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of unique k-mer strings found in the sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If k is 0 or the sequence is empty.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_find_kmer_coords","title":"<code>py_find_kmer_coords(seq, kmers)</code>  <code>builtin</code>","text":"<p>Python binding: find all positions of each k-mer in a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>The DNA sequence to search in.</p> required <code>kmers</code> <code>list[str]</code> <p>List of k-mer strings to search for.</p> required <p>Returns:</p> Type Description <code>dict[str, list[int]]</code> <p>Dictionary mapping each k-mer to its list of start positions (0-based).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is invalid or k-mers are inconsistent.</p>"},{"location":"api/functions/#merging-k-mer-runs","title":"Merging K-mer Runs","text":"<p>rusty-dot provides four merge functions covering all k-mer alignment orientations. <code>py_merge_runs</code> is the recommended entry-point for new code; the strand-specific functions are available for lower-level control.</p>"},{"location":"api/functions/#unified-entry-point","title":"Unified entry-point","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_runs","title":"<code>py_merge_runs(kmer_coords, query_kmer_positions, k, strand)</code>  <code>builtin</code>","text":"<p>Python binding: unified merge for both strand orientations.</p> <p>A single entry-point for merging k-mer coordinate runs on either the forward (<code>\"+\"```) or reverse-complement (</code>\"-\"<code>`) strand.  The function dispatches to :func:</code>merge_fwd_runs<code>for the forward strand.  For the reverse strand it applies **both** the anti-diagonal algorithm (:func:</code>merge_rev_runs<code>) and the co-diagonal algorithm (:func:</code>merge_rev_fwd_runs`), combining the results and deduplicating any identical blocks.</p> <p>For the forward strand, <code>kmer_coords</code> contains the positions of each k-mer in the target sequence and <code>query_kmer_positions</code> contains the positions of the same k-mers in the query sequence.</p> <p>For the reverse strand, <code>kmer_coords</code> should contain the positions of the reverse complement of each query k-mer in the target (as returned by <code>find_rev_coords_in_index</code>), and <code>query_kmer_positions</code> contains the positions of the original k-mers in the query.</p> <p>Parameters:</p> Name Type Description Default <code>kmer_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to 0-based target positions.  For <code>strand=\"-\"</code>, these are the positions of the RC of each k-mer in the target.</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to 0-based query positions.</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <code>strand</code> <code>str</code> <p>Orientation of the match: <code>\"+\"</code> for forward (co-linear diagonal) or <code>\"-\"</code> for reverse-complement (both anti-diagonal and co-diagonal patterns are merged and returned together).</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int, str]]</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> 5-tuples.  Coordinates are 0-based; end positions are exclusive. <code>strand</code> echoes the input argument so callers can mix results from multiple calls without losing orientation information.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>strand</code> is neither <code>\"+\"</code> nor <code>\"-\"</code>.</p>"},{"location":"api/functions/#forward-strand-merge","title":"Forward-strand merge","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_kmer_runs","title":"<code>py_merge_kmer_runs(kmer_coords, query_kmer_positions, k)</code>  <code>builtin</code>","text":"<p>Python binding: merge sequential k-mer coordinate runs (forward strand).</p> <p>Parameters:</p> Name Type Description Default <code>kmer_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to list of target start positions (0-based).</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to list of query start positions (0-based).</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of (query_start, query_end, target_start, target_end) tuples. Coordinates are 0-based, with end positions exclusive.</p>"},{"location":"api/functions/#reverse-complement-merges","title":"Reverse-complement merges","text":"<p>Two complementary algorithms cover all reverse-complement alignment patterns:</p> Pattern When to use <code>py_merge_rev_runs</code> RC target positions decrease as query advances (query +1, target \u22121 per step) \u2014 standard inverted-repeat alignment where the two arms face each other <code>py_merge_rev_fwd_runs</code> RC target positions increase as query advances (query +1, target +1 per step) \u2014 both repeat arms run in the same left-to-right direction <p><code>py_merge_runs(strand=\"-\")</code> calls both and deduplicates the results automatically.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_rev_runs","title":"<code>py_merge_rev_runs(target_rev_coords, query_kmer_positions, k)</code>  <code>builtin</code>","text":"<p>Python binding: merge reverse-complement (<code>-</code> strand) k-mer coordinate runs.</p> <p>For each k-mer, <code>target_rev_coords</code> should contain the positions in the target where the reverse complement of that k-mer was found (as returned by <code>find_rev_coords_in_index</code>).  Consecutive anti-diagonal pairs \u2014 where <code>query_pos</code> advances by 1 and the corresponding RC target position decreases by 1 \u2014 are merged into a single <code>CoordPair</code>.</p> <p>Parameters:</p> Name Type Description Default <code>target_rev_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to the 0-based start positions of its reverse complement in the target sequence.</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to its 0-based start positions in the query sequence.</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> tuples representing merged <code>-</code>-strand match regions.  Coordinates are 0-based with end positions exclusive.  <code>target_start</code> and <code>target_end</code> are the forward-strand boundaries of the RC match region on the target.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_rev_fwd_runs","title":"<code>py_merge_rev_fwd_runs(target_rev_coords, query_kmer_positions, k)</code>  <code>builtin</code>","text":"<p>Python binding: merge reverse-complement (<code>-</code> strand) k-mer coordinate runs that are co-linear on a forward diagonal (RC positions increase as query position increases).</p> <p>This is the complement of :func:<code>py_merge_rev_runs</code>, which handles the anti-diagonal case.  Together they cover all possible orientations of reverse-complement k-mer matches:</p> <ul> <li><code>py_merge_rev_runs</code> \u2014 anti-diagonal: <code>q</code> advances +1, <code>t_rc</code> decreases by 1   (standard inverted-repeat / reverse-complement alignment).</li> <li><code>py_merge_rev_fwd_runs</code> \u2014 forward diagonal: <code>q</code> advances +1, <code>t_rc</code> also   advances +1 (inverted-repeat case where both arms run in the same direction).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>target_rev_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to the 0-based start positions of its reverse complement in the target sequence (as returned by <code>find_rev_coords_in_index</code>).</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to its 0-based start positions in the query sequence.</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> tuples representing merged <code>-</code>-strand match regions where RC target positions advance together with query positions.  Coordinates are 0-based with end positions exclusive.</p>"},{"location":"api/functions/#paf-formatting","title":"PAF Formatting","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_coords_to_paf","title":"<code>py_coords_to_paf(matches, query_name, query_len, target_name, target_len)</code>  <code>builtin</code>","text":"<p>Python binding: convert coordinate tuples to PAF format strings.</p> <p>Parameters:</p> Name Type Description Default <code>matches</code> <code>list[tuple[int, int, int, int]]</code> <p>List of (query_start, query_end, target_start, target_end) tuples.</p> required <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>query_len</code> <code>int</code> <p>Total length of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>target_len</code> <code>int</code> <p>Total length of the target sequence.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of PAF format lines (tab-separated).</p>"},{"location":"api/functions/#index-serialization","title":"Index Serialization","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_save_index","title":"<code>py_save_index(path, sequences, k)</code>  <code>builtin</code>","text":"<p>Python binding: save an index collection to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to save the serialized index.</p> required <code>sequences</code> <code>dict[str, str]</code> <p>Dictionary of sequence name to sequence string.</p> required <code>k</code> <code>int</code> <p>The k-mer length used to build the index.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_load_index","title":"<code>py_load_index(path)</code>  <code>builtin</code>","text":"<p>Python binding: load an index collection from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the serialized index file.</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, list[str]], int]</code> <p>A tuple of (kmer_sets_dict, k) where kmer_sets_dict maps sequence names to their k-mer lists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If deserialization fails.</p>"},{"location":"api/paf_io/","title":"PAF I/O","text":"<p>This module provides classes and helpers for reading, writing, and reordering PAF (Pairwise mApping Format) alignment records.</p>"},{"location":"api/paf_io/#pafalignment-alignment-record-collection","title":"PafAlignment \u2014 Alignment record collection","text":"<p><code>PafAlignment</code> wraps a list of :class:<code>~rusty_dot.paf_io.PafRecord</code> objects and provides filtering, contig reordering, and sequence-length lookup utilities.  It can be passed directly to :class:<code>~rusty_dot.dotplot.DotPlotter</code> \u2014 no :class:<code>~rusty_dot.SequenceIndex</code> is required:</p> <pre><code>from rusty_dot.paf_io import PafAlignment\nfrom rusty_dot.dotplot import DotPlotter\n\naln = PafAlignment.from_file(\"alignments.paf\")\nq_order, t_order = aln.reorder_contigs()\n\nplotter = DotPlotter(aln)\nplotter.plot(\n    query_names=q_order,\n    target_names=t_order,\n    output_path=\"dotplot.png\",\n    scale_sequences=True,\n)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord","title":"<code>PafRecord</code>  <code>dataclass</code>","text":"<p>A single PAF alignment record.</p> <p>The twelve required PAF columns are represented as typed attributes. Optional SAM-like tags (e.g. <code>tp:A:P</code>, <code>cg:Z:10M</code>) are stored in :attr:<code>tags</code>.  If a <code>cg:Z:</code> tag is present, CIGAR-derived alignment statistics are populated automatically.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Query sequence name (column 1).</p> required <code>query_len</code> <code>int</code> <p>Query sequence length (column 2).</p> required <code>query_start</code> <code>int</code> <p>Query start position, 0-based (column 3).</p> required <code>query_end</code> <code>int</code> <p>Query end position, exclusive (column 4).</p> required <code>strand</code> <code>str</code> <p>Relative strand: <code>\"+\"</code> or <code>\"-\"</code> (column 5).</p> required <code>target_name</code> <code>str</code> <p>Target sequence name (column 6).</p> required <code>target_len</code> <code>int</code> <p>Target sequence length (column 7).</p> required <code>target_start</code> <code>int</code> <p>Target start position, 0-based (column 8).</p> required <code>target_end</code> <code>int</code> <p>Target end position, exclusive (column 9).</p> required <code>residue_matches</code> <code>int</code> <p>Number of residue matches (column 10).</p> required <code>alignment_block_len</code> <code>int</code> <p>Number of bases in the alignment block (column 11).</p> required <code>mapping_quality</code> <code>int</code> <p>Mapping quality (0\u2013255; 255 = missing) (column 12).</p> required <code>tags</code> <code>dict[str, Any]</code> <p>Optional SAM-like tags decoded as <code>{tag_name: value}</code>.</p> <code>dict()</code> <code>cigar</code> <code>str or None</code> <p>CIGAR string from <code>cg:Z:</code> tag, or <code>None</code> if absent.</p> <code>None</code> <code>alignment_length</code> <code>int or None</code> <p>Target-span alignment length derived from CIGAR, or <code>None</code>.</p> <code>None</code> <code>n_matches</code> <code>int or None</code> <p>Count of exact-match bases (<code>=</code> ops) from CIGAR; falls back to <code>residue_matches</code> when only <code>M</code> ops are present.</p> <code>None</code> <code>n_mismatches</code> <code>int or None</code> <p>Count of mismatch bases (<code>X</code> ops) from CIGAR, or <code>None</code>.</p> <code>None</code> <code>n_gaps</code> <code>int or None</code> <p>Total number of gap bases (<code>I</code> + <code>D</code> bases) from CIGAR.</p> <code>None</code> <code>n_gap_bases</code> <code>int or None</code> <p>Same as <code>n_gaps</code> (alias kept for clarity).</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@dataclass\nclass PafRecord:\n    \"\"\"A single PAF alignment record.\n\n    The twelve required PAF columns are represented as typed attributes.\n    Optional SAM-like tags (e.g. ``tp:A:P``, ``cg:Z:10M``) are stored in\n    :attr:`tags`.  If a ``cg:Z:`` tag is present, CIGAR-derived alignment\n    statistics are populated automatically.\n\n    Parameters\n    ----------\n    query_name : str\n        Query sequence name (column 1).\n    query_len : int\n        Query sequence length (column 2).\n    query_start : int\n        Query start position, 0-based (column 3).\n    query_end : int\n        Query end position, exclusive (column 4).\n    strand : str\n        Relative strand: ``\"+\"`` or ``\"-\"`` (column 5).\n    target_name : str\n        Target sequence name (column 6).\n    target_len : int\n        Target sequence length (column 7).\n    target_start : int\n        Target start position, 0-based (column 8).\n    target_end : int\n        Target end position, exclusive (column 9).\n    residue_matches : int\n        Number of residue matches (column 10).\n    alignment_block_len : int\n        Number of bases in the alignment block (column 11).\n    mapping_quality : int\n        Mapping quality (0\u2013255; 255 = missing) (column 12).\n    tags : dict[str, Any]\n        Optional SAM-like tags decoded as ``{tag_name: value}``.\n    cigar : str or None\n        CIGAR string from ``cg:Z:`` tag, or ``None`` if absent.\n    alignment_length : int or None\n        Target-span alignment length derived from CIGAR, or ``None``.\n    n_matches : int or None\n        Count of exact-match bases (``=`` ops) from CIGAR; falls back to\n        ``residue_matches`` when only ``M`` ops are present.\n    n_mismatches : int or None\n        Count of mismatch bases (``X`` ops) from CIGAR, or ``None``.\n    n_gaps : int or None\n        Total number of gap bases (``I`` + ``D`` bases) from CIGAR.\n    n_gap_bases : int or None\n        Same as ``n_gaps`` (alias kept for clarity).\n    \"\"\"\n\n    query_name: str\n    query_len: int\n    query_start: int\n    query_end: int\n    strand: str\n    target_name: str\n    target_len: int\n    target_start: int\n    target_end: int\n    residue_matches: int\n    alignment_block_len: int\n    mapping_quality: int\n    tags: dict[str, Any] = field(default_factory=dict)\n    cigar: str | None = None\n    alignment_length: int | None = None\n    n_matches: int | None = None\n    n_mismatches: int | None = None\n    n_gaps: int | None = None\n    n_gap_bases: int | None = None\n\n    @property\n    def query_aligned_len(self) -&gt; int:\n        \"\"\"Return the aligned length on the query sequence.\n\n        Returns\n        -------\n        int\n            ``query_end - query_start``.\n        \"\"\"\n        return self.query_end - self.query_start\n\n    @property\n    def target_aligned_len(self) -&gt; int:\n        \"\"\"Return the aligned length on the target sequence.\n\n        Returns\n        -------\n        int\n            ``target_end - target_start``.\n        \"\"\"\n        return self.target_end - self.target_start\n\n    @classmethod\n    def from_line(cls, line: str) -&gt; 'PafRecord':\n        \"\"\"Parse a single PAF text line into a :class:`PafRecord`.\n\n        Parameters\n        ----------\n        line : str\n            A single PAF record line (tab-separated, trailing newline optional).\n\n        Returns\n        -------\n        PafRecord\n            The parsed record.\n\n        Raises\n        ------\n        ValueError\n            If the line has fewer than 12 tab-separated fields.\n        \"\"\"\n        fields = line.rstrip('\\n').split('\\t')\n        if len(fields) &lt; 12:\n            raise ValueError(\n                f'PAF line has {len(fields)} fields; expected at least 12: {line!r}'\n            )\n        tags: dict[str, Any] = {}\n        cigar: str | None = None\n        for tag_field in fields[12:]:\n            parts = tag_field.split(':', 2)\n            if len(parts) == 3:\n                tag_name, tag_type, tag_value = parts\n                if tag_type == 'i':\n                    tags[tag_name] = int(tag_value)\n                elif tag_type == 'f':\n                    tags[tag_name] = float(tag_value)\n                else:\n                    tags[tag_name] = tag_value\n                if tag_name == 'cg' and tag_type == 'Z':\n                    cigar = tag_value\n\n        residue_matches = int(fields[9])\n        stats: dict[str, int] = {}\n        if cigar is not None:\n            stats = _cigar_stats(cigar, residue_matches)\n\n        return cls(\n            query_name=fields[0],\n            query_len=int(fields[1]),\n            query_start=int(fields[2]),\n            query_end=int(fields[3]),\n            strand=fields[4],\n            target_name=fields[5],\n            target_len=int(fields[6]),\n            target_start=int(fields[7]),\n            target_end=int(fields[8]),\n            residue_matches=residue_matches,\n            alignment_block_len=int(fields[10]),\n            mapping_quality=int(fields[11]),\n            tags=tags,\n            cigar=cigar,\n            alignment_length=stats.get('alignment_length'),\n            n_matches=stats.get('n_matches'),\n            n_mismatches=stats.get('n_mismatches'),\n            n_gaps=stats.get('n_gaps'),\n            n_gap_bases=stats.get('n_gap_bases'),\n        )\n\n    def to_line(self) -&gt; str:\n        \"\"\"Serialise this record back to a PAF-format string (no trailing newline).\n\n        Returns\n        -------\n        str\n            Tab-separated PAF line with the 12 required columns.  Optional\n            tags are not included.\n        \"\"\"\n        return '\\t'.join(\n            str(v)\n            for v in [\n                self.query_name,\n                self.query_len,\n                self.query_start,\n                self.query_end,\n                self.strand,\n                self.target_name,\n                self.target_len,\n                self.target_start,\n                self.target_end,\n                self.residue_matches,\n                self.alignment_block_len,\n                self.mapping_quality,\n            ]\n        )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.query_aligned_len","title":"<code>query_aligned_len</code>  <code>property</code>","text":"<p>Return the aligned length on the query sequence.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>query_end - query_start</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.target_aligned_len","title":"<code>target_aligned_len</code>  <code>property</code>","text":"<p>Return the aligned length on the target sequence.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>target_end - target_start</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Parse a single PAF text line into a :class:<code>PafRecord</code>.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A single PAF record line (tab-separated, trailing newline optional).</p> required <p>Returns:</p> Type Description <code>PafRecord</code> <p>The parsed record.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the line has fewer than 12 tab-separated fields.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_line(cls, line: str) -&gt; 'PafRecord':\n    \"\"\"Parse a single PAF text line into a :class:`PafRecord`.\n\n    Parameters\n    ----------\n    line : str\n        A single PAF record line (tab-separated, trailing newline optional).\n\n    Returns\n    -------\n    PafRecord\n        The parsed record.\n\n    Raises\n    ------\n    ValueError\n        If the line has fewer than 12 tab-separated fields.\n    \"\"\"\n    fields = line.rstrip('\\n').split('\\t')\n    if len(fields) &lt; 12:\n        raise ValueError(\n            f'PAF line has {len(fields)} fields; expected at least 12: {line!r}'\n        )\n    tags: dict[str, Any] = {}\n    cigar: str | None = None\n    for tag_field in fields[12:]:\n        parts = tag_field.split(':', 2)\n        if len(parts) == 3:\n            tag_name, tag_type, tag_value = parts\n            if tag_type == 'i':\n                tags[tag_name] = int(tag_value)\n            elif tag_type == 'f':\n                tags[tag_name] = float(tag_value)\n            else:\n                tags[tag_name] = tag_value\n            if tag_name == 'cg' and tag_type == 'Z':\n                cigar = tag_value\n\n    residue_matches = int(fields[9])\n    stats: dict[str, int] = {}\n    if cigar is not None:\n        stats = _cigar_stats(cigar, residue_matches)\n\n    return cls(\n        query_name=fields[0],\n        query_len=int(fields[1]),\n        query_start=int(fields[2]),\n        query_end=int(fields[3]),\n        strand=fields[4],\n        target_name=fields[5],\n        target_len=int(fields[6]),\n        target_start=int(fields[7]),\n        target_end=int(fields[8]),\n        residue_matches=residue_matches,\n        alignment_block_len=int(fields[10]),\n        mapping_quality=int(fields[11]),\n        tags=tags,\n        cigar=cigar,\n        alignment_length=stats.get('alignment_length'),\n        n_matches=stats.get('n_matches'),\n        n_mismatches=stats.get('n_mismatches'),\n        n_gaps=stats.get('n_gaps'),\n        n_gap_bases=stats.get('n_gap_bases'),\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.to_line","title":"<code>to_line()</code>","text":"<p>Serialise this record back to a PAF-format string (no trailing newline).</p> <p>Returns:</p> Type Description <code>str</code> <p>Tab-separated PAF line with the 12 required columns.  Optional tags are not included.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def to_line(self) -&gt; str:\n    \"\"\"Serialise this record back to a PAF-format string (no trailing newline).\n\n    Returns\n    -------\n    str\n        Tab-separated PAF line with the 12 required columns.  Optional\n        tags are not included.\n    \"\"\"\n    return '\\t'.join(\n        str(v)\n        for v in [\n            self.query_name,\n            self.query_len,\n            self.query_start,\n            self.query_end,\n            self.strand,\n            self.target_name,\n            self.target_len,\n            self.target_start,\n            self.target_end,\n            self.residue_matches,\n            self.alignment_block_len,\n            self.mapping_quality,\n        ]\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment","title":"<code>PafAlignment</code>","text":"<p>A collection of PAF alignment records with contig-ordering utilities.</p> <p>Can be constructed from a file path or an iterable of :class:<code>PafRecord</code> objects.  Provides :meth:<code>reorder_contigs</code> to sort query and target sequence names so that a subsequent dotplot shows maximum collinearity.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>list of PafRecord</code> <p>The alignment records.</p> required <p>Examples:</p> <p>Load from a file and reorder contigs:</p> <pre><code>&gt;&gt;&gt; aln = PafAlignment.from_file(\"alignments.paf\")\n&gt;&gt;&gt; q_order, t_order = aln.reorder_contigs(aln.query_names, aln.target_names)\n</code></pre> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>class PafAlignment:\n    \"\"\"A collection of PAF alignment records with contig-ordering utilities.\n\n    Can be constructed from a file path or an iterable of :class:`PafRecord`\n    objects.  Provides :meth:`reorder_contigs` to sort query and target\n    sequence names so that a subsequent dotplot shows maximum collinearity.\n\n    Parameters\n    ----------\n    records : list of PafRecord\n        The alignment records.\n\n    Examples\n    --------\n    Load from a file and reorder contigs:\n\n    &gt;&gt;&gt; aln = PafAlignment.from_file(\"alignments.paf\")\n    &gt;&gt;&gt; q_order, t_order = aln.reorder_contigs(aln.query_names, aln.target_names)\n    \"\"\"\n\n    def __init__(self, records: list[PafRecord]) -&gt; None:\n        self.records: list[PafRecord] = records\n\n    # ------------------------------------------------------------------\n    # Constructors\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_file(cls, path: str | Path) -&gt; 'PafAlignment':\n        \"\"\"Load records from a PAF file.\n\n        Parameters\n        ----------\n        path : str or Path\n            Path to the PAF file.\n\n        Returns\n        -------\n        PafAlignment\n            New instance with all records loaded.\n        \"\"\"\n        return cls(list(parse_paf_file(path)))\n\n    @classmethod\n    def from_records(cls, records: Iterable[PafRecord]) -&gt; 'PafAlignment':\n        \"\"\"Construct from an iterable of :class:`PafRecord` objects.\n\n        Parameters\n        ----------\n        records : iterable of PafRecord\n            Source records.\n\n        Returns\n        -------\n        PafAlignment\n            New instance.\n        \"\"\"\n        return cls(list(records))\n\n    # ------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------\n\n    @property\n    def query_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of query sequence names (insertion order).\n\n        Returns\n        -------\n        list[str]\n            Unique query names in the order first seen.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.query_name] = None\n        return list(seen)\n\n    @property\n    def target_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of target sequence names (insertion order).\n\n        Returns\n        -------\n        list[str]\n            Unique target names in the order first seen.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.target_name] = None\n        return list(seen)\n\n    def sequence_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of all query and target sequence names.\n\n        The list contains each name at most once, in the order it was first\n        encountered (queries before targets within each record).  This method\n        makes :class:`PafAlignment` compatible with :class:`~rusty_dot.dotplot.DotPlotter`.\n\n        Returns\n        -------\n        list[str]\n            All unique sequence names across query and target fields.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.query_name] = None\n            seen[rec.target_name] = None\n        return list(seen)\n\n    def get_sequence_length(self, name: str) -&gt; int:\n        \"\"\"Return the length of a sequence by name as stored in PAF records.\n\n        Looks up *name* in the ``query_name`` and ``target_name`` fields of\n        every record and returns the corresponding ``query_len`` or\n        ``target_len``.  This method makes :class:`PafAlignment` compatible\n        with :class:`~rusty_dot.dotplot.DotPlotter`.\n\n        Parameters\n        ----------\n        name : str\n            Sequence name to look up.\n\n        Returns\n        -------\n        int\n            Length of the sequence.\n\n        Raises\n        ------\n        KeyError\n            If *name* is not found in any record.\n        \"\"\"\n        for rec in self.records:\n            if rec.query_name == name:\n                return rec.query_len\n            if rec.target_name == name:\n                return rec.target_len\n        raise KeyError(f'Sequence {name!r} not found in PAF records.')\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of records.\n\n        Returns\n        -------\n        int\n            Record count.\n        \"\"\"\n        return len(self.records)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise string representation.\n\n        Returns\n        -------\n        str\n            ``PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)``.\n        \"\"\"\n        return (\n            f'PafAlignment(records={len(self.records)}, '\n            f'queries={len(self.query_names)}, '\n            f'targets={len(self.target_names)})'\n        )\n\n    # ------------------------------------------------------------------\n    # Filtering\n    # ------------------------------------------------------------------\n\n    def filter_by_query(self, names: Iterable[str]) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` containing only the given query names.\n\n        Parameters\n        ----------\n        names : iterable of str\n            Query names to keep.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment.\n        \"\"\"\n        keep = set(names)\n        return PafAlignment([r for r in self.records if r.query_name in keep])\n\n    def filter_by_target(self, names: Iterable[str]) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` containing only the given target names.\n\n        Parameters\n        ----------\n        names : iterable of str\n            Target names to keep.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment.\n        \"\"\"\n        keep = set(names)\n        return PafAlignment([r for r in self.records if r.target_name in keep])\n\n    def filter_by_min_length(self, min_length: int) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` keeping only records of sufficient length.\n\n        Filters on the query aligned length (``query_end - query_start``), which\n        equals the alignment block span for both merged k-mer runs and PAF\n        alignments imported from a file.\n\n        Parameters\n        ----------\n        min_length : int\n            Minimum alignment length (inclusive).  Records with a query aligned\n            length strictly less than ``min_length`` are discarded.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment containing only records with\n            ``query_aligned_len &gt;= min_length``.\n        \"\"\"\n        return PafAlignment(\n            [r for r in self.records if r.query_aligned_len &gt;= min_length]\n        )\n\n    # ------------------------------------------------------------------\n    # Contig reordering\n    # ------------------------------------------------------------------\n\n    def reorder_contigs(\n        self,\n        query_names: list[str] | None = None,\n        target_names: list[str] | None = None,\n    ) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Sort query and target contigs to maximise collinearity in the dotplot.\n\n        Uses the gravity-centre algorithm: each contig is assigned a gravity\n        equal to the weighted mean position of its alignment blocks on the\n        opposing axis.  Contigs are then sorted by ascending gravity.\n\n        Parameters\n        ----------\n        query_names : list[str] or None, optional\n            Query contigs to reorder.  Defaults to :attr:`query_names`.\n        target_names : list[str] or None, optional\n            Target contigs to reorder.  Defaults to :attr:`target_names`.\n\n        Returns\n        -------\n        tuple[list[str], list[str]]\n            ``(sorted_query_names, sorted_target_names)``.\n        \"\"\"\n        q = query_names if query_names is not None else self.query_names\n        t = target_names if target_names is not None else self.target_names\n        return compute_gravity_contigs(self.records, q, t)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.query_names","title":"<code>query_names</code>  <code>property</code>","text":"<p>Return a deduplicated list of query sequence names (insertion order).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unique query names in the order first seen.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.target_names","title":"<code>target_names</code>  <code>property</code>","text":"<p>Return a deduplicated list of target sequence names (insertion order).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unique target names in the order first seen.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load records from a PAF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the PAF file.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>New instance with all records loaded.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; 'PafAlignment':\n    \"\"\"Load records from a PAF file.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the PAF file.\n\n    Returns\n    -------\n    PafAlignment\n        New instance with all records loaded.\n    \"\"\"\n    return cls(list(parse_paf_file(path)))\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.from_records","title":"<code>from_records(records)</code>  <code>classmethod</code>","text":"<p>Construct from an iterable of :class:<code>PafRecord</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable of PafRecord</code> <p>Source records.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>New instance.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_records(cls, records: Iterable[PafRecord]) -&gt; 'PafAlignment':\n    \"\"\"Construct from an iterable of :class:`PafRecord` objects.\n\n    Parameters\n    ----------\n    records : iterable of PafRecord\n        Source records.\n\n    Returns\n    -------\n    PafAlignment\n        New instance.\n    \"\"\"\n    return cls(list(records))\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.sequence_names","title":"<code>sequence_names()</code>","text":"<p>Return a deduplicated list of all query and target sequence names.</p> <p>The list contains each name at most once, in the order it was first encountered (queries before targets within each record).  This method makes :class:<code>PafAlignment</code> compatible with :class:<code>~rusty_dot.dotplot.DotPlotter</code>.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>All unique sequence names across query and target fields.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def sequence_names(self) -&gt; list[str]:\n    \"\"\"Return a deduplicated list of all query and target sequence names.\n\n    The list contains each name at most once, in the order it was first\n    encountered (queries before targets within each record).  This method\n    makes :class:`PafAlignment` compatible with :class:`~rusty_dot.dotplot.DotPlotter`.\n\n    Returns\n    -------\n    list[str]\n        All unique sequence names across query and target fields.\n    \"\"\"\n    seen: dict[str, None] = {}\n    for rec in self.records:\n        seen[rec.query_name] = None\n        seen[rec.target_name] = None\n    return list(seen)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.get_sequence_length","title":"<code>get_sequence_length(name)</code>","text":"<p>Return the length of a sequence by name as stored in PAF records.</p> <p>Looks up name in the <code>query_name</code> and <code>target_name</code> fields of every record and returns the corresponding <code>query_len</code> or <code>target_len</code>.  This method makes :class:<code>PafAlignment</code> compatible with :class:<code>~rusty_dot.dotplot.DotPlotter</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Sequence name to look up.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Length of the sequence.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If name is not found in any record.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_sequence_length(self, name: str) -&gt; int:\n    \"\"\"Return the length of a sequence by name as stored in PAF records.\n\n    Looks up *name* in the ``query_name`` and ``target_name`` fields of\n    every record and returns the corresponding ``query_len`` or\n    ``target_len``.  This method makes :class:`PafAlignment` compatible\n    with :class:`~rusty_dot.dotplot.DotPlotter`.\n\n    Parameters\n    ----------\n    name : str\n        Sequence name to look up.\n\n    Returns\n    -------\n    int\n        Length of the sequence.\n\n    Raises\n    ------\n    KeyError\n        If *name* is not found in any record.\n    \"\"\"\n    for rec in self.records:\n        if rec.query_name == name:\n            return rec.query_len\n        if rec.target_name == name:\n            return rec.target_len\n    raise KeyError(f'Sequence {name!r} not found in PAF records.')\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of records.</p> <p>Returns:</p> Type Description <code>int</code> <p>Record count.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of records.\n\n    Returns\n    -------\n    int\n        Record count.\n    \"\"\"\n    return len(self.records)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise string representation.\n\n    Returns\n    -------\n    str\n        ``PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)``.\n    \"\"\"\n    return (\n        f'PafAlignment(records={len(self.records)}, '\n        f'queries={len(self.query_names)}, '\n        f'targets={len(self.target_names)})'\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_query","title":"<code>filter_by_query(names)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> containing only the given query names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>iterable of str</code> <p>Query names to keep.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_query(self, names: Iterable[str]) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` containing only the given query names.\n\n    Parameters\n    ----------\n    names : iterable of str\n        Query names to keep.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment.\n    \"\"\"\n    keep = set(names)\n    return PafAlignment([r for r in self.records if r.query_name in keep])\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_target","title":"<code>filter_by_target(names)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> containing only the given target names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>iterable of str</code> <p>Target names to keep.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_target(self, names: Iterable[str]) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` containing only the given target names.\n\n    Parameters\n    ----------\n    names : iterable of str\n        Target names to keep.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment.\n    \"\"\"\n    keep = set(names)\n    return PafAlignment([r for r in self.records if r.target_name in keep])\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_min_length","title":"<code>filter_by_min_length(min_length)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> keeping only records of sufficient length.</p> <p>Filters on the query aligned length (<code>query_end - query_start</code>), which equals the alignment block span for both merged k-mer runs and PAF alignments imported from a file.</p> <p>Parameters:</p> Name Type Description Default <code>min_length</code> <code>int</code> <p>Minimum alignment length (inclusive).  Records with a query aligned length strictly less than <code>min_length</code> are discarded.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment containing only records with <code>query_aligned_len &gt;= min_length</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_min_length(self, min_length: int) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` keeping only records of sufficient length.\n\n    Filters on the query aligned length (``query_end - query_start``), which\n    equals the alignment block span for both merged k-mer runs and PAF\n    alignments imported from a file.\n\n    Parameters\n    ----------\n    min_length : int\n        Minimum alignment length (inclusive).  Records with a query aligned\n        length strictly less than ``min_length`` are discarded.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment containing only records with\n        ``query_aligned_len &gt;= min_length``.\n    \"\"\"\n    return PafAlignment(\n        [r for r in self.records if r.query_aligned_len &gt;= min_length]\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.reorder_contigs","title":"<code>reorder_contigs(query_names=None, target_names=None)</code>","text":"<p>Sort query and target contigs to maximise collinearity in the dotplot.</p> <p>Uses the gravity-centre algorithm: each contig is assigned a gravity equal to the weighted mean position of its alignment blocks on the opposing axis.  Contigs are then sorted by ascending gravity.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str] or None</code> <p>Query contigs to reorder.  Defaults to :attr:<code>query_names</code>.</p> <code>None</code> <code>target_names</code> <code>list[str] or None</code> <p>Target contigs to reorder.  Defaults to :attr:<code>target_names</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_contigs(\n    self,\n    query_names: list[str] | None = None,\n    target_names: list[str] | None = None,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Sort query and target contigs to maximise collinearity in the dotplot.\n\n    Uses the gravity-centre algorithm: each contig is assigned a gravity\n    equal to the weighted mean position of its alignment blocks on the\n    opposing axis.  Contigs are then sorted by ascending gravity.\n\n    Parameters\n    ----------\n    query_names : list[str] or None, optional\n        Query contigs to reorder.  Defaults to :attr:`query_names`.\n    target_names : list[str] or None, optional\n        Target contigs to reorder.  Defaults to :attr:`target_names`.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)``.\n    \"\"\"\n    q = query_names if query_names is not None else self.query_names\n    t = target_names if target_names is not None else self.target_names\n    return compute_gravity_contigs(self.records, q, t)\n</code></pre>"},{"location":"api/paf_io/#functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.parse_paf_file","title":"<code>parse_paf_file(path)</code>","text":"<p>Yield :class:<code>PafRecord</code> objects from a PAF file.</p> <p>Lines beginning with <code>#</code> are treated as comments and skipped.  Empty lines are also skipped.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the PAF file.</p> required <p>Yields:</p> Type Description <code>PafRecord</code> <p>One record per non-comment, non-empty line.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If <code>path</code> does not exist.</p> <code>ValueError</code> <p>If a line cannot be parsed as a PAF record.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def parse_paf_file(path: str | Path) -&gt; Generator[PafRecord, None, None]:\n    \"\"\"Yield :class:`PafRecord` objects from a PAF file.\n\n    Lines beginning with ``#`` are treated as comments and skipped.  Empty\n    lines are also skipped.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the PAF file.\n\n    Yields\n    ------\n    PafRecord\n        One record per non-comment, non-empty line.\n\n    Raises\n    ------\n    FileNotFoundError\n        If ``path`` does not exist.\n    ValueError\n        If a line cannot be parsed as a PAF record.\n    \"\"\"\n    path = Path(path)\n    with path.open('r', encoding='utf-8') as fh:\n        for line in fh:\n            line = line.rstrip('\\n')\n            if not line or line.startswith('#'):\n                continue\n            yield PafRecord.from_line(line)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.compute_gravity_contigs","title":"<code>compute_gravity_contigs(records, query_names, target_names)</code>","text":"<p>Return query and target contig names sorted by gravity centre.</p> <p>For each query contig the gravity centre is the weighted mean of target mid-point positions (normalised by the total target span) across all alignment records that involve that contig.  Target contigs are sorted symmetrically against the query axis.</p> <p>Contigs with no alignment records receive a gravity of <code>float(\"inf\")</code> and are placed at the end of the sorted list.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable of PafRecord</code> <p>Alignment records to use for computing gravity centres.</p> required <code>query_names</code> <code>list[str]</code> <p>The query contig names to reorder.</p> required <code>target_names</code> <code>list[str]</code> <p>The target contig names to reorder.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> ordered by ascending gravity centre.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def compute_gravity_contigs(\n    records: Iterable[PafRecord],\n    query_names: list[str],\n    target_names: list[str],\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Return query and target contig names sorted by gravity centre.\n\n    For each query contig the gravity centre is the weighted mean of target\n    mid-point positions (normalised by the total target span) across all\n    alignment records that involve that contig.  Target contigs are sorted\n    symmetrically against the query axis.\n\n    Contigs with no alignment records receive a gravity of ``float(\"inf\")``\n    and are placed at the end of the sorted list.\n\n    Parameters\n    ----------\n    records : iterable of PafRecord\n        Alignment records to use for computing gravity centres.\n    query_names : list[str]\n        The query contig names to reorder.\n    target_names : list[str]\n        The target contig names to reorder.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)`` ordered by ascending\n        gravity centre.\n    \"\"\"\n    query_set = set(query_names)\n    target_set = set(target_names)\n\n    # Collect all records into a list and build sequence-length maps from them.\n    q_len_map: dict[str, int] = {}\n    t_len_map: dict[str, int] = {}\n    all_records: list[PafRecord] = []\n    for rec in records:\n        all_records.append(rec)\n        q_len_map[rec.query_name] = rec.query_len\n        t_len_map[rec.target_name] = rec.target_len\n\n    # Build cumulative target offsets using actual sequence lengths.\n    t_offsets: dict[str, int] = {}\n    t_off = 0\n    for t in target_names:\n        t_offsets[t] = t_off\n        t_off += t_len_map.get(t, 1)\n    total_target_len = max(t_off, 1)\n\n    # Build cumulative query offsets using actual sequence lengths.\n    q_offsets_real: dict[str, int] = {}\n    q_off = 0\n    for q in query_names:\n        q_offsets_real[q] = q_off\n        q_off += q_len_map.get(q, 1)\n    total_query_len = max(q_off, 1)\n\n    # Accumulate weighted positions.\n    q_weight: dict[str, float] = dict.fromkeys(query_names, 0.0)\n    q_wpos: dict[str, float] = dict.fromkeys(query_names, 0.0)\n    t_weight: dict[str, float] = dict.fromkeys(target_names, 0.0)\n    t_wpos: dict[str, float] = dict.fromkeys(target_names, 0.0)\n\n    for rec in all_records:\n        if rec.query_name not in query_set or rec.target_name not in target_set:\n            continue\n        size = float(rec.alignment_block_len or (rec.query_end - rec.query_start))\n        if size &lt;= 0:\n            continue\n\n        # Target gravity from query's perspective.\n        t_mid = (\n            t_offsets.get(rec.target_name, 0)\n            + (rec.target_start + rec.target_end) / 2.0\n        )\n        q_weight[rec.query_name] += size\n        q_wpos[rec.query_name] += size * t_mid\n\n        # Query gravity from target's perspective.\n        q_mid = (\n            q_offsets_real.get(rec.query_name, 0)\n            + (rec.query_start + rec.query_end) / 2.0\n        )\n        t_weight[rec.target_name] += size\n        t_wpos[rec.target_name] += size * q_mid\n\n    def _gravity(name: str, wt: dict, wp: dict, total: float) -&gt; float:\n        w = wt.get(name, 0.0)\n        return (wp.get(name, 0.0) / w / total) if w &gt; 0 else float('inf')\n\n    def _sort_key_with_len(\n        name: str,\n        wt: dict,\n        wp: dict,\n        total: float,\n        len_map: dict,\n    ) -&gt; tuple:\n        g = _gravity(name, wt, wp, total)\n        if g == float('inf'):\n            # Unmatched: sort after matched (1 &gt; 0), then by descending length\n            return (1, -len_map.get(name, 0))\n        return (0, g)\n\n    sorted_q = sorted(\n        query_names,\n        key=lambda n: _sort_key_with_len(\n            n, q_weight, q_wpos, total_target_len, q_len_map\n        ),\n    )\n    sorted_t = sorted(\n        target_names,\n        key=lambda n: _sort_key_with_len(\n            n, t_weight, t_wpos, total_query_len, t_len_map\n        ),\n    )\n    return sorted_q, sorted_t\n</code></pre>"},{"location":"api/sequence_index/","title":"SequenceIndex","text":"<p>The <code>SequenceIndex</code> class is the primary interface for building and querying FM-index-backed sequence comparison data. It is implemented in Rust (via PyO3) for maximum performance.</p>"},{"location":"api/sequence_index/#how-multiple-sequences-are-stored","title":"How multiple sequences are stored","text":"<p>Each sequence added to a <code>SequenceIndex</code> receives its own independent FM-index, built by rust-bio. The rust-bio FM-index is a read-only data structure that is constructed once for a given sequence and cannot be extended or updated after construction.</p> <p>This means:</p> <ul> <li>Adding sequences accumulates independent indexes. Calling <code>add_sequence</code> or <code>load_fasta</code> multiple times grows the collection \u2014 each call creates a new, isolated FM-index for that sequence only and does not affect any existing FM-index.</li> <li><code>load_fasta</code> can be called multiple times. Each call parses a file and adds its sequences to the collection, preserving all sequences that were added previously. Two calls on two separate FASTA files will leave the index containing all sequences from both files.</li> <li>Re-using a name emits a warning and overwrites. If <code>add_sequence</code> or a FASTA record uses a name that already exists in the index, a <code>UserWarning</code> is emitted and the existing entry (and its FM-index) is replaced with a new one for the new sequence.</li> <li>Duplicate names within a FASTA file raise an error. If a FASTA file contains two records with the same sequence name, <code>load_fasta</code> raises a <code>ValueError</code> before adding any sequences from that file to the index.</li> <li>Pairwise comparisons use two independent FM-indexes. <code>compare_sequences</code> and <code>compare_sequences_stranded</code> look up the two named sequences from the dictionary and compare their individual FM-indexes \u2014 no combined or merged FM-index is ever created.</li> </ul> <pre><code>from rusty_dot import SequenceIndex\nimport warnings\n\nidx = SequenceIndex(k=15)\n\n# Each call adds a new independent FM-index entry\nidx.add_sequence(\"contig1\", \"ACGT\" * 100)\nidx.add_sequence(\"contig2\", \"TTTT\" * 100)\nprint(idx.sequence_names())   # ['contig1', 'contig2']\n\n# load_fasta accumulates \u2014 sequences from both files are kept\nidx.load_fasta(\"assembly_a.fasta\")\nidx.load_fasta(\"assembly_b.fasta\")\nprint(len(idx.sequence_names()))  # total from both files plus the two above\n\n# Re-using a name emits a UserWarning then replaces the entry\nwith warnings.catch_warnings(record=True) as w:\n    warnings.simplefilter(\"always\")\n    idx.add_sequence(\"contig1\", \"GGGG\" * 100)   # overwrites old contig1\nassert len(w) == 1                               # exactly one warning emitted\nassert issubclass(w[0].category, UserWarning)    # warned before overwriting\nprint(idx.get_sequence_length(\"contig1\"))        # 400 (the new sequence)\n\n# load_fasta raises ValueError if the FASTA file itself has duplicate names\ntry:\n    idx.load_fasta(\"file_with_dup_names.fasta\")\nexcept ValueError as e:\n    print(e)   # \"duplicate sequence name 'seq1' in FASTA file '...'\"\n</code></pre>"},{"location":"api/sequence_index/#class","title":"Class","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex","title":"<code>SequenceIndex</code>","text":"<p>FM-index backed sequence comparison engine.</p> <p>Each sequence added to the index receives its own independent FM-index built by rust-bio.  The FM-index is constructed once per sequence and cannot be extended after construction, so adding more sequences never modifies an existing FM-index \u2014 it only creates a new one for the newly added sequence.</p> <p>The index behaves as a dictionary of per-sequence FM-indexes:</p> <ul> <li>:meth:<code>add_sequence</code> and :meth:<code>load_fasta</code> add new entries to   the collection; calling either method multiple times accumulates   sequences rather than replacing the collection.</li> <li>If a sequence name already exists in the index, a <code>UserWarning</code> is   emitted and the existing entry is overwritten with a new FM-index   for the new sequence.</li> <li>:meth:<code>load_fasta</code> raises <code>ValueError</code> if the FASTA file itself   contains duplicate sequence names.</li> <li>Pairwise comparisons (:meth:<code>compare_sequences</code>,   :meth:<code>compare_sequences_stranded</code>) always operate on exactly two   independent FM-indexes.</li> </ul> <p>The k-mer length <code>k</code> is fixed at construction time and applies to all sequences held in the index.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The k-mer length to use for indexing and comparison.</p> required <p>Examples:</p> <p>Build an index from individual sequences:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\")\n&gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\")\n&gt;&gt;&gt; idx.sequence_names()\n['seq1', 'seq2']\n</code></pre> <p>Accumulate sequences from multiple FASTA files:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=15)\n&gt;&gt;&gt; idx.load_fasta(\"assembly_a.fasta\")   # adds seqs from file A\n&gt;&gt;&gt; idx.load_fasta(\"assembly_b.fasta\")   # adds seqs from file B, keeps file A seqs\n&gt;&gt;&gt; matches = idx.compare_sequences(\"seq1\", \"seq2\")\n</code></pre> <p>Overwrite a sequence by re-using its name:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGT\")\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"GGGGGGGG\")  # silently replaces the previous seq1\n</code></pre>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex-attributes","title":"Attributes","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.k","title":"<code>k</code>  <code>property</code>","text":"<p>The k-mer length used for this index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The k-mer length supplied at construction time.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex-functions","title":"Functions","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__init__","title":"<code>__init__(k)</code>","text":"<p>Initialise an empty SequenceIndex.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The k-mer length to use for indexing and comparison. Must be greater than zero.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>k</code> is zero.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.add_sequence","title":"<code>add_sequence(name, seq)</code>","text":"<p>Add a single sequence to the index.</p> <p>Builds a new independent FM-index for <code>seq</code> using rust-bio and stores it alongside the k-mer set and raw sequence bytes.  Each call creates a separate FM-index for that sequence only \u2014 the rust-bio FM-index cannot be extended after construction, so adding sequences never modifies existing FM-indexes.</p> <p>Calling <code>add_sequence</code> does not affect any other sequence already in the index.  Sequences accumulate: calling this method N times with N distinct names results in an index holding N independent FM-indexes.</p> <p>If a sequence named <code>name</code> already exists in the index, a <code>UserWarning</code> is emitted and the existing entry is overwritten with a new FM-index for the new <code>seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the sequence.  Re-using an existing name emits a :class:<code>UserWarning</code> and replaces that sequence (and its FM-index).</p> required <code>seq</code> <code>str</code> <p>DNA sequence string. Uppercase is recommended; lowercase input is accepted and treated as uppercase.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the FM-index cannot be built (e.g., invalid characters).</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If <code>name</code> already exists in the index (the existing entry is overwritten).</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.load_fasta","title":"<code>load_fasta(path)</code>","text":"<p>Load all sequences from a FASTA or gzipped FASTA file.</p> <p>Parses the file with needletail (automatic gzip detection) and builds a fresh independent FM-index for each record.</p> <p>Sequences already in the index are preserved \u2014 <code>load_fasta</code> only adds new entries (or overwrites entries whose name already exists in the index).  Calling <code>load_fasta</code> on two separate files accumulates all sequences from both files in the same index.</p> <p>If the FASTA file contains duplicate sequence names (two records with the same identifier), a <code>ValueError</code> is raised before any sequences are added to the index.</p> <p>If a record's name already exists in the index, a <code>UserWarning</code> is emitted and the existing entry is overwritten with the new sequence.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a FASTA (<code>.fa</code>, <code>.fasta</code>) or gzipped FASTA (<code>.fa.gz</code>, <code>.fasta.gz</code>) file.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Sequence names (record identifiers) that were added, in the order they appear in the file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be opened or parsed, or if the file contains duplicate sequence names.</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>For each record whose name already exists in the index (those entries are overwritten).</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.sequence_names","title":"<code>sequence_names()</code>","text":"<p>Return all sequence names currently held in the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unordered list of sequence identifiers.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_kmer_set","title":"<code>get_kmer_set(name)</code>","text":"<p>Return the set of unique k-mers for a named sequence.</p> <p>Only k-mers composed entirely of the characters A, C, G, T are included (k-mers containing N or other IUPAC codes are excluded).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The sequence identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>The set of unique k-mer strings (length <code>k</code>) found in the sequence.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_sequence_length","title":"<code>get_sequence_length(name)</code>","text":"<p>Return the length of a named sequence in base pairs.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The sequence identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sequence length in base pairs (not including any internal sentinel character).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.compare_sequences","title":"<code>compare_sequences(query_name, target_name, merge=True)</code>","text":"<p>Find shared k-mer matches between two sequences.</p> <p>Intersects the k-mer sets of the two sequences and looks up the coordinates of each shared k-mer in both FM-indexes.  Uses the smaller k-mer set as the probe for efficiency.</p> <p>When <code>merge=True</code> (default) consecutive k-mer hits on the same co-linear diagonal are merged into a single coordinate block. Results for each <code>(query_name, target_name, merge)</code> combination are cached; repeated calls with the same arguments are free.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence (defines the y-axis in a dotplot).</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence (defines the x-axis in a dotplot).</p> required <code>merge</code> <code>bool</code> <p>When <code>True</code> (default), merge consecutive co-linear k-mer hits into contiguous coordinate blocks.  When <code>False</code>, every individual k-mer hit is returned as its own block.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> coordinate tuples.  All coordinates are 0-based; end positions are exclusive.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either <code>query_name</code> or <code>target_name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_paf","title":"<code>get_paf(query_name, target_name, merge=True)</code>","text":"<p>Return PAF-formatted alignment strings for a sequence pair.</p> <p>Calls <code>compare_sequences</code> internally (using the cache if available) and formats the result as 12-column PAF lines.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF lines as tab-separated strings.  Each line has 12 fields: query name, query length, query start, query end, strand, target name, target length, target start, target end, residue matches, alignment block length, mapping quality.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_paf_all","title":"<code>get_paf_all(merge=True)</code>","text":"<p>Return PAF-formatted strings for every ordered sequence pair.</p> <p>Calls :meth:<code>get_paf</code> for every <code>(i, j)</code> pair where <code>i != j</code>, populating the comparison cache as a side-effect.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>All PAF lines for every pairwise comparison, one line per match.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.precompute_all_pairs","title":"<code>precompute_all_pairs(merge=True)</code>","text":"<p>Pre-calculate comparisons for every ordered sequence pair.</p> <p>Iterates over all <code>(i, j)</code> pairs where <code>i != j</code> and calls <code>compare_sequences</code> for each, populating the cache.  Subsequent individual calls to <code>compare_sequences</code> for any pair will then be served from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>Ordered list of <code>(query_name, target_name)</code> pairs that were computed.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.compare_sequences_stranded","title":"<code>compare_sequences_stranded(query_name, target_name, merge=True)</code>","text":"<p>Find shared k-mer matches between two sequences on both strands.</p> <p>In addition to the forward (<code>+</code>) strand matches returned by :meth:<code>compare_sequences</code>, this method also searches for k-mers in the query whose reverse complement appears in the target, reporting those as <code>\"-\"</code> strand matches.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge co-linear k-mer runs.  Forward runs are merged by diagonal; reverse runs are merged by anti-diagonal. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int, str]]</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> tuples.  Coordinates are 0-based; end positions are exclusive. <code>strand</code> is <code>\"+\"</code> for forward matches and <code>\"-\"</code> for reverse-complement matches.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.optimal_contig_order","title":"<code>optimal_contig_order(query_names, target_names)</code>","text":"<p>Return query and target contig names sorted for maximum collinearity.</p> <p>Uses the gravity-centre algorithm: for each query contig the gravity is the weighted mean of target mid-point positions (normalised by total target span) across all matches.  Query contigs with no matches are placed at the end.  The same algorithm is applied symmetrically to reorder the target contigs.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str]</code> <p>Names of the query sequences to reorder.</p> required <code>target_names</code> <code>list[str]</code> <p>Names of the target sequences to use as the reference axis.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> ordered by ascending gravity centre.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If any sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.save","title":"<code>save(path)</code>","text":"<p>Serialise the index to a binary file.</p> <p>Stores the original sequence bytes and k-mer sets using postcard. The FM-index is rebuilt from the sequence bytes when the file is loaded, so the on-disk format is compact and version-independent.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Destination file path.  The file is created or overwritten.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be created or serialisation fails.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.load","title":"<code>load(path)</code>","text":"<p>Load sequences from a previously serialised index file.</p> <p>Deserialises sequence bytes and k-mer sets from a file written by <code>save</code>, then rebuilds the FM-index for each sequence in memory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a binary index file produced by <code>save</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be read, deserialisation fails, or the k-mer length stored in the file does not match <code>self.k</code>.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of sequences currently held in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>Count of indexed sequences.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation of the index.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string of the form <code>SequenceIndex(k=&lt;k&gt;, sequences=&lt;n&gt;)</code>.</p>"},{"location":"tutorials/all_vs_all_two_indices/","title":"All-vs-All Dotplot Between Two Sequence Indices","text":"In\u00a0[\u00a0]: Copied! <pre>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\nfrom rusty_dot.paf_io import CrossIndex, PafAlignment, PafRecord\n</pre> from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter from rusty_dot.paf_io import CrossIndex, PafAlignment, PafRecord In\u00a0[\u00a0]: Copied! <pre># Sequences for \"genome A\" \u2014 three contigs of different lengths\ngenome_a = {\n    'contigA1': 'ACGTACGTACGTACGTACGT' * 10,  # 200 bp\n    'contigA2': 'TACGTACGTACGTACGTACG' * 5,  # 100 bp\n    'contigA3': 'GCGCGCGCGCGCGCGCGCGC' * 3,  # 60 bp\n}\n\n# Sequences for \"genome B\" \u2014 three contigs\ngenome_b = {\n    'contigB1': 'ACGTACGTACGTACGTACGT' * 8,  # 160 bp  (similar to contigA1)\n    'contigB2': 'GCGCGCGCGCGCGCGCGCGC' * 4,  # 80 bp   (similar to contigA3)\n    'contigB3': 'TTTTAAAAAGGGGCCCCTTTT' * 2,  # 42 bp   (no matches)\n}\n</pre> # Sequences for \"genome A\" \u2014 three contigs of different lengths genome_a = {     'contigA1': 'ACGTACGTACGTACGTACGT' * 10,  # 200 bp     'contigA2': 'TACGTACGTACGTACGTACG' * 5,  # 100 bp     'contigA3': 'GCGCGCGCGCGCGCGCGCGC' * 3,  # 60 bp }  # Sequences for \"genome B\" \u2014 three contigs genome_b = {     'contigB1': 'ACGTACGTACGTACGTACGT' * 8,  # 160 bp  (similar to contigA1)     'contigB2': 'GCGCGCGCGCGCGCGCGCGC' * 4,  # 80 bp   (similar to contigA3)     'contigB3': 'TTTTAAAAAGGGGCCCCTTTT' * 2,  # 42 bp   (no matches) } In\u00a0[\u00a0]: Copied! <pre>cross = CrossIndex(k=10)\n\nfor name, seq in genome_a.items():\n    cross.add_sequence(name, seq, group='a')\n\nfor name, seq in genome_b.items():\n    cross.add_sequence(name, seq, group='b')\n\nprint(cross)\n</pre> cross = CrossIndex(k=10)  for name, seq in genome_a.items():     cross.add_sequence(name, seq, group='a')  for name, seq in genome_b.items():     cross.add_sequence(name, seq, group='b')  print(cross) In\u00a0[\u00a0]: Copied! <pre>paf_lines = cross.get_paf_all(merge=True)\n\nprint(f'Total PAF lines: {len(paf_lines)}')\nfor line in paf_lines[:5]:\n    print(line)\n</pre> paf_lines = cross.get_paf_all(merge=True)  print(f'Total PAF lines: {len(paf_lines)}') for line in paf_lines[:5]:     print(line) In\u00a0[\u00a0]: Copied! <pre>records = [PafRecord.from_line(line) for line in paf_lines]\naln = PafAlignment.from_records(records)\n\nq_sorted, t_sorted = aln.reorder_contigs(\n    query_names=cross.query_names,\n    target_names=cross.target_names,\n)\n\nprint('Sorted query (genome A) contigs:', q_sorted)\nprint('Sorted target (genome B) contigs:', t_sorted)\n</pre> records = [PafRecord.from_line(line) for line in paf_lines] aln = PafAlignment.from_records(records)  q_sorted, t_sorted = aln.reorder_contigs(     query_names=cross.query_names,     target_names=cross.target_names, )  print('Sorted query (genome A) contigs:', q_sorted) print('Sorted target (genome B) contigs:', t_sorted) <p>Note: Contigs with no cross-group matches (e.g. <code>contigB3</code>) are placed at the end, sorted by descending length.</p> In\u00a0[\u00a0]: Copied! <pre>combined_idx = SequenceIndex(k=10)\n\nfor name, seq in genome_a.items():\n    combined_idx.add_sequence(name, seq)\n\nfor name, seq in genome_b.items():\n    combined_idx.add_sequence(name, seq)\n\nprint(combined_idx)\n</pre> combined_idx = SequenceIndex(k=10)  for name, seq in genome_a.items():     combined_idx.add_sequence(name, seq)  for name, seq in genome_b.items():     combined_idx.add_sequence(name, seq)  print(combined_idx) In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nplotter = DotPlotter(combined_idx)\n\nfig = plotter.plot(\n    query_names=q_sorted,\n    target_names=t_sorted,\n    figsize_per_panel=4.0,\n    scale_sequences=True,\n    title='Genome A vs Genome B \u2014 collinearity-sorted contigs',\n    dpi=100,\n)\nplt.close(fig)  # free memory when no longer needed\n</pre> import matplotlib.pyplot as plt  plotter = DotPlotter(combined_idx)  fig = plotter.plot(     query_names=q_sorted,     target_names=t_sorted,     figsize_per_panel=4.0,     scale_sequences=True,     title='Genome A vs Genome B \u2014 collinearity-sorted contigs',     dpi=100, ) plt.close(fig)  # free memory when no longer needed In\u00a0[\u00a0]: Copied! <pre>q_opt, t_opt = cross.reorder_contigs()\nprint('Optimal query order:', q_opt)\nprint('Optimal target order:', t_opt)\n</pre> q_opt, t_opt = cross.reorder_contigs() print('Optimal query order:', q_opt) print('Optimal target order:', t_opt)"},{"location":"tutorials/all_vs_all_two_indices/#all-vs-all-dotplot-between-two-sequence-indices","title":"All-vs-All Dotplot Between Two Sequence Indices\u00b6","text":"<p>This tutorial demonstrates how to compare sequences from two separate FASTA files (e.g. two genome assemblies) using <code>CrossIndex</code>.  Each FASTA file is assigned to its own group, and pairwise alignments are computed between all sequences in group A and all sequences in group B.</p>"},{"location":"tutorials/all_vs_all_two_indices/#overview","title":"Overview\u00b6","text":"<ol> <li>Create a <code>CrossIndex</code> and load two FASTA files into groups A and B.</li> <li>Retrieve all cross-group PAF alignments with <code>get_paf_all()</code>.</li> <li>Build a <code>PafAlignment</code> from those records for contig reordering.</li> <li>Plot the sorted all-vs-all dotplot with <code>DotPlotter</code>.</li> </ol>"},{"location":"tutorials/all_vs_all_two_indices/#1-create-example-sequences","title":"1. Create example sequences\u00b6","text":"<p>For demonstration we build two small sets of sequences in memory.  In real usage you would call <code>cross.load_fasta('genome_a.fasta', group='a')</code> and <code>cross.load_fasta('genome_b.fasta', group='b')</code>.</p>"},{"location":"tutorials/all_vs_all_two_indices/#2-build-a-crossindex","title":"2. Build a CrossIndex\u00b6","text":"<p><code>CrossIndex</code> holds one internal <code>SequenceIndex</code> that contains sequences from both groups, using internal prefixes (<code>a:</code> / <code>b:</code>) to prevent name collisions.</p>"},{"location":"tutorials/all_vs_all_two_indices/#3-retrieve-all-cross-group-paf-alignments","title":"3. Retrieve all cross-group PAF alignments\u00b6","text":""},{"location":"tutorials/all_vs_all_two_indices/#4-build-a-pafalignment-for-contig-reordering","title":"4. Build a PafAlignment for contig reordering\u00b6","text":"<p>Parse the raw PAF strings into <code>PafRecord</code> objects so we can use the <code>reorder_contigs</code> method to maximise collinearity.</p>"},{"location":"tutorials/all_vs_all_two_indices/#5-build-a-combined-index-for-plotting","title":"5. Build a combined index for plotting\u00b6","text":"<p><code>DotPlotter</code> requires a single <code>SequenceIndex</code> containing all sequences to be plotted.  We create one by adding sequences from both genomes.</p>"},{"location":"tutorials/all_vs_all_two_indices/#6-plot-the-all-vs-all-dotplot-with-relative-scaling","title":"6. Plot the all-vs-all dotplot with relative scaling\u00b6","text":"<p>Pass <code>scale_sequences=True</code> so that each subplot's width and height are proportional to the lengths of the compared sequences.</p> <p><code>plot()</code> returns a <code>matplotlib.figure.Figure</code>, so the plot is displayed inline in Jupyter automatically.  Pass <code>output_path</code> to also save it to disk.</p>"},{"location":"tutorials/all_vs_all_two_indices/#using-crossindexreorder_contigs-directly","title":"Using <code>CrossIndex.reorder_contigs</code> directly\u00b6","text":"<p>A convenience wrapper is also available on the <code>CrossIndex</code> object itself, which internally calls <code>SequenceIndex.optimal_contig_order</code>.</p>"},{"location":"tutorials/dotplot_tutorial/","title":"Dotplot Visualization Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport tempfile\n\nimport matplotlib.pyplot as plt\n\nfrom rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n</pre> import os import tempfile  import matplotlib.pyplot as plt  from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter In\u00a0[\u00a0]: Copied! <pre># Helper to create a reverse complement\ndef revcomp(seq):\n    table = str.maketrans('ACGTacgt', 'TGCAtgca')\n    return seq.translate(table)[::-1]\n\n\nunit = 'ACGTACGTACGT'  # 12 bp repeat unit\nseq_a = unit * 10  # 120 bp  \u2014 the reference\nseq_b = 'T' + unit * 9 + 'T'  # 120 bp  \u2014 shifted by 1\nseq_c = revcomp(unit * 5) + unit * 5  # 120 bp  \u2014 half inverted\n\nidx = SequenceIndex(k=8)\nidx.add_sequence('reference', seq_a)\nidx.add_sequence('shifted', seq_b)\nidx.add_sequence('partial_inv', seq_c)\n\nprint(f'Index: {idx}')\n</pre> # Helper to create a reverse complement def revcomp(seq):     table = str.maketrans('ACGTacgt', 'TGCAtgca')     return seq.translate(table)[::-1]   unit = 'ACGTACGTACGT'  # 12 bp repeat unit seq_a = unit * 10  # 120 bp  \u2014 the reference seq_b = 'T' + unit * 9 + 'T'  # 120 bp  \u2014 shifted by 1 seq_c = revcomp(unit * 5) + unit * 5  # 120 bp  \u2014 half inverted  idx = SequenceIndex(k=8) idx.add_sequence('reference', seq_a) idx.add_sequence('shifted', seq_b) idx.add_sequence('partial_inv', seq_c)  print(f'Index: {idx}') In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(idx)\n\n# No output_path: the figure is returned and displayed inline in Jupyter\nfig = plotter.plot(title='All vs All \u2014 inline display')\nplt.close(fig)  # free memory when no longer needed\n</pre> plotter = DotPlotter(idx)  # No output_path: the figure is returned and displayed inline in Jupyter fig = plotter.plot(title='All vs All \u2014 inline display') plt.close(fig)  # free memory when no longer needed In\u00a0[\u00a0]: Copied! <pre># Inline display for a single pair\nfig = plotter.plot_single(\n    query_name='reference',\n    target_name='partial_inv',\n    title='reference vs partial_inv \u2014 inline',\n)\nplt.close(fig)\n</pre> # Inline display for a single pair fig = plotter.plot_single(     query_name='reference',     target_name='partial_inv',     title='reference vs partial_inv \u2014 inline', ) plt.close(fig) In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    all_vs_all_path = fh.name\n\nfig = plotter.plot(\n    output_path=all_vs_all_path,\n    title='All vs All',\n)\nplt.close(fig)\nprint(f'Saved: {all_vs_all_path}  ({os.path.getsize(all_vs_all_path)} bytes)')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     all_vs_all_path = fh.name  fig = plotter.plot(     output_path=all_vs_all_path,     title='All vs All', ) plt.close(fig) print(f'Saved: {all_vs_all_path}  ({os.path.getsize(all_vs_all_path)} bytes)') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    subset_path = fh.name\n\nplotter.plot(\n    query_names=['reference', 'shifted'],\n    target_names=['partial_inv'],\n    output_path=subset_path,\n    title='Reference &amp; Shifted vs Partial Inversion',\n)\nprint(f'Subset plot saved: {subset_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     subset_path = fh.name  plotter.plot(     query_names=['reference', 'shifted'],     target_names=['partial_inv'],     output_path=subset_path,     title='Reference &amp; Shifted vs Partial Inversion', ) print(f'Subset plot saved: {subset_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    single_path = fh.name\n\nplotter.plot_single(\n    query_name='reference',\n    target_name='shifted',\n    output_path=single_path,\n    figsize=(5, 5),\n    title='reference vs shifted',\n)\nprint(f'Single-pair plot saved: {single_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     single_path = fh.name  plotter.plot_single(     query_name='reference',     target_name='shifted',     output_path=single_path,     figsize=(5, 5),     title='reference vs shifted', ) print(f'Single-pair plot saved: {single_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    styled_path = fh.name\n\nplotter.plot(\n    output_path=styled_path,\n    dot_size=1.5,\n    dot_color='crimson',\n    dpi=200,\n    title='Custom style: crimson, dpi=200',\n)\nprint(f'Styled plot saved: {styled_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     styled_path = fh.name  plotter.plot(     output_path=styled_path,     dot_size=1.5,     dot_color='crimson',     dpi=200,     title='Custom style: crimson, dpi=200', ) print(f'Styled plot saved: {styled_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    unmerged_path = fh.name\n\nplotter.plot_single(\n    query_name='reference',\n    target_name='shifted',\n    output_path=unmerged_path,\n    merge=False,\n    title='reference vs shifted (unmerged k-mer hits)',\n)\nprint(f'Unmerged plot saved: {unmerged_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     unmerged_path = fh.name  plotter.plot_single(     query_name='reference',     target_name='shifted',     output_path=unmerged_path,     merge=False,     title='reference vs shifted (unmerged k-mer hits)', ) print(f'Unmerged plot saved: {unmerged_path}') In\u00a0[\u00a0]: Copied! <pre>for dpi in [72, 150, 300]:\n    with tempfile.NamedTemporaryFile(suffix=f'_dpi{dpi}.png', delete=False) as fh:\n        path = fh.name\n    plotter.plot_single(\n        'reference',\n        'shifted',\n        output_path=path,\n        dpi=dpi,\n        title=f'DPI = {dpi}',\n    )\n    size_kb = os.path.getsize(path) / 1024\n    print(f'DPI={dpi:4d}  file size={size_kb:.1f} kB  path={path}')\n</pre> for dpi in [72, 150, 300]:     with tempfile.NamedTemporaryFile(suffix=f'_dpi{dpi}.png', delete=False) as fh:         path = fh.name     plotter.plot_single(         'reference',         'shifted',         output_path=path,         dpi=dpi,         title=f'DPI = {dpi}',     )     size_kb = os.path.getsize(path) / 1024     print(f'DPI={dpi:4d}  file size={size_kb:.1f} kB  path={path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    large_path = fh.name\n\nplotter.plot(\n    output_path=large_path,\n    figsize_per_panel=6.0,  # each panel is 6\u00d76 inches\n    title='Large panels (6 inches each)',\n)\nprint(f'Large-panel plot saved: {large_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     large_path = fh.name  plotter.plot(     output_path=large_path,     figsize_per_panel=6.0,  # each panel is 6\u00d76 inches     title='Large panels (6 inches each)', ) print(f'Large-panel plot saved: {large_path}') In\u00a0[\u00a0]: Copied! <pre># PNG (default raster format)\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    png_path = fh.name\n\nfig = plotter.plot(output_path=png_path, title='PNG output')\nplt.close(fig)\nprint(f'PNG:  {png_path}  ({os.path.getsize(png_path)} bytes)')\n\n# SVG via file extension\nwith tempfile.NamedTemporaryFile(suffix='.svg', delete=False) as fh:\n    svg_ext_path = fh.name\n\nfig = plotter.plot(output_path=svg_ext_path, title='SVG via extension')\nplt.close(fig)\nprint(f'SVG (ext):     {svg_ext_path}  ({os.path.getsize(svg_ext_path)} bytes)')\n\n# SVG via explicit format parameter (output path need not end in .svg)\nwith tempfile.NamedTemporaryFile(suffix='.out', delete=False) as fh:\n    svg_fmt_path = fh.name\n\nfig = plotter.plot(output_path=svg_fmt_path, format='svg', title='SVG via format param')\nplt.close(fig)\nprint(f'SVG (fmt):     {svg_fmt_path}  ({os.path.getsize(svg_fmt_path)} bytes)')\n\n# PDF \u2014 vector format suitable for LaTeX / Word\nwith tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as fh:\n    pdf_path = fh.name\n\nfig = plotter.plot(output_path=pdf_path, title='PDF output')\nplt.close(fig)\nprint(f'PDF:  {pdf_path}  ({os.path.getsize(pdf_path)} bytes)')\n\n# Verify SVG header\nwith open(svg_ext_path) as f:\n    snippet = f.read(80)\nprint(f'\\nSVG file header: {snippet!r}')\n</pre> # PNG (default raster format) with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     png_path = fh.name  fig = plotter.plot(output_path=png_path, title='PNG output') plt.close(fig) print(f'PNG:  {png_path}  ({os.path.getsize(png_path)} bytes)')  # SVG via file extension with tempfile.NamedTemporaryFile(suffix='.svg', delete=False) as fh:     svg_ext_path = fh.name  fig = plotter.plot(output_path=svg_ext_path, title='SVG via extension') plt.close(fig) print(f'SVG (ext):     {svg_ext_path}  ({os.path.getsize(svg_ext_path)} bytes)')  # SVG via explicit format parameter (output path need not end in .svg) with tempfile.NamedTemporaryFile(suffix='.out', delete=False) as fh:     svg_fmt_path = fh.name  fig = plotter.plot(output_path=svg_fmt_path, format='svg', title='SVG via format param') plt.close(fig) print(f'SVG (fmt):     {svg_fmt_path}  ({os.path.getsize(svg_fmt_path)} bytes)')  # PDF \u2014 vector format suitable for LaTeX / Word with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as fh:     pdf_path = fh.name  fig = plotter.plot(output_path=pdf_path, title='PDF output') plt.close(fig) print(f'PDF:  {pdf_path}  ({os.path.getsize(pdf_path)} bytes)')  # Verify SVG header with open(svg_ext_path) as f:     snippet = f.read(80) print(f'\\nSVG file header: {snippet!r}') In\u00a0[\u00a0]: Copied! <pre># Without filtering: all merged hits are drawn\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    unfiltered_path = fh.name\nplotter.plot_single(\n    'reference', 'shifted', output_path=unfiltered_path, title='No min_length filter'\n)\n\n# With filtering: only hits of at least 24 bp are drawn\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    filtered_path = fh.name\nplotter.plot_single(\n    'reference',\n    'shifted',\n    output_path=filtered_path,\n    min_length=24,\n    title='min_length=24',\n)\n\nprint(f'Unfiltered: {unfiltered_path}  ({os.path.getsize(unfiltered_path)} bytes)')\nprint(f'Filtered:   {filtered_path}  ({os.path.getsize(filtered_path)} bytes)')\n</pre> # Without filtering: all merged hits are drawn with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     unfiltered_path = fh.name plotter.plot_single(     'reference', 'shifted', output_path=unfiltered_path, title='No min_length filter' )  # With filtering: only hits of at least 24 bp are drawn with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     filtered_path = fh.name plotter.plot_single(     'reference',     'shifted',     output_path=filtered_path,     min_length=24,     title='min_length=24', )  print(f'Unfiltered: {unfiltered_path}  ({os.path.getsize(unfiltered_path)} bytes)') print(f'Filtered:   {filtered_path}  ({os.path.getsize(filtered_path)} bytes)') In\u00a0[\u00a0]: Copied! <pre>import random\n\nfrom rusty_dot.paf_io import PafAlignment, PafRecord\n\n# Build synthetic PAF records with varying identity values to illustrate\n# the colour-by-identity feature without needing a real aligner.\nrandom.seed(0)\npaf_records = []\nfor i in range(8):\n    block_len = random.randint(10, 30)\n    identity = 0.6 + 0.04 * i  # 60 % \u2026 88 %\n    residue_matches = round(block_len * identity)\n    q_start = i * 12\n    paf_records.append(\n        PafRecord(\n            query_name='reference',\n            query_len=144,\n            query_start=q_start,\n            query_end=q_start + block_len,\n            strand='+',\n            target_name='shifted',\n            target_len=144,\n            target_start=q_start,\n            target_end=q_start + block_len,\n            residue_matches=residue_matches,\n            alignment_block_len=block_len,\n            mapping_quality=255,\n        )\n    )\n\npaf_aln = PafAlignment(paf_records)\nprint(f'{len(paf_aln)} records loaded')\n\n# Create a DotPlotter with the PAF alignment attached\nidentity_plotter = DotPlotter(idx, paf_alignment=paf_aln)\n\n# \u2500\u2500 Plot coloured by identity \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    identity_path = fh.name\n\nfig = identity_plotter.plot_single(\n    'reference',\n    'shifted',\n    output_path=identity_path,\n    color_by_identity=True,\n    identity_palette='viridis',\n    title='Coloured by identity (viridis)',\n)\nplt.close(fig)\nprint(f'Identity plot: {identity_path}  ({os.path.getsize(identity_path)} bytes)')\n\n# \u2500\u2500 Colorbar (standalone scale figure) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    colorbar_path = fh.name\n\nfig_cb = identity_plotter.plot_identity_colorbar(\n    palette='viridis',\n    output_path=colorbar_path,\n)\nplt.close(fig_cb)\nprint(f'Colorbar:      {colorbar_path}  ({os.path.getsize(colorbar_path)} bytes)')\n\n# \u2500\u2500 Try a different palette \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    plasma_path = fh.name\n\nfig_p = identity_plotter.plot_single(\n    'reference',\n    'shifted',\n    output_path=plasma_path,\n    color_by_identity=True,\n    identity_palette='plasma',\n    title='Coloured by identity (plasma)',\n)\nplt.close(fig_p)\nprint(f'Plasma plot:   {plasma_path}  ({os.path.getsize(plasma_path)} bytes)')\n</pre> import random  from rusty_dot.paf_io import PafAlignment, PafRecord  # Build synthetic PAF records with varying identity values to illustrate # the colour-by-identity feature without needing a real aligner. random.seed(0) paf_records = [] for i in range(8):     block_len = random.randint(10, 30)     identity = 0.6 + 0.04 * i  # 60 % \u2026 88 %     residue_matches = round(block_len * identity)     q_start = i * 12     paf_records.append(         PafRecord(             query_name='reference',             query_len=144,             query_start=q_start,             query_end=q_start + block_len,             strand='+',             target_name='shifted',             target_len=144,             target_start=q_start,             target_end=q_start + block_len,             residue_matches=residue_matches,             alignment_block_len=block_len,             mapping_quality=255,         )     )  paf_aln = PafAlignment(paf_records) print(f'{len(paf_aln)} records loaded')  # Create a DotPlotter with the PAF alignment attached identity_plotter = DotPlotter(idx, paf_alignment=paf_aln)  # \u2500\u2500 Plot coloured by identity \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     identity_path = fh.name  fig = identity_plotter.plot_single(     'reference',     'shifted',     output_path=identity_path,     color_by_identity=True,     identity_palette='viridis',     title='Coloured by identity (viridis)', ) plt.close(fig) print(f'Identity plot: {identity_path}  ({os.path.getsize(identity_path)} bytes)')  # \u2500\u2500 Colorbar (standalone scale figure) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     colorbar_path = fh.name  fig_cb = identity_plotter.plot_identity_colorbar(     palette='viridis',     output_path=colorbar_path, ) plt.close(fig_cb) print(f'Colorbar:      {colorbar_path}  ({os.path.getsize(colorbar_path)} bytes)')  # \u2500\u2500 Try a different palette \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     plasma_path = fh.name  fig_p = identity_plotter.plot_single(     'reference',     'shifted',     output_path=plasma_path,     color_by_identity=True,     identity_palette='plasma',     title='Coloured by identity (plasma)', ) plt.close(fig_p) print(f'Plasma plot:   {plasma_path}  ({os.path.getsize(plasma_path)} bytes)')"},{"location":"tutorials/dotplot_tutorial/#dotplot-visualization-tutorial","title":"Dotplot Visualization Tutorial\u00b6","text":"<p>This notebook explores all visualisation options provided by the <code>DotPlotter</code> class.</p> <p>A dot plot (or dotplot) is a classic bioinformatics visualisation that displays all shared subsequences between two sequences.  Each dot represents a shared k-mer; diagonal runs of dots indicate conserved regions.  Inversions appear as anti-diagonal lines.</p>"},{"location":"tutorials/dotplot_tutorial/#1-build-a-test-index","title":"1. Build a test index\u00b6","text":"<p>We create three artificial sequences with different overlap patterns:</p>"},{"location":"tutorials/dotplot_tutorial/#2-inline-rendering-in-jupyter-notebooks","title":"2. Inline rendering in Jupyter notebooks\u00b6","text":"<p>Both <code>plot()</code> and <code>plot_single()</code> return a <code>matplotlib.figure.Figure</code>.  In a Jupyter notebook the returned figure is automatically displayed inline \u2014 no file path is required.</p> <p>Call <code>matplotlib.pyplot.close(fig)</code> when you are done with the figure to free memory.</p>"},{"location":"tutorials/dotplot_tutorial/#3-all-vs-all-dotplot-default-settings","title":"3. All-vs-all dotplot (default settings)\u00b6","text":"<p><code>DotPlotter.plot()</code> without arguments produces an all-vs-all grid using all sequences in the index.  Passing <code>output_path</code> saves the figure to disk in addition to returning it.</p>"},{"location":"tutorials/dotplot_tutorial/#4-subset-specific-query-and-target-sets","title":"4. Subset: specific query and target sets\u00b6","text":"<p>Pass <code>query_names</code> and <code>target_names</code> to restrict the grid to a subset of sequences.</p>"},{"location":"tutorials/dotplot_tutorial/#5-single-pair-dotplot","title":"5. Single-pair dotplot\u00b6","text":"<p><code>plot_single</code> renders one comparison panel with its own figure size and title.</p>"},{"location":"tutorials/dotplot_tutorial/#6-customising-dot-appearance","title":"6. Customising dot appearance\u00b6","text":"<p>All plotting methods accept <code>dot_size</code> and <code>dot_color</code> to control the appearance of match lines.</p>"},{"location":"tutorials/dotplot_tutorial/#7-controlling-merge-behaviour","title":"7. Controlling merge behaviour\u00b6","text":"<p>When <code>merge=True</code> (default), consecutive co-linear k-mer hits are merged into single lines. Set <code>merge=False</code> to display every individual k-mer hit as its own point \u2014 useful for inspecting raw k-mer density.</p>"},{"location":"tutorials/dotplot_tutorial/#8-output-resolution","title":"8. Output resolution\u00b6","text":"<p>Use the <code>dpi</code> parameter to control the resolution of the saved image. Higher DPI is better for print-quality figures.</p>"},{"location":"tutorials/dotplot_tutorial/#9-panel-size-control","title":"9. Panel size control\u00b6","text":"<p>For all-vs-all grids, <code>figsize_per_panel</code> controls the size (in inches) of each subplot panel.</p>"},{"location":"tutorials/dotplot_tutorial/#10-saving-to-different-file-formats","title":"10. Saving to different file formats\u00b6","text":"<p>rusty-dot passes the <code>format</code> argument directly to <code>matplotlib.savefig</code>, so you can produce PNG, SVG, PDF, or any other matplotlib-supported format.</p> <p>The simplest approach is to use the matching file extension \u2014 matplotlib infers the format automatically.  You can also pass <code>format='svg'</code> (or <code>'pdf'</code>, <code>'png'</code>, \u2026) explicitly to override the extension.</p> Extension / <code>format=</code> Notes <code>.png</code> / <code>'png'</code> Raster; good default for screen and web <code>.svg</code> / <code>'svg'</code> Vector; infinitely scalable, ideal for publications <code>.pdf</code> / <code>'pdf'</code> Vector; embeds cleanly into LaTeX and Word documents"},{"location":"tutorials/dotplot_tutorial/#11-minimum-alignment-length-filter","title":"11. Minimum alignment length filter\u00b6","text":"<p>Pass <code>min_length</code> to suppress alignments shorter than a given number of base pairs. This applies to merged k-mer runs (which may be longer than the original k-mer size after merging) and to any pre-computed PAF alignments that are loaded later.</p> <p>The filter is applied per match segment; only the length of the query span is checked: <code>query_end - query_start &gt;= min_length</code>.</p>"},{"location":"tutorials/dotplot_tutorial/#12-colour-alignments-by-identity-paf-alignments","title":"12. Colour alignments by identity (PAF alignments)\u00b6","text":"<p>When alignments are loaded from a PAF file (e.g. produced by minimap2), each record carries a <code>residue_matches</code> count and an <code>alignment_block_len</code> that together define sequence identity.  Pass <code>color_by_identity=True</code> to <code>plot()</code> or <code>plot_single()</code> to render each alignment segment with a colour drawn from the chosen Matplotlib colormap (<code>identity_palette</code>, default <code>'viridis'</code>).</p> <p>Note: Individual k-mer matches are always 100 % identical (exact matches), so <code>color_by_identity</code> only makes sense with PAF-sourced alignments.  If you pass <code>color_by_identity=True</code> without supplying a <code>PafAlignment</code> a warning is logged and the plot falls back to the default strand colours.</p> <p>Use <code>DotPlotter.plot_identity_colorbar()</code> to generate a standalone colorbar figure for the identity scale.</p>"},{"location":"tutorials/dotplot_tutorial/#summary-of-dotplotter-parameters","title":"Summary of DotPlotter parameters\u00b6","text":"Parameter Default Description <code>query_names</code> <code>None</code> List of query sequence names (rows); <code>None</code> = all <code>target_names</code> <code>None</code> List of target sequence names (columns); <code>None</code> = all <code>output_path</code> <code>None</code> Output file path; <code>None</code> = no file written (inline display only) <code>format</code> <code>None</code> Output format (e.g. <code>'svg'</code>, <code>'png'</code>, <code>'pdf'</code>); inferred from extension when <code>None</code> <code>figsize_per_panel</code> <code>4.0</code> Inches per subplot panel (all-vs-all only) <code>figsize</code> <code>(6, 6)</code> Total figure size for <code>plot_single</code> <code>dot_size</code> <code>0.5</code> Line/marker size for each match <code>dot_color</code> <code>\"blue\"</code> Colour of forward-strand match lines <code>rc_color</code> <code>\"red\"</code> Colour of reverse-complement match lines <code>merge</code> <code>True</code> Merge co-linear k-mer runs into blocks <code>min_length</code> <code>0</code> Minimum alignment length to display; <code>0</code> = show all <code>title</code> <code>None</code> Figure title <code>dpi</code> <code>150</code> Output image resolution <code>color_by_identity</code> <code>False</code> Colour alignments by identity fraction when a <code>PafAlignment</code> is loaded <code>identity_palette</code> <code>'viridis'</code> Matplotlib colormap for identity colouring (any valid colormap name) <p>Both <code>plot()</code> and <code>plot_single()</code> return a <code>matplotlib.figure.Figure</code>. In a Jupyter notebook the figure is displayed inline automatically. Call <code>matplotlib.pyplot.close(fig)</code> to release memory when finished.</p>"},{"location":"tutorials/minimap2_paf_tutorial/","title":"Visualising Minimap2 Alignments with rusty-dot","text":"In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\nimport subprocess\n\nimport matplotlib.pyplot as plt\n\nfrom rusty_dot.dotplot import DotPlotter\nfrom rusty_dot.paf_io import PafAlignment, parse_paf_file\n</pre> from pathlib import Path import subprocess  import matplotlib.pyplot as plt  from rusty_dot.dotplot import DotPlotter from rusty_dot.paf_io import PafAlignment, parse_paf_file  In\u00a0[\u00a0]: Copied! <pre># \u2500\u2500 Adjust these paths \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nQUERY_FASTA = 'genome_a.fasta'  # query assembly (rows in the dotplot)\nTARGET_FASTA = 'genome_b.fasta'  # target assembly (columns in the dotplot)\nPAF_OUTPUT = 'alignments.paf'\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ntry:\n    result = subprocess.run(\n        ['minimap2', '-x', 'asm5', '--cs', TARGET_FASTA, QUERY_FASTA],\n        capture_output=True,\n        text=True,\n        check=True,\n    )\n    Path(PAF_OUTPUT).write_text(result.stdout)\n    print(\n        f'Alignment complete.  Wrote {len(result.stdout.splitlines())} records to {PAF_OUTPUT}'\n    )\nexcept (FileNotFoundError, subprocess.CalledProcessError) as exc:\n    print(f'minimap2 not available or alignment failed: {exc}')\n    print('Falling back to synthetic PAF data in Section 3.')\n    PAF_OUTPUT = None\n</pre> # \u2500\u2500 Adjust these paths \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 QUERY_FASTA = 'genome_a.fasta'  # query assembly (rows in the dotplot) TARGET_FASTA = 'genome_b.fasta'  # target assembly (columns in the dotplot) PAF_OUTPUT = 'alignments.paf' # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  try:     result = subprocess.run(         ['minimap2', '-x', 'asm5', '--cs', TARGET_FASTA, QUERY_FASTA],         capture_output=True,         text=True,         check=True,     )     Path(PAF_OUTPUT).write_text(result.stdout)     print(         f'Alignment complete.  Wrote {len(result.stdout.splitlines())} records to {PAF_OUTPUT}'     ) except (FileNotFoundError, subprocess.CalledProcessError) as exc:     print(f'minimap2 not available or alignment failed: {exc}')     print('Falling back to synthetic PAF data in Section 3.')     PAF_OUTPUT = None In\u00a0[\u00a0]: Copied! <pre>if PAF_OUTPUT and Path(PAF_OUTPUT).exists():\n    records = list(parse_paf_file(PAF_OUTPUT))\n    print(f'Loaded {len(records)} alignment records')\n    if records:\n        r = records[0]\n        print(f'  query: {r.query_name} ({r.query_len:,} bp)')\n        print(f'  target: {r.target_name} ({r.target_len:,} bp)')\n        print(f'  strand: {r.strand}')\n        if r.cigar:\n            print(\n                f'  CIGAR-derived identity: {r.n_matches / max(r.alignment_length, 1):.2%}'\n            )\n</pre> if PAF_OUTPUT and Path(PAF_OUTPUT).exists():     records = list(parse_paf_file(PAF_OUTPUT))     print(f'Loaded {len(records)} alignment records')     if records:         r = records[0]         print(f'  query: {r.query_name} ({r.query_len:,} bp)')         print(f'  target: {r.target_name} ({r.target_len:,} bp)')         print(f'  strand: {r.strand}')         if r.cigar:             print(                 f'  CIGAR-derived identity: {r.n_matches / max(r.alignment_length, 1):.2%}'             ) In\u00a0[\u00a0]: Copied! <pre>SYNTHETIC_PAF = \"\"\"\\\ncontigA1\\t200\\t0\\t180\\t+\\tcontigB1\\t160\\t0\\t160\\t155\\t160\\t60\ncontigA2\\t100\\t10\\t90\\t+\\tcontigB2\\t80\\t5\\t75\\t65\\t70\\t60\ncontigA1\\t200\\t50\\t120\\t-\\tcontigB2\\t80\\t0\\t70\\t65\\t70\\t30\n\"\"\"\n\nPAF_FILE = '/tmp/synthetic_alignments.paf'\nwith open(PAF_FILE, 'w') as fh:\n    fh.write(SYNTHETIC_PAF)\n\nif PAF_OUTPUT is None:\n    PAF_OUTPUT = PAF_FILE\n\nprint(f'Using PAF file: {PAF_OUTPUT}')\n</pre> SYNTHETIC_PAF = \"\"\"\\ contigA1\\t200\\t0\\t180\\t+\\tcontigB1\\t160\\t0\\t160\\t155\\t160\\t60 contigA2\\t100\\t10\\t90\\t+\\tcontigB2\\t80\\t5\\t75\\t65\\t70\\t60 contigA1\\t200\\t50\\t120\\t-\\tcontigB2\\t80\\t0\\t70\\t65\\t70\\t30 \"\"\"  PAF_FILE = '/tmp/synthetic_alignments.paf' with open(PAF_FILE, 'w') as fh:     fh.write(SYNTHETIC_PAF)  if PAF_OUTPUT is None:     PAF_OUTPUT = PAF_FILE  print(f'Using PAF file: {PAF_OUTPUT}') In\u00a0[\u00a0]: Copied! <pre>aln = PafAlignment.from_file(PAF_OUTPUT)\nprint(aln)\n\nq_sorted, t_sorted = aln.reorder_contigs()\nprint('Sorted query contigs:', q_sorted)\nprint('Sorted target contigs:', t_sorted)\n</pre> aln = PafAlignment.from_file(PAF_OUTPUT) print(aln)  q_sorted, t_sorted = aln.reorder_contigs() print('Sorted query contigs:', q_sorted) print('Sorted target contigs:', t_sorted) In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(aln)\n\n# Use the sorted contig order; scale panels by sequence length\nplotter.plot(\n    query_names=q_sorted,\n    target_names=t_sorted,\n    output_path='/tmp/minimap2_dotplot.png',\n    figsize_per_panel=4.0,\n    scale_sequences=True,\n    title='Minimap2 alignment \u2014 sorted contigs',\n    dpi=100,\n)\n\nfrom IPython.display import Image\n\nImage('/tmp/minimap2_dotplot.png')\n</pre> plotter = DotPlotter(aln)  # Use the sorted contig order; scale panels by sequence length plotter.plot(     query_names=q_sorted,     target_names=t_sorted,     output_path='/tmp/minimap2_dotplot.png',     figsize_per_panel=4.0,     scale_sequences=True,     title='Minimap2 alignment \u2014 sorted contigs',     dpi=100, )  from IPython.display import Image  Image('/tmp/minimap2_dotplot.png')  In\u00a0[\u00a0]: Copied! <pre># The same PafAlignment is used; enable identity colouring\nplotter_identity = DotPlotter(aln)\n\nplotter_identity.plot(\n    query_names=q_sorted,\n    target_names=t_sorted,\n    output_path='/tmp/minimap2_identity_dotplot.png',\n    figsize_per_panel=4.0,\n    scale_sequences=True,\n    color_by_identity=True,\n    identity_palette='viridis',\n    title='Minimap2 alignment \u2014 coloured by identity',\n    dpi=100,\n)\n\n# Render the identity colour scale as a separate figure\nfig_cb = plotter_identity.plot_identity_colorbar(\n    palette='viridis',\n    output_path='/tmp/minimap2_identity_colorbar.png',\n    dpi=100,\n)\nplt.close(fig_cb)\n\nfrom IPython.display import Image\n\nImage('/tmp/minimap2_identity_dotplot.png')\n</pre> # The same PafAlignment is used; enable identity colouring plotter_identity = DotPlotter(aln)  plotter_identity.plot(     query_names=q_sorted,     target_names=t_sorted,     output_path='/tmp/minimap2_identity_dotplot.png',     figsize_per_panel=4.0,     scale_sequences=True,     color_by_identity=True,     identity_palette='viridis',     title='Minimap2 alignment \u2014 coloured by identity',     dpi=100, )  # Render the identity colour scale as a separate figure fig_cb = plotter_identity.plot_identity_colorbar(     palette='viridis',     output_path='/tmp/minimap2_identity_colorbar.png',     dpi=100, ) plt.close(fig_cb)  from IPython.display import Image  Image('/tmp/minimap2_identity_dotplot.png')"},{"location":"tutorials/minimap2_paf_tutorial/#visualising-minimap2-alignments-with-rusty-dot","title":"Visualising Minimap2 Alignments with rusty-dot\u00b6","text":"<p>This tutorial shows how to align two genome assemblies with minimap2 and visualise the output PAF file as an all-vs-all dotplot using rusty-dot.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#prerequisites","title":"Prerequisites\u00b6","text":"<ul> <li>minimap2 installed and available on <code>PATH</code></li> <li>Two FASTA files to compare (e.g. two assemblies, or one assembly aligned to a reference)</li> </ul>"},{"location":"tutorials/minimap2_paf_tutorial/#workflow","title":"Workflow\u00b6","text":"<ol> <li>Align assemblies with minimap2 to produce a PAF file.</li> <li>Load the PAF file with <code>PafAlignment.from_file()</code>.</li> <li>Optionally reorder contigs for maximum collinearity.</li> <li>Pass the <code>PafAlignment</code> object directly to <code>DotPlotter</code> and plot.</li> </ol>"},{"location":"tutorials/minimap2_paf_tutorial/#1-align-two-assemblies-with-minimap2","title":"1. Align two assemblies with minimap2\u00b6","text":"<p>Replace the paths below with your own FASTA files.  The <code>asm5</code> preset is suitable for comparing assemblies with &lt; 5% divergence.</p> <pre>minimap2 -x asm5 --cs genome_b.fasta genome_a.fasta &gt; alignments.paf\n</pre> <p>The cell below runs minimap2 programmatically.  If minimap2 is not available, skip to Section 3 where we create synthetic PAF data.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#2-inspect-cigar-statistics-optional","title":"2. Inspect CIGAR statistics (optional)\u00b6","text":"<p>When minimap2 is run with <code>--cs</code> the PAF file contains <code>cg:Z:</code> CIGAR tags.  <code>PafRecord</code> parses these automatically.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#3-synthetic-example-minimap2-not-available","title":"3. Synthetic example (minimap2 not available)\u00b6","text":"<p>If minimap2 is not installed we create a small synthetic PAF file that mirrors what minimap2 would produce.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#4-load-paf-and-reorder-contigs-for-maximum-collinearity","title":"4. Load PAF and reorder contigs for maximum collinearity\u00b6","text":"<p><code>PafAlignment.reorder_contigs()</code> uses a gravity-centre algorithm to sort contigs so the dotplot shows maximum collinearity along the diagonal.  Unmatched contigs are placed at the end, sorted by descending length.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#5-plot-alignments","title":"5. Plot alignments\u00b6","text":"<p><code>DotPlotter</code> accepts a <code>PafAlignment</code> directly \u2014 no <code>SequenceIndex</code> is required.  Sequence lengths are read from the PAF records, and alignment segments are drawn using the strand colour convention: forward (<code>+</code>) matches are blue and reverse-complement (<code>-</code>) matches are red.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#6-colour-alignments-by-identity","title":"6. Colour alignments by identity\u00b6","text":"<p>PAF records include a <code>residue_matches</code> column and an <code>alignment_block_len</code> column that together define sequence identity:</p> <p>$$\\text{identity} = \\frac{\\text{residue\\_matches}}{\\text{alignment\\_block\\_len}}$$</p> <p>Pass <code>color_by_identity=True</code> to <code>DotPlotter.plot()</code> to colour each alignment segment by identity instead of using flat strand colours.  Any Matplotlib colormap is accepted via <code>identity_palette</code> (default <code>'viridis'</code>).</p> <p><code>DotPlotter.plot_identity_colorbar()</code> generates a standalone colorbar figure that you can display alongside the dotplot.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#summary","title":"Summary\u00b6","text":"Step Tool Purpose Align <code>minimap2 -x asm5</code> Generate PAF alignments Load <code>PafAlignment.from_file()</code> Parse PAF records Sort <code>aln.reorder_contigs()</code> Maximise collinearity Plot <code>DotPlotter(aln).plot(scale_sequences=True)</code> Visualise with relative scaling Colour by identity <code>DotPlotter(aln).plot(color_by_identity=True)</code> Colour each segment by identity <p>The <code>scale_sequences=True</code> option ensures each subplot's dimensions are proportional to the actual lengths of the compared sequences, so short and long contigs are not artificially stretched to the same size.</p>"},{"location":"tutorials/paf_workflow/","title":"PAF Workflow Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nimport tempfile\n\nfrom rusty_dot import SequenceIndex, py_coords_to_paf\nfrom rusty_dot.paf_io import (\n    PafAlignment,\n    PafRecord,\n    parse_paf_file,\n)\n</pre> import os import tempfile  from rusty_dot import SequenceIndex, py_coords_to_paf from rusty_dot.paf_io import (     PafAlignment,     PafRecord,     parse_paf_file, ) In\u00a0[\u00a0]: Copied! <pre># Build a small index\nidx = SequenceIndex(k=10)\nunit = 'ACGTACGTACGT'\nidx.add_sequence('query', unit * 8)  # 96 bp\nidx.add_sequence('target', ('T' + unit * 7 + 'T'))  # 98 bp\n\n# Get PAF lines\npaf_lines = idx.get_paf('query', 'target', merge=True)\nprint(f'Generated {len(paf_lines)} PAF lines')\nprint('\\nPAF columns (first record):')\ncol_names = [\n    'query_name',\n    'query_len',\n    'query_start',\n    'query_end',\n    'strand',\n    'target_name',\n    'target_len',\n    'target_start',\n    'target_end',\n    'residue_matches',\n    'block_len',\n    'mapq',\n]\nif paf_lines:\n    for col, val in zip(col_names, paf_lines[0].split('\\t')):\n        print(f'  {col:20s}: {val}')\n</pre> # Build a small index idx = SequenceIndex(k=10) unit = 'ACGTACGTACGT' idx.add_sequence('query', unit * 8)  # 96 bp idx.add_sequence('target', ('T' + unit * 7 + 'T'))  # 98 bp  # Get PAF lines paf_lines = idx.get_paf('query', 'target', merge=True) print(f'Generated {len(paf_lines)} PAF lines') print('\\nPAF columns (first record):') col_names = [     'query_name',     'query_len',     'query_start',     'query_end',     'strand',     'target_name',     'target_len',     'target_start',     'target_end',     'residue_matches',     'block_len',     'mapq', ] if paf_lines:     for col, val in zip(col_names, paf_lines[0].split('\\t')):         print(f'  {col:20s}: {val}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    paf_path = fh.name\n    for line in paf_lines:\n        fh.write(line + '\\n')\n\nprint(f'PAF file written: {paf_path}')\nprint(f'File size: {os.path.getsize(paf_path)} bytes')\n</pre> with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     paf_path = fh.name     for line in paf_lines:         fh.write(line + '\\n')  print(f'PAF file written: {paf_path}') print(f'File size: {os.path.getsize(paf_path)} bytes') In\u00a0[\u00a0]: Copied! <pre>records = list(parse_paf_file(paf_path))\nprint(f'Loaded {len(records)} records')\n\nif records:\n    rec = records[0]\n    print('\\nFirst record:')\n    print(\n        f'  query:   {rec.query_name}  [{rec.query_start}-{rec.query_end}]  len={rec.query_len}'\n    )\n    print(\n        f'  target:  {rec.target_name}  [{rec.target_start}-{rec.target_end}]  len={rec.target_len}'\n    )\n    print(f'  strand:  {rec.strand}')\n    print(f'  matches: {rec.residue_matches}')\n    print(f'  q_aligned_len: {rec.query_aligned_len}')\n    print(f'  t_aligned_len: {rec.target_aligned_len}')\n</pre> records = list(parse_paf_file(paf_path)) print(f'Loaded {len(records)} records')  if records:     rec = records[0]     print('\\nFirst record:')     print(         f'  query:   {rec.query_name}  [{rec.query_start}-{rec.query_end}]  len={rec.query_len}'     )     print(         f'  target:  {rec.target_name}  [{rec.target_start}-{rec.target_end}]  len={rec.target_len}'     )     print(f'  strand:  {rec.strand}')     print(f'  matches: {rec.residue_matches}')     print(f'  q_aligned_len: {rec.query_aligned_len}')     print(f'  t_aligned_len: {rec.target_aligned_len}') In\u00a0[\u00a0]: Copied! <pre>line = 'query\\t96\\t5\\t90\\t+\\ttarget\\t98\\t5\\t90\\t80\\t85\\t255\\ttp:A:P\\tcg:Z:10=5X20=3I30='\nrec = PafRecord.from_line(line)\n\nprint('Parsed PafRecord:')\nprint(f'  cigar:            {rec.cigar}')\nprint(f'  alignment_length: {rec.alignment_length}')\nprint(f'  n_matches:        {rec.n_matches}')\nprint(f'  n_mismatches:     {rec.n_mismatches}')\nprint(f'  n_gaps:           {rec.n_gaps}')\nprint(f'  n_gap_bases:      {rec.n_gap_bases}')\nprint(f'  tags:             {rec.tags}')\n</pre> line = 'query\\t96\\t5\\t90\\t+\\ttarget\\t98\\t5\\t90\\t80\\t85\\t255\\ttp:A:P\\tcg:Z:10=5X20=3I30=' rec = PafRecord.from_line(line)  print('Parsed PafRecord:') print(f'  cigar:            {rec.cigar}') print(f'  alignment_length: {rec.alignment_length}') print(f'  n_matches:        {rec.n_matches}') print(f'  n_mismatches:     {rec.n_mismatches}') print(f'  n_gaps:           {rec.n_gaps}') print(f'  n_gap_bases:      {rec.n_gap_bases}') print(f'  tags:             {rec.tags}') In\u00a0[\u00a0]: Copied! <pre>print(rec.to_line())\n</pre> print(rec.to_line()) In\u00a0[\u00a0]: Copied! <pre># Load from the PAF file we created earlier\naln = PafAlignment.from_file(paf_path)\nprint(aln)\nprint(f'Query names:  {aln.query_names}')\nprint(f'Target names: {aln.target_names}')\n</pre> # Load from the PAF file we created earlier aln = PafAlignment.from_file(paf_path) print(aln) print(f'Query names:  {aln.query_names}') print(f'Target names: {aln.target_names}') In\u00a0[\u00a0]: Copied! <pre># Construct from a list of records\naln2 = PafAlignment.from_records(records)\nprint(f'from_records: {aln2}')\n</pre> # Construct from a list of records aln2 = PafAlignment.from_records(records) print(f'from_records: {aln2}') In\u00a0[\u00a0]: Copied! <pre># Filter to a specific query\nfiltered_q = aln.filter_by_query(['query'])\nprint(f\"filter_by_query(['query']): {filtered_q}\")\n\n# Filter to a specific target\nfiltered_t = aln.filter_by_target(['target'])\nprint(f\"filter_by_target(['target']): {filtered_t}\")\n\n# Filter by minimum alignment length (query span)\n# Only keeps records where query_end - query_start &gt;= min_length\nfiltered_len = aln.filter_by_min_length(20)\nprint(f'filter_by_min_length(20): {filtered_len}')\n</pre> # Filter to a specific query filtered_q = aln.filter_by_query(['query']) print(f\"filter_by_query(['query']): {filtered_q}\")  # Filter to a specific target filtered_t = aln.filter_by_target(['target']) print(f\"filter_by_target(['target']): {filtered_t}\")  # Filter by minimum alignment length (query span) # Only keeps records where query_end - query_start &gt;= min_length filtered_len = aln.filter_by_min_length(20) print(f'filter_by_min_length(20): {filtered_len}') In\u00a0[\u00a0]: Copied! <pre># Build a multi-contig index to demonstrate reordering\nidx_multi = SequenceIndex(k=8)\nunit = 'ACGTACGTACGT'\nidx_multi.add_sequence('qA', unit * 5)\nidx_multi.add_sequence('qB', 'GCGCGCGCGCGCGCGCGCGC' * 3)\nidx_multi.add_sequence('tA', unit * 5)\nidx_multi.add_sequence('tB', ('T' + unit) * 4)\n\n# Write all-vs-all PAF\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    multi_paf_path = fh.name\n    for q in ['qA', 'qB']:\n        for t in ['tA', 'tB']:\n            for line in idx_multi.get_paf(q, t):\n                fh.write(line + '\\n')\n\naln_multi = PafAlignment.from_file(multi_paf_path)\nprint(f'Multi-contig alignment: {aln_multi}')\n\nq_sorted, t_sorted = aln_multi.reorder_contigs(\n    query_names=['qA', 'qB'],\n    target_names=['tA', 'tB'],\n)\nprint(f'Reordered queries:  {q_sorted}')\nprint(f'Reordered targets:  {t_sorted}')\n</pre> # Build a multi-contig index to demonstrate reordering idx_multi = SequenceIndex(k=8) unit = 'ACGTACGTACGT' idx_multi.add_sequence('qA', unit * 5) idx_multi.add_sequence('qB', 'GCGCGCGCGCGCGCGCGCGC' * 3) idx_multi.add_sequence('tA', unit * 5) idx_multi.add_sequence('tB', ('T' + unit) * 4)  # Write all-vs-all PAF with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     multi_paf_path = fh.name     for q in ['qA', 'qB']:         for t in ['tA', 'tB']:             for line in idx_multi.get_paf(q, t):                 fh.write(line + '\\n')  aln_multi = PafAlignment.from_file(multi_paf_path) print(f'Multi-contig alignment: {aln_multi}')  q_sorted, t_sorted = aln_multi.reorder_contigs(     query_names=['qA', 'qB'],     target_names=['tA', 'tB'], ) print(f'Reordered queries:  {q_sorted}') print(f'Reordered targets:  {t_sorted}') In\u00a0[\u00a0]: Copied! <pre>matches = [\n    (0, 50, 10, 60),\n    (55, 90, 65, 100),\n]\n\npaf_strings = py_coords_to_paf(\n    matches,\n    query_name='my_query',\n    query_len=100,\n    target_name='my_target',\n    target_len=120,\n)\n\nfor line in paf_strings:\n    print(line)\n</pre> matches = [     (0, 50, 10, 60),     (55, 90, 65, 100), ]  paf_strings = py_coords_to_paf(     matches,     query_name='my_query',     query_len=100,     target_name='my_target',     target_len=120, )  for line in paf_strings:     print(line) In\u00a0[\u00a0]: Copied! <pre># Pre-compute to populate the cache\nidx_multi.precompute_all_pairs(merge=True)\n\nq_order, t_order = idx_multi.optimal_contig_order(\n    query_names=['qA', 'qB'],\n    target_names=['tA', 'tB'],\n)\nprint(f'Optimal query order:  {q_order}')\nprint(f'Optimal target order: {t_order}')\n</pre> # Pre-compute to populate the cache idx_multi.precompute_all_pairs(merge=True)  q_order, t_order = idx_multi.optimal_contig_order(     query_names=['qA', 'qB'],     target_names=['tA', 'tB'], ) print(f'Optimal query order:  {q_order}') print(f'Optimal target order: {t_order}')"},{"location":"tutorials/paf_workflow/#paf-workflow-tutorial","title":"PAF Workflow Tutorial\u00b6","text":"<p>This notebook demonstrates the full PAF (Pairwise mApping Format) workflow in rusty-dot:</p> <ol> <li>Generating PAF output from a <code>SequenceIndex</code></li> <li>Writing PAF output to a file</li> <li>Reading PAF files back with <code>parse_paf_file</code> and <code>PafAlignment</code></li> <li>Parsing CIGAR strings for alignment statistics</li> <li>Filtering and reordering contigs with <code>PafAlignment.reorder_contigs</code></li> <li>Using the low-level <code>py_coords_to_paf</code> function</li> </ol> <p>PAF is a tab-separated, 12-column format used by many alignment tools.  It is the primary output format of rusty-dot.</p>"},{"location":"tutorials/paf_workflow/#1-generate-paf-output-from-a-sequenceindex","title":"1. Generate PAF output from a SequenceIndex\u00b6","text":"<p>The easiest way to produce PAF lines is <code>SequenceIndex.get_paf</code>.</p>"},{"location":"tutorials/paf_workflow/#2-write-paf-to-a-file","title":"2. Write PAF to a file\u00b6","text":"<p>PAF is a plain text format \u2014 just write each line with a newline.</p>"},{"location":"tutorials/paf_workflow/#3-read-a-paf-file-with-parse_paf_file","title":"3. Read a PAF file with parse_paf_file\u00b6","text":"<p><code>parse_paf_file</code> is a generator that yields <code>PafRecord</code> objects one at a time. Comment lines (starting with <code>#</code>) and blank lines are skipped.</p>"},{"location":"tutorials/paf_workflow/#4-parsing-a-paf-record-from-a-string","title":"4. Parsing a PAF record from a string\u00b6","text":"<p><code>PafRecord.from_line</code> parses a single PAF line string.</p>"},{"location":"tutorials/paf_workflow/#5-serialise-a-pafrecord-back-to-a-string","title":"5. Serialise a PafRecord back to a string\u00b6","text":"<p><code>to_line()</code> recreates the 12-column PAF string (tags are not re-emitted).</p>"},{"location":"tutorials/paf_workflow/#6-pafalignment-collection-with-contig-reordering","title":"6. PafAlignment \u2014 collection with contig reordering\u00b6","text":"<p><code>PafAlignment</code> wraps a list of <code>PafRecord</code> objects and provides filtering and gravity-based contig reordering.</p>"},{"location":"tutorials/paf_workflow/#filtering","title":"Filtering\u00b6","text":""},{"location":"tutorials/paf_workflow/#gravity-based-contig-reordering","title":"Gravity-based contig reordering\u00b6","text":"<p><code>reorder_contigs</code> sorts query and target names so that a subsequent dotplot shows maximum collinearity.  Each contig is assigned a gravity equal to the weighted mean position of its alignment blocks on the opposing axis.</p>"},{"location":"tutorials/paf_workflow/#7-low-level-py_coords_to_paf","title":"7. Low-level: py_coords_to_paf\u00b6","text":"<p><code>py_coords_to_paf</code> converts raw coordinate tuples to PAF strings without going through a <code>SequenceIndex</code>.  It is useful when you have coordinate data from another source.</p>"},{"location":"tutorials/paf_workflow/#8-using-sequenceindexoptimal_contig_order","title":"8. Using SequenceIndex.optimal_contig_order\u00b6","text":"<p>The <code>SequenceIndex</code> also exposes a built-in gravity-based ordering via <code>optimal_contig_order</code>, which uses the cached comparison results.</p>"},{"location":"tutorials/paf_workflow/#summary","title":"Summary\u00b6","text":"Task API Generate PAF lines <code>SequenceIndex.get_paf(query, target)</code> Parse a PAF file <code>parse_paf_file(path)</code> or <code>PafAlignment.from_file(path)</code> Parse a single line <code>PafRecord.from_line(line)</code> Serialise a record <code>PafRecord.to_line()</code> Filter by query/target <code>PafAlignment.filter_by_query(names)</code> / <code>filter_by_target(names)</code> Filter by alignment length <code>PafAlignment.filter_by_min_length(min_length)</code> Reorder contigs <code>PafAlignment.reorder_contigs()</code> or <code>SequenceIndex.optimal_contig_order()</code> Convert coords to PAF <code>py_coords_to_paf(matches, ...)</code>"},{"location":"tutorials/quickstart/","title":"Quick Start Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import matplotlib.pyplot as plt\n\nfrom rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n\nprint('rusty-dot imported successfully')\n</pre> import matplotlib.pyplot as plt  from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter  print('rusty-dot imported successfully') In\u00a0[\u00a0]: Copied! <pre># Create an index with k=10\nidx = SequenceIndex(k=10)\nprint(idx)  # SequenceIndex(k=10, sequences=0)\n</pre> # Create an index with k=10 idx = SequenceIndex(k=10) print(idx)  # SequenceIndex(k=10, sequences=0) In\u00a0[\u00a0]: Copied! <pre># Two sequences with a shared region\nseq_a = 'ACGTACGTACGTACGTACGT' * 5  # 100 bp\nseq_b = 'TACGTACGTACGTACGTACG' * 5  # 100 bp (shifted by 1 bp)\nseq_c = 'GCGCGCGCGCGCGCGCGCGC' * 5  # 100 bp (different content)\n\nidx.add_sequence('seq_a', seq_a)\nidx.add_sequence('seq_b', seq_b)\nidx.add_sequence('seq_c', seq_c)\n\nprint(f'Indexed sequences: {idx.sequence_names()}')\nprint(f'Total sequences: {len(idx)}')\n</pre> # Two sequences with a shared region seq_a = 'ACGTACGTACGTACGTACGT' * 5  # 100 bp seq_b = 'TACGTACGTACGTACGTACG' * 5  # 100 bp (shifted by 1 bp) seq_c = 'GCGCGCGCGCGCGCGCGCGC' * 5  # 100 bp (different content)  idx.add_sequence('seq_a', seq_a) idx.add_sequence('seq_b', seq_b) idx.add_sequence('seq_c', seq_c)  print(f'Indexed sequences: {idx.sequence_names()}') print(f'Total sequences: {len(idx)}') In\u00a0[\u00a0]: Copied! <pre># How many unique 10-mers does each sequence have?\nfor name in idx.sequence_names():\n    kset = idx.get_kmer_set(name)\n    print(\n        f'{name}: {len(kset)} unique k-mers, length={idx.get_sequence_length(name)} bp'\n    )\n</pre> # How many unique 10-mers does each sequence have? for name in idx.sequence_names():     kset = idx.get_kmer_set(name)     print(         f'{name}: {len(kset)} unique k-mers, length={idx.get_sequence_length(name)} bp'     ) In\u00a0[\u00a0]: Copied! <pre>matches = idx.compare_sequences('seq_a', 'seq_b', merge=True)\nprint(f'seq_a vs seq_b: {len(matches)} match blocks')\nfor m in matches[:5]:\n    q_start, q_end, t_start, t_end = m\n    print(\n        f'  query [{q_start}-{q_end}]  target [{t_start}-{t_end}]  length={q_end - q_start}'\n    )\n</pre> matches = idx.compare_sequences('seq_a', 'seq_b', merge=True) print(f'seq_a vs seq_b: {len(matches)} match blocks') for m in matches[:5]:     q_start, q_end, t_start, t_end = m     print(         f'  query [{q_start}-{q_end}]  target [{t_start}-{t_end}]  length={q_end - q_start}'     ) In\u00a0[\u00a0]: Copied! <pre># Fewer matches between unrelated sequences\nmatches_ac = idx.compare_sequences('seq_a', 'seq_c', merge=True)\nprint(f'seq_a vs seq_c: {len(matches_ac)} match blocks')\n</pre> # Fewer matches between unrelated sequences matches_ac = idx.compare_sequences('seq_a', 'seq_c', merge=True) print(f'seq_a vs seq_c: {len(matches_ac)} match blocks') In\u00a0[\u00a0]: Copied! <pre>stranded = idx.compare_sequences_stranded('seq_a', 'seq_b', merge=True)\nfwd = [m for m in stranded if m[4] == '+']\nrev = [m for m in stranded if m[4] == '-']\nprint(f'Forward matches: {len(fwd)}, Reverse-complement matches: {len(rev)}')\n</pre> stranded = idx.compare_sequences_stranded('seq_a', 'seq_b', merge=True) fwd = [m for m in stranded if m[4] == '+'] rev = [m for m in stranded if m[4] == '-'] print(f'Forward matches: {len(fwd)}, Reverse-complement matches: {len(rev)}') In\u00a0[\u00a0]: Copied! <pre>paf_lines = idx.get_paf('seq_a', 'seq_b', merge=True)\nprint(f'PAF lines: {len(paf_lines)}')\nprint('\\nFirst PAF line:')\nif paf_lines:\n    fields = paf_lines[0].split('\\t')\n    labels = [\n        'query',\n        'q_len',\n        'q_start',\n        'q_end',\n        'strand',\n        'target',\n        't_len',\n        't_start',\n        't_end',\n        'matches',\n        'block_len',\n        'mapq',\n    ]\n    for label, value in zip(labels, fields):\n        print(f'  {label:12s}: {value}')\n</pre> paf_lines = idx.get_paf('seq_a', 'seq_b', merge=True) print(f'PAF lines: {len(paf_lines)}') print('\\nFirst PAF line:') if paf_lines:     fields = paf_lines[0].split('\\t')     labels = [         'query',         'q_len',         'q_start',         'q_end',         'strand',         'target',         't_len',         't_start',         't_end',         'matches',         'block_len',         'mapq',     ]     for label, value in zip(labels, fields):         print(f'  {label:12s}: {value}') In\u00a0[\u00a0]: Copied! <pre># Save PAF output to a file\nimport os\nimport tempfile\n\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    paf_path = fh.name\n    for line in paf_lines:\n        fh.write(line + '\\n')\n\nprint(f'PAF saved to: {paf_path}')\nprint(f'File size: {os.path.getsize(paf_path)} bytes')\n</pre> # Save PAF output to a file import os import tempfile  with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     paf_path = fh.name     for line in paf_lines:         fh.write(line + '\\n')  print(f'PAF saved to: {paf_path}') print(f'File size: {os.path.getsize(paf_path)} bytes') In\u00a0[\u00a0]: Copied! <pre>import gzip\nimport tempfile\n\nfasta_content = '&gt;seq1\\nACGTACGTACGTACGTACGT\\n&gt;seq2\\nTACGTACGTACGTACGTACG\\n'\n\n# Plain FASTA\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.fasta', delete=False) as fh:\n    fh.write(fasta_content)\n    plain_path = fh.name\n\n# Gzipped FASTA\nwith tempfile.NamedTemporaryFile(suffix='.fasta.gz', delete=False) as fh:\n    gz_path = fh.name\nwith gzip.open(gz_path, 'wt') as fh:\n    fh.write(fasta_content)\n\n# Load into a fresh index\nidx2 = SequenceIndex(k=10)\nnames = idx2.load_fasta(plain_path)\nprint(f'Loaded from plain FASTA: {names}')\n\nidx3 = SequenceIndex(k=10)\nnames_gz = idx3.load_fasta(gz_path)\nprint(f'Loaded from gzipped FASTA: {names_gz}')\n</pre> import gzip import tempfile  fasta_content = '&gt;seq1\\nACGTACGTACGTACGTACGT\\n&gt;seq2\\nTACGTACGTACGTACGTACG\\n'  # Plain FASTA with tempfile.NamedTemporaryFile(mode='w', suffix='.fasta', delete=False) as fh:     fh.write(fasta_content)     plain_path = fh.name  # Gzipped FASTA with tempfile.NamedTemporaryFile(suffix='.fasta.gz', delete=False) as fh:     gz_path = fh.name with gzip.open(gz_path, 'wt') as fh:     fh.write(fasta_content)  # Load into a fresh index idx2 = SequenceIndex(k=10) names = idx2.load_fasta(plain_path) print(f'Loaded from plain FASTA: {names}')  idx3 = SequenceIndex(k=10) names_gz = idx3.load_fasta(gz_path) print(f'Loaded from gzipped FASTA: {names_gz}') In\u00a0[\u00a0]: Copied! <pre>import tempfile\n\n# Save\nwith tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as fh:\n    idx_path = fh.name\n\nidx.save(idx_path)\nprint(f'Index saved to: {idx_path}')\nprint(f'File size: {os.path.getsize(idx_path)} bytes')\n\n# Load into a new index (k must match)\nidx_loaded = SequenceIndex(k=10)\nidx_loaded.load(idx_path)\nprint(f'Loaded index: {idx_loaded}')\nprint(f'Sequences: {idx_loaded.sequence_names()}')\n</pre> import tempfile  # Save with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as fh:     idx_path = fh.name  idx.save(idx_path) print(f'Index saved to: {idx_path}') print(f'File size: {os.path.getsize(idx_path)} bytes')  # Load into a new index (k must match) idx_loaded = SequenceIndex(k=10) idx_loaded.load(idx_path) print(f'Loaded index: {idx_loaded}') print(f'Sequences: {idx_loaded.sequence_names()}') In\u00a0[\u00a0]: Copied! <pre>pairs = idx.precompute_all_pairs(merge=True)\nprint(f'Pre-computed {len(pairs)} pairs:')\nfor q, t in pairs:\n    print(f'  {q} vs {t}')\n</pre> pairs = idx.precompute_all_pairs(merge=True) print(f'Pre-computed {len(pairs)} pairs:') for q, t in pairs:     print(f'  {q} vs {t}') In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(idx)\n\n# Inline display only \u2014 no file is written\nfig = plotter.plot(title='Quick Start Dotplot \u2014 inline')\nplt.close(fig)  # free memory when no longer needed\n</pre> plotter = DotPlotter(idx)  # Inline display only \u2014 no file is written fig = plotter.plot(title='Quick Start Dotplot \u2014 inline') plt.close(fig)  # free memory when no longer needed In\u00a0[\u00a0]: Copied! <pre># Save to a PNG file and display inline\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    out_path = fh.name\n\nfig = plotter.plot(output_path=out_path, title='Quick Start Dotplot')\nplt.close(fig)\nprint(f'Dotplot saved to: {out_path}')\n</pre> # Save to a PNG file and display inline with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     out_path = fh.name  fig = plotter.plot(output_path=out_path, title='Quick Start Dotplot') plt.close(fig) print(f'Dotplot saved to: {out_path}')"},{"location":"tutorials/quickstart/#quick-start-tutorial","title":"Quick Start Tutorial\u00b6","text":"<p>This notebook demonstrates the core workflow of rusty-dot: building a sequence index, finding shared k-mer matches, generating PAF-format alignments, and visualising results as a dotplot.</p>"},{"location":"tutorials/quickstart/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Install rusty-dot following the Installation guide, then run:</p> <pre>pip install jupyter\n</pre>"},{"location":"tutorials/quickstart/#1-import-the-package","title":"1. Import the package\u00b6","text":""},{"location":"tutorials/quickstart/#2-build-a-sequenceindex","title":"2. Build a SequenceIndex\u00b6","text":"<p><code>SequenceIndex</code> is the core class.  You supply the k-mer length <code>k</code> at construction time. A larger <code>k</code> reduces spurious matches but may miss shorter conserved regions.</p>"},{"location":"tutorials/quickstart/#3-add-sequences-directly","title":"3. Add sequences directly\u00b6","text":"<p>Use <code>add_sequence(name, seq)</code> to add individual sequences. These are stored in-memory and indexed immediately.</p>"},{"location":"tutorials/quickstart/#4-query-the-index","title":"4. Query the index\u00b6","text":""},{"location":"tutorials/quickstart/#4a-inspect-k-mer-sets","title":"4a. Inspect k-mer sets\u00b6","text":""},{"location":"tutorials/quickstart/#4b-find-shared-k-mer-matches","title":"4b. Find shared k-mer matches\u00b6","text":"<p><code>compare_sequences</code> intersects the k-mer sets and returns <code>(query_start, query_end, target_start, target_end)</code> tuples.</p>"},{"location":"tutorials/quickstart/#4c-stranded-matches","title":"4c. Stranded matches\u00b6","text":"<p><code>compare_sequences_stranded</code> additionally searches for reverse-complement matches, returning a 5-tuple <code>(q_start, q_end, t_start, t_end, strand)</code> where strand is <code>\"+\"</code> or <code>\"-\"</code>.</p>"},{"location":"tutorials/quickstart/#5-paf-output","title":"5. PAF output\u00b6","text":"<p>PAF (Pairwise mApping Format) is a standard tab-separated format for alignment records. <code>get_paf</code> returns a list of 12-column PAF strings.</p>"},{"location":"tutorials/quickstart/#6-load-from-fasta-files","title":"6. Load from FASTA files\u00b6","text":"<p><code>load_fasta</code> reads plain or gzipped FASTA files with automatic format detection.</p>"},{"location":"tutorials/quickstart/#7-save-and-load-the-index","title":"7. Save and load the index\u00b6","text":"<p>Indexes can be serialised to disk and reloaded, avoiding the need to reprocess large FASTA files.</p>"},{"location":"tutorials/quickstart/#8-pre-compute-all-pairs","title":"8. Pre-compute all pairs\u00b6","text":"<p>For repeated queries over the same dataset, <code>precompute_all_pairs</code> fills the result cache for every ordered <code>(i, j)</code> pair in one go.</p>"},{"location":"tutorials/quickstart/#9-simple-dotplot","title":"9. Simple dotplot\u00b6","text":"<p>The <code>DotPlotter</code> class wraps the index to generate publication-ready dotplots.</p> <p>Both <code>plot()</code> and <code>plot_single()</code> return a <code>matplotlib.figure.Figure</code>.  In a Jupyter notebook the figure is displayed inline automatically when you omit <code>output_path</code>.  Pass <code>output_path</code> to save to disk as well.</p> <p>See the Dotplot Visualization tutorial for the full list of options including SVG, PDF, and other file formats.</p>"},{"location":"tutorials/quickstart/#next-steps","title":"Next steps\u00b6","text":"<ul> <li>Dotplot Visualization tutorial \u2014 all plot customisation options.</li> <li>PAF Workflow tutorial \u2014 loading PAF files, CIGAR parsing, and contig reordering.</li> <li>API Reference \u2014 complete documentation for every class and function.</li> </ul>"}]}
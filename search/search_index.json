{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"rusty-dot","text":"<p>rusty-dot is a Rust + PyO3 tool for making fast dot plot comparisons of DNA sequences using a Rust FM-Index.</p>"},{"location":"#overview","title":"Overview","text":"<p>rusty-dot provides a high-performance toolkit for pairwise DNA sequence comparison and visualisation. At its core, it builds an FM-index (via rust-bio) for each sequence and uses k-mer set intersection to efficiently find shared subsequences between any two sequences in the collection.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Fast FM-index construction via Rust + PyO3 bindings</li> <li>Read FASTA / gzipped FASTA files via needletail</li> <li>Build FM-indexes per sequence using rust-bio</li> <li>K-mer set intersection for efficient shared k-mer lookup</li> <li>Both-strand k-mer matching: forward (<code>+</code>) and reverse-complement (<code>-</code>) hits via <code>compare_sequences_stranded</code></li> <li>Complete RC hit coverage: two patterns merged independently \u2014 anti-diagonal (standard inverted repeat) and co-diagonal (both arms same direction)</li> <li>Unified merge API (<code>py_merge_runs</code>) handles all orientation cases with a single call</li> <li>PAF format output for alignment records</li> <li>FM-index serialization/deserialization with serde + bincode</li> <li>All-vs-all dotplot visualization with matplotlib: forward hits in blue, RC hits in red; edge-only axis labels in grid plots; subpanels scaled by sequence length by default (<code>scale_sequences=True</code>)</li> <li><code>CrossIdx</code> multi-group cross-index: N arbitrary sequence groups, configurable group pairs for alignment, per-group contig ordering (insertion order, length, or collinearity), <code>run_merge</code> to update cached PAF records, compatible with <code>DotPlotter</code></li> <li>Full Python bindings via PyO3</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n\n# Build index for two sequences\nidx = SequenceIndex(k=15)\nidx.load_fasta(\"genome1.fasta\")\nidx.load_fasta(\"genome2.fasta\")\n\n# Get PAF-format alignments (forward strand only)\nfor line in idx.get_paf(\"seq1\", \"seq2\"):\n    print(line)\n\n# Stranded comparison: forward (+) and reverse-complement (-) hits\nhits = idx.compare_sequences_stranded(\"seq1\", \"seq2\", merge=True)\nfor qs, qe, ts, te, strand in hits:\n    print(f\"{strand}  q[{qs}:{qe}]  t[{ts}:{te}]\")\n\n# Generate dotplot \u2014 forward hits blue, RC hits red\nplotter = DotPlotter(idx)\nplotter.plot(output_path=\"dotplot.png\")\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Installation \u2014 how to install rusty-dot and its dependencies.</li> <li>Tutorials \u2014 step-by-step Jupyter notebook walkthroughs.</li> <li>API Reference \u2014 full documentation for all classes and functions.</li> </ul>"},{"location":"development/","title":"Development Guide","text":"<p>This page explains how to set up a local development environment for rusty-dot so you can edit both the Rust extension and the Python package and run the full test suite.</p>"},{"location":"development/#prerequisites","title":"Prerequisites","text":""},{"location":"development/#install-rust","title":"Install Rust","text":"<p>rusty-dot requires a working Rust toolchain (stable channel). Install it with rustup:</p> <pre><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource $HOME/.cargo/env\nrustup update stable\n</code></pre> <p>Verify the installation:</p> <pre><code>rustc --version\ncargo --version\n</code></pre>"},{"location":"development/#create-a-conda-environment","title":"Create a conda environment","text":"<p>A minimal conda environment file is provided at <code>environment.yml</code>. It pins Python to 3.13 and installs the key Python dependencies.</p> <pre><code>conda env create -f environment.yml\nconda activate rustydot\n</code></pre> <p>Alternatively, use any Python \u2265 3.9 virtual environment:</p> <pre><code>python -m venv .venv\nsource .venv/bin/activate   # Windows: .venv\\Scripts\\activate\n</code></pre>"},{"location":"development/#fork-and-clone-the-repository","title":"Fork and clone the repository","text":"<p>Fork rusty-dot on GitHub, then clone your fork:</p> <pre><code>git clone https://github.com/&lt;your-username&gt;/rusty-dot.git\ncd rusty-dot\ngit remote add upstream https://github.com/Adamtaranto/rusty-dot.git\n</code></pre>"},{"location":"development/#install-in-development-mode","title":"Install in development mode","text":"<p>maturin is the build backend for the Rust extension. Install it and then build the package in editable mode:</p> <pre><code>pip install maturin\n# Build Rust extension + install package in editable mode\nmaturin develop --extras dev,docs\n</code></pre> <p>The <code>--extras dev,docs</code> flag installs all optional development and documentation dependencies declared in <code>pyproject.toml</code>.</p> <p>Verify the install:</p> <pre><code>import rusty_dot\nprint(rusty_dot.__version__)\n</code></pre> <p>Note</p> <p>Always re-run <code>maturin develop</code> after modifying any Rust source files (<code>src/*.rs</code>).  Pure Python changes in <code>python/rusty_dot/</code> take effect immediately without a rebuild.</p>"},{"location":"development/#installing-pre-commit-hooks","title":"Installing pre-commit hooks","text":"<p>rusty-dot uses pre-commit to enforce code quality on every commit.  Install the hooks once after cloning:</p> <pre><code>pip install pre-commit   # already included in the dev extras\npre-commit install                 # install commit-stage hooks\npre-commit install --hook-type pre-push   # install push-stage hooks\n</code></pre> <p>The hooks include:</p> Hook Stage What it checks <code>check-ast</code> / <code>check-yaml</code> / <code>check-toml</code> commit File syntax <code>trailing-whitespace</code> / <code>end-of-file-fixer</code> commit Whitespace <code>cargo fmt --check</code> commit Rust formatting <code>cargo check</code> commit Rust compilation <code>cargo clippy -- -D warnings</code> commit Rust linting <code>ruff format</code> / <code>ruff check</code> commit Python formatting &amp; linting <code>pydocstyle</code> (<code>.pyi</code> stubs only) commit Docstring style <code>cargo test --lib</code> push Rust unit tests <code>pytest tests/ -x -q</code> push Python test suite <p>Run all hooks manually at any time:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"development/#running-python-tests","title":"Running Python tests","text":"<pre><code>pytest tests/ -v\n</code></pre> <p>To run a specific test file or test function:</p> <pre><code>pytest tests/test_index.py -v\npytest tests/test_index.py::test_get_paf_all_returns_paf_lines -v\n</code></pre>"},{"location":"development/#python-code-style-ruff","title":"Python code style \u2014 ruff","text":"<p>rusty-dot uses ruff for Python linting and formatting (configured in <code>pyproject.toml</code>).</p> <p>Check for issues:</p> <pre><code>ruff check python/ tests/\n</code></pre> <p>Auto-fix fixable issues:</p> <pre><code>ruff check --fix python/ tests/\n</code></pre> <p>Format code:</p> <pre><code>ruff format python/ tests/\n</code></pre>"},{"location":"development/#rust-code-quality","title":"Rust code quality","text":""},{"location":"development/#format","title":"Format","text":"<pre><code>cargo fmt\n</code></pre> <p>Check formatting without modifying files (also used by the pre-commit hook):</p> <pre><code>cargo fmt --all -- --check\n</code></pre>"},{"location":"development/#lint-clippy","title":"Lint (Clippy)","text":"<pre><code>cargo clippy -- -D warnings\n</code></pre>"},{"location":"development/#compile-check","title":"Compile check","text":"<p>Quickly verify the crate compiles without producing a binary:</p> <pre><code>cargo check\n</code></pre>"},{"location":"development/#rust-unit-tests","title":"Rust unit tests","text":"<p>Run the Rust-side library tests:</p> <pre><code>cargo test --lib\n</code></pre> <p>Run all Rust tests (including integration tests, if any):</p> <pre><code>cargo test\n</code></pre>"},{"location":"development/#building-the-documentation-locally","title":"Building the documentation locally","text":"<p>Install the docs dependencies (included in <code>pip install maturin --extras dev,docs</code>):</p> <pre><code>mkdocs serve\n</code></pre> <p>Open http://127.0.0.1:8000 in your browser.  The site rebuilds automatically when you save a documentation file.</p> <p>To build a static site:</p> <pre><code>mkdocs build\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or later</li> <li>A working Rust toolchain (for building from source)</li> <li>maturin \u2265 1.0</li> </ul>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<p>Clone the repository and build the Rust extension with maturin:</p> <pre><code>git clone https://github.com/Adamtaranto/rusty-dot.git\ncd rusty-dot\npip install maturin\nmaturin develop --release\n</code></pre> <p>The <code>--release</code> flag enables full Rust compiler optimisations, which is strongly recommended for any non-trivial dataset.</p>"},{"location":"installation/#install-python-dependencies","title":"Install Python dependencies","text":"<p>rusty-dot depends on:</p> Package Purpose <code>matplotlib \u2265 3.5</code> Dotplot visualisation <code>numpy \u2265 1.21</code> Array operations used by matplotlib <p>These are declared as package dependencies and will be installed automatically by pip.</p>"},{"location":"installation/#optional-documentation-dependencies","title":"Optional: documentation dependencies","text":"<p>To build the documentation locally:</p> <pre><code>pip install rusty-dot[docs]\nmkdocs serve\n</code></pre>"},{"location":"installation/#verify-the-installation","title":"Verify the installation","text":"<pre><code>import rusty_dot\nprint(rusty_dot.__version__)  # 0.1.0\n\nfrom rusty_dot import SequenceIndex\nidx = SequenceIndex(k=10)\nidx.add_sequence(\"test\", \"ACGTACGTACGT\")\nprint(idx)  # SequenceIndex(k=10, sequences=1)\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>rusty-dot exposes its functionality through the following classes and functions.</p>"},{"location":"api/#classes","title":"Classes","text":"Class Module Description <code>SequenceIndex</code> <code>rusty_dot</code> Rust-backed FM-index for sequence comparison <code>DotPlotter</code> <code>rusty_dot.dotplot</code> All-vs-all dotplot visualisation <code>CrossIdx</code> <code>rusty_dot.paf_io</code> Multi-group cross-index for cross-group pairwise comparisons; DotPlotter-compatible <code>PafRecord</code> <code>rusty_dot.paf_io</code> Single PAF alignment record <code>PafAlignment</code> <code>rusty_dot.paf_io</code> Collection of PAF records with reordering utilities"},{"location":"api/#functions","title":"Functions","text":"Function Module Description <code>py_read_fasta</code> <code>rusty_dot</code> Read a FASTA or gzipped FASTA file <code>py_build_kmer_set</code> <code>rusty_dot</code> Build the k-mer set for a sequence <code>py_find_kmer_coords</code> <code>rusty_dot</code> Find k-mer positions in a sequence via FM-index <code>py_merge_runs</code> <code>rusty_dot</code> Unified strand-aware merge: forward and both RC patterns <code>py_merge_kmer_runs</code> <code>rusty_dot</code> Merge forward-strand (<code>+</code>) co-linear k-mer hits into blocks <code>py_merge_rev_runs</code> <code>rusty_dot</code> Merge RC anti-diagonal k-mer hits (standard inverted repeat) <code>py_merge_rev_fwd_runs</code> <code>rusty_dot</code> Merge RC co-diagonal k-mer hits (both arms same direction) <code>py_coords_to_paf</code> <code>rusty_dot</code> Convert coordinate tuples to PAF lines <code>py_save_index</code> <code>rusty_dot</code> Serialise an index collection to disk <code>py_load_index</code> <code>rusty_dot</code> Load a serialised index from disk <code>parse_paf_file</code> <code>rusty_dot.paf_io</code> Yield PAF records from a file <code>compute_gravity_contigs</code> <code>rusty_dot.paf_io</code> Sort contigs by gravity centre"},{"location":"api/dotplot/","title":"DotPlotter","text":"<p>The <code>DotPlotter</code> class generates all-vs-all dotplot figures from a populated <code>SequenceIndex</code>.</p>"},{"location":"api/dotplot/#class","title":"Class","text":""},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter","title":"<code>DotPlotter</code>","text":"<p>Generate all-vs-all dotplots for sets of DNA sequences.</p> <p>Accepts either a :class:<code>~rusty_dot.SequenceIndex</code> (single sequence collection) or a :class:<code>~rusty_dot.paf_io.CrossIdx</code> (multi-group collection).  When using a <code>CrossIdx</code>, pass group-specific names via <code>query_names</code> and <code>target_names</code>::</p> <pre><code>cross = CrossIdx(k=15)\ncross.load_fasta(\"assembly_a.fasta\", group=\"a\")\ncross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\nplotter = DotPlotter(cross)\nplotter.plot(\n    query_names=cross.sequence_names(group=\"a\"),\n    target_names=cross.sequence_names(group=\"b\"),\n    output_path=\"cross_plot.png\",\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>SequenceIndex or CrossIdx</code> <p>A populated index instance.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rusty_dot import SequenceIndex\n&gt;&gt;&gt; from rusty_dot.dotplot import DotPlotter\n&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\" * 10)\n&gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\" * 10)\n&gt;&gt;&gt; plotter = DotPlotter(idx)\n&gt;&gt;&gt; plotter.plot(output_path=\"dotplot.png\")\n</code></pre> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>class DotPlotter:\n    \"\"\"Generate all-vs-all dotplots for sets of DNA sequences.\n\n    Accepts either a :class:`~rusty_dot.SequenceIndex` (single sequence\n    collection) or a :class:`~rusty_dot.paf_io.CrossIdx` (multi-group\n    collection).  When using a ``CrossIdx``, pass group-specific names via\n    ``query_names`` and ``target_names``::\n\n        cross = CrossIdx(k=15)\n        cross.load_fasta(\"assembly_a.fasta\", group=\"a\")\n        cross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\n        plotter = DotPlotter(cross)\n        plotter.plot(\n            query_names=cross.sequence_names(group=\"a\"),\n            target_names=cross.sequence_names(group=\"b\"),\n            output_path=\"cross_plot.png\",\n        )\n\n    Parameters\n    ----------\n    index : SequenceIndex or CrossIdx\n        A populated index instance.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from rusty_dot import SequenceIndex\n    &gt;&gt;&gt; from rusty_dot.dotplot import DotPlotter\n    &gt;&gt;&gt; idx = SequenceIndex(k=10)\n    &gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\" * 10)\n    &gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\" * 10)\n    &gt;&gt;&gt; plotter = DotPlotter(idx)\n    &gt;&gt;&gt; plotter.plot(output_path=\"dotplot.png\")\n    \"\"\"\n\n    def __init__(self, index: Union[SequenceIndex, 'CrossIdx']) -&gt; None:\n        \"\"\"Initialise the DotPlotter.\n\n        Parameters\n        ----------\n        index : SequenceIndex or CrossIdx\n            A populated index instance.\n        \"\"\"\n        self.index = index\n\n    def plot(\n        self,\n        query_names: Optional[list[str]] = None,\n        target_names: Optional[list[str]] = None,\n        output_path: Union[str, Path] = 'dotplot.png',\n        figsize_per_panel: float = 4.0,\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        rc_color: str = 'red',\n        merge: bool = True,\n        title: Optional[str] = None,\n        dpi: int = 150,\n        scale_sequences: bool = True,\n    ) -&gt; None:\n        \"\"\"Plot an all-vs-all dotplot grid.\n\n        If both ``query_names`` and ``target_names`` are provided, the plot\n        will show each query sequence (rows) against each target sequence\n        (columns). If only one set is provided, or neither, all pairwise\n        combinations within the available sequences are plotted.\n\n        Parameters\n        ----------\n        query_names : list[str], optional\n            Sequence names for the y-axis (rows). If ``None``, uses all\n            sequences in the index.\n        target_names : list[str], optional\n            Sequence names for the x-axis (columns). If ``None``, uses all\n            sequences in the index.\n        output_path : str or Path, optional\n            Output image file path. Default is ``\"dotplot.png\"``.\n        figsize_per_panel : float, optional\n            Base size in inches for each subplot panel when\n            ``scale_sequences=False``.  When ``scale_sequences=True`` this\n            value sets the size of the *longest* sequence axis and all\n            other axes are scaled proportionally.  Default is ``4.0``.\n        dot_size : float, optional\n            Size of each dot in the scatter plot. Default is ``0.5``.\n        dot_color : str, optional\n            Colour for forward-strand (``+``) match lines. Default is ``\"blue\"``.\n        rc_color : str, optional\n            Colour for reverse-complement (``-``) strand match lines.\n            Default is ``\"red\"``.\n        merge : bool, optional\n            Whether to merge sequential k-mer runs before plotting.\n            Default is ``True``.\n        title : str, optional\n            Overall figure title. If ``None``, no title is added.\n        dpi : int, optional\n            Resolution of the output image. Default is ``150``.\n        scale_sequences : bool, optional\n            When ``True`` (default), subplot widths and heights are\n            proportional to the lengths of the corresponding sequences so that\n            relative sequence sizes are preserved.  When ``False``, every\n            panel has the same fixed size.\n        \"\"\"\n        all_names = self.index.sequence_names()\n        if not all_names:\n            raise ValueError('No sequences in the index.')\n\n        if query_names is None:\n            query_names = sorted(all_names)\n        if target_names is None:\n            target_names = sorted(all_names)\n\n        nrows = len(query_names)\n        ncols = len(target_names)\n\n        if scale_sequences:\n            q_lens = [self.index.get_sequence_length(n) for n in query_names]\n            t_lens = [self.index.get_sequence_length(n) for n in target_names]\n            max_len = max(max(q_lens), max(t_lens), 1)\n            col_widths = [figsize_per_panel * (seq_len / max_len) for seq_len in t_lens]\n            row_heights = [\n                figsize_per_panel * (seq_len / max_len) for seq_len in q_lens\n            ]\n            fig_w = sum(col_widths)\n            fig_h = sum(row_heights)\n            fig, axes = plt.subplots(\n                nrows,\n                ncols,\n                figsize=(fig_w, fig_h),\n                squeeze=False,\n                gridspec_kw={\n                    'width_ratios': col_widths,\n                    'height_ratios': row_heights,\n                },\n            )\n        else:\n            fig_w = figsize_per_panel * ncols\n            fig_h = figsize_per_panel * nrows\n            fig, axes = plt.subplots(\n                nrows,\n                ncols,\n                figsize=(fig_w, fig_h),\n                squeeze=False,\n            )\n\n        for row_idx, q_name in enumerate(query_names):\n            for col_idx, t_name in enumerate(target_names):\n                ax = axes[row_idx][col_idx]\n                self._plot_panel(\n                    ax,\n                    q_name,\n                    t_name,\n                    dot_size=dot_size,\n                    dot_color=dot_color,\n                    rc_color=rc_color,\n                    merge=merge,\n                    # Only label the leftmost column (y) and bottom row (x)\n                    show_xlabel=(row_idx == nrows - 1),\n                    show_ylabel=(col_idx == 0),\n                )\n\n        if title:\n            fig.suptitle(title, fontsize=14, y=1.01)\n\n        plt.tight_layout()\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n        plt.close(fig)\n\n    def _plot_panel(\n        self,\n        ax: plt.Axes,\n        query_name: str,\n        target_name: str,\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        rc_color: str = 'red',\n        merge: bool = True,\n        show_xlabel: bool = True,\n        show_ylabel: bool = True,\n    ) -&gt; None:\n        \"\"\"Render a single comparison panel onto the given Axes.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n            The axes to draw on.\n        query_name : str\n            Name of the query sequence (y-axis).\n        target_name : str\n            Name of the target sequence (x-axis).\n        dot_size : float, optional\n            Marker size. Default is ``0.5``.\n        dot_color : str, optional\n            Marker colour for forward-strand (``+``) matches. Default is ``\"blue\"``.\n        rc_color : str, optional\n            Marker colour for reverse-complement (``-``) matches. Default is ``\"red\"``.\n        merge : bool, optional\n            Whether to merge sequential runs. Default is ``True``.\n        show_xlabel : bool, optional\n            Whether to render the target sequence name as an x-axis label.\n            Default is ``True``.\n        show_ylabel : bool, optional\n            Whether to render the query sequence name as a y-axis label.\n            Default is ``True``.\n        \"\"\"\n        q_len = self.index.get_sequence_length(query_name)\n        t_len = self.index.get_sequence_length(target_name)\n\n        matches = self.index.compare_sequences_stranded(query_name, target_name, merge)\n\n        # Draw match lines/dots; RC matches are drawn as anti-diagonal lines.\n        for q_start, q_end, t_start, t_end, strand in matches:\n            if strand == '-':\n                # Reverse complement: as query advances (q_start\u2192q_end) the\n                # target position retreats (t_end\u2192t_start).\n                xs = [t_end, t_start]\n                color = rc_color\n            else:\n                xs = [t_start, t_end]\n                color = dot_color\n            ax.plot(\n                xs,\n                [q_start, q_end],\n                color=color,\n                linewidth=dot_size,\n                alpha=0.7,\n            )\n\n        ax.set_xlim(0, t_len)\n        ax.set_ylim(0, q_len)\n        ax.invert_yaxis()\n        if show_xlabel:\n            ax.set_xlabel(target_name, fontsize=8)\n        if show_ylabel:\n            ax.set_ylabel(query_name, fontsize=8)\n        ax.tick_params(axis='both', labelsize=6)\n        ax.set_aspect('auto')\n\n    def plot_single(\n        self,\n        query_name: str,\n        target_name: str,\n        output_path: Union[str, Path] = 'dotplot.png',\n        figsize: tuple[float, float] = (6.0, 6.0),\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        rc_color: str = 'red',\n        merge: bool = True,\n        title: Optional[str] = None,\n        dpi: int = 150,\n    ) -&gt; None:\n        \"\"\"Plot a single pairwise dotplot.\n\n        Parameters\n        ----------\n        query_name : str\n            Name of the query sequence (y-axis).\n        target_name : str\n            Name of the target sequence (x-axis).\n        output_path : str or Path, optional\n            Output image file path. Default is ``\"dotplot.png\"``.\n        figsize : tuple[float, float], optional\n            Figure size as (width, height) in inches. Default is ``(6, 6)``.\n        dot_size : float, optional\n            Marker/line size for each match. Default is ``0.5``.\n        dot_color : str, optional\n            Colour for forward-strand (``+``) matches. Default is ``\"blue\"``.\n        rc_color : str, optional\n            Colour for reverse-complement (``-``) matches. Default is ``\"red\"``.\n        merge : bool, optional\n            Whether to merge sequential k-mer runs. Default is ``True``.\n        title : str, optional\n            Plot title. If ``None``, a default title is used.\n        dpi : int, optional\n            Output image resolution. Default is ``150``.\n        \"\"\"\n        fig, ax = plt.subplots(figsize=figsize)\n        self._plot_panel(\n            ax,\n            query_name,\n            target_name,\n            dot_size=dot_size,\n            dot_color=dot_color,\n            rc_color=rc_color,\n            merge=merge,\n        )\n        if title is None:\n            title = f'{query_name} vs {target_name}'\n        ax.set_title(title, fontsize=10)\n        plt.tight_layout()\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n        plt.close(fig)\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter-functions","title":"Functions","text":""},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.__init__","title":"<code>__init__(index)</code>","text":"<p>Initialise the DotPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>SequenceIndex or CrossIdx</code> <p>A populated index instance.</p> required Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def __init__(self, index: Union[SequenceIndex, 'CrossIdx']) -&gt; None:\n    \"\"\"Initialise the DotPlotter.\n\n    Parameters\n    ----------\n    index : SequenceIndex or CrossIdx\n        A populated index instance.\n    \"\"\"\n    self.index = index\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot","title":"<code>plot(query_names=None, target_names=None, output_path='dotplot.png', figsize_per_panel=4.0, dot_size=0.5, dot_color='blue', rc_color='red', merge=True, title=None, dpi=150, scale_sequences=True)</code>","text":"<p>Plot an all-vs-all dotplot grid.</p> <p>If both <code>query_names</code> and <code>target_names</code> are provided, the plot will show each query sequence (rows) against each target sequence (columns). If only one set is provided, or neither, all pairwise combinations within the available sequences are plotted.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str]</code> <p>Sequence names for the y-axis (rows). If <code>None</code>, uses all sequences in the index.</p> <code>None</code> <code>target_names</code> <code>list[str]</code> <p>Sequence names for the x-axis (columns). If <code>None</code>, uses all sequences in the index.</p> <code>None</code> <code>output_path</code> <code>str or Path</code> <p>Output image file path. Default is <code>\"dotplot.png\"</code>.</p> <code>'dotplot.png'</code> <code>figsize_per_panel</code> <code>float</code> <p>Base size in inches for each subplot panel when <code>scale_sequences=False</code>.  When <code>scale_sequences=True</code> this value sets the size of the longest sequence axis and all other axes are scaled proportionally.  Default is <code>4.0</code>.</p> <code>4.0</code> <code>dot_size</code> <code>float</code> <p>Size of each dot in the scatter plot. Default is <code>0.5</code>.</p> <code>0.5</code> <code>dot_color</code> <code>str</code> <p>Colour for forward-strand (<code>+</code>) match lines. Default is <code>\"blue\"</code>.</p> <code>'blue'</code> <code>rc_color</code> <code>str</code> <p>Colour for reverse-complement (<code>-</code>) strand match lines. Default is <code>\"red\"</code>.</p> <code>'red'</code> <code>merge</code> <code>bool</code> <p>Whether to merge sequential k-mer runs before plotting. Default is <code>True</code>.</p> <code>True</code> <code>title</code> <code>str</code> <p>Overall figure title. If <code>None</code>, no title is added.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Resolution of the output image. Default is <code>150</code>.</p> <code>150</code> <code>scale_sequences</code> <code>bool</code> <p>When <code>True</code> (default), subplot widths and heights are proportional to the lengths of the corresponding sequences so that relative sequence sizes are preserved.  When <code>False</code>, every panel has the same fixed size.</p> <code>True</code> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot(\n    self,\n    query_names: Optional[list[str]] = None,\n    target_names: Optional[list[str]] = None,\n    output_path: Union[str, Path] = 'dotplot.png',\n    figsize_per_panel: float = 4.0,\n    dot_size: float = 0.5,\n    dot_color: str = 'blue',\n    rc_color: str = 'red',\n    merge: bool = True,\n    title: Optional[str] = None,\n    dpi: int = 150,\n    scale_sequences: bool = True,\n) -&gt; None:\n    \"\"\"Plot an all-vs-all dotplot grid.\n\n    If both ``query_names`` and ``target_names`` are provided, the plot\n    will show each query sequence (rows) against each target sequence\n    (columns). If only one set is provided, or neither, all pairwise\n    combinations within the available sequences are plotted.\n\n    Parameters\n    ----------\n    query_names : list[str], optional\n        Sequence names for the y-axis (rows). If ``None``, uses all\n        sequences in the index.\n    target_names : list[str], optional\n        Sequence names for the x-axis (columns). If ``None``, uses all\n        sequences in the index.\n    output_path : str or Path, optional\n        Output image file path. Default is ``\"dotplot.png\"``.\n    figsize_per_panel : float, optional\n        Base size in inches for each subplot panel when\n        ``scale_sequences=False``.  When ``scale_sequences=True`` this\n        value sets the size of the *longest* sequence axis and all\n        other axes are scaled proportionally.  Default is ``4.0``.\n    dot_size : float, optional\n        Size of each dot in the scatter plot. Default is ``0.5``.\n    dot_color : str, optional\n        Colour for forward-strand (``+``) match lines. Default is ``\"blue\"``.\n    rc_color : str, optional\n        Colour for reverse-complement (``-``) strand match lines.\n        Default is ``\"red\"``.\n    merge : bool, optional\n        Whether to merge sequential k-mer runs before plotting.\n        Default is ``True``.\n    title : str, optional\n        Overall figure title. If ``None``, no title is added.\n    dpi : int, optional\n        Resolution of the output image. Default is ``150``.\n    scale_sequences : bool, optional\n        When ``True`` (default), subplot widths and heights are\n        proportional to the lengths of the corresponding sequences so that\n        relative sequence sizes are preserved.  When ``False``, every\n        panel has the same fixed size.\n    \"\"\"\n    all_names = self.index.sequence_names()\n    if not all_names:\n        raise ValueError('No sequences in the index.')\n\n    if query_names is None:\n        query_names = sorted(all_names)\n    if target_names is None:\n        target_names = sorted(all_names)\n\n    nrows = len(query_names)\n    ncols = len(target_names)\n\n    if scale_sequences:\n        q_lens = [self.index.get_sequence_length(n) for n in query_names]\n        t_lens = [self.index.get_sequence_length(n) for n in target_names]\n        max_len = max(max(q_lens), max(t_lens), 1)\n        col_widths = [figsize_per_panel * (seq_len / max_len) for seq_len in t_lens]\n        row_heights = [\n            figsize_per_panel * (seq_len / max_len) for seq_len in q_lens\n        ]\n        fig_w = sum(col_widths)\n        fig_h = sum(row_heights)\n        fig, axes = plt.subplots(\n            nrows,\n            ncols,\n            figsize=(fig_w, fig_h),\n            squeeze=False,\n            gridspec_kw={\n                'width_ratios': col_widths,\n                'height_ratios': row_heights,\n            },\n        )\n    else:\n        fig_w = figsize_per_panel * ncols\n        fig_h = figsize_per_panel * nrows\n        fig, axes = plt.subplots(\n            nrows,\n            ncols,\n            figsize=(fig_w, fig_h),\n            squeeze=False,\n        )\n\n    for row_idx, q_name in enumerate(query_names):\n        for col_idx, t_name in enumerate(target_names):\n            ax = axes[row_idx][col_idx]\n            self._plot_panel(\n                ax,\n                q_name,\n                t_name,\n                dot_size=dot_size,\n                dot_color=dot_color,\n                rc_color=rc_color,\n                merge=merge,\n                # Only label the leftmost column (y) and bottom row (x)\n                show_xlabel=(row_idx == nrows - 1),\n                show_ylabel=(col_idx == 0),\n            )\n\n    if title:\n        fig.suptitle(title, fontsize=14, y=1.01)\n\n    plt.tight_layout()\n    plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n    plt.close(fig)\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot_single","title":"<code>plot_single(query_name, target_name, output_path='dotplot.png', figsize=(6.0, 6.0), dot_size=0.5, dot_color='blue', rc_color='red', merge=True, title=None, dpi=150)</code>","text":"<p>Plot a single pairwise dotplot.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence (y-axis).</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence (x-axis).</p> required <code>output_path</code> <code>str or Path</code> <p>Output image file path. Default is <code>\"dotplot.png\"</code>.</p> <code>'dotplot.png'</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size as (width, height) in inches. Default is <code>(6, 6)</code>.</p> <code>(6.0, 6.0)</code> <code>dot_size</code> <code>float</code> <p>Marker/line size for each match. Default is <code>0.5</code>.</p> <code>0.5</code> <code>dot_color</code> <code>str</code> <p>Colour for forward-strand (<code>+</code>) matches. Default is <code>\"blue\"</code>.</p> <code>'blue'</code> <code>rc_color</code> <code>str</code> <p>Colour for reverse-complement (<code>-</code>) matches. Default is <code>\"red\"</code>.</p> <code>'red'</code> <code>merge</code> <code>bool</code> <p>Whether to merge sequential k-mer runs. Default is <code>True</code>.</p> <code>True</code> <code>title</code> <code>str</code> <p>Plot title. If <code>None</code>, a default title is used.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Output image resolution. Default is <code>150</code>.</p> <code>150</code> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot_single(\n    self,\n    query_name: str,\n    target_name: str,\n    output_path: Union[str, Path] = 'dotplot.png',\n    figsize: tuple[float, float] = (6.0, 6.0),\n    dot_size: float = 0.5,\n    dot_color: str = 'blue',\n    rc_color: str = 'red',\n    merge: bool = True,\n    title: Optional[str] = None,\n    dpi: int = 150,\n) -&gt; None:\n    \"\"\"Plot a single pairwise dotplot.\n\n    Parameters\n    ----------\n    query_name : str\n        Name of the query sequence (y-axis).\n    target_name : str\n        Name of the target sequence (x-axis).\n    output_path : str or Path, optional\n        Output image file path. Default is ``\"dotplot.png\"``.\n    figsize : tuple[float, float], optional\n        Figure size as (width, height) in inches. Default is ``(6, 6)``.\n    dot_size : float, optional\n        Marker/line size for each match. Default is ``0.5``.\n    dot_color : str, optional\n        Colour for forward-strand (``+``) matches. Default is ``\"blue\"``.\n    rc_color : str, optional\n        Colour for reverse-complement (``-``) matches. Default is ``\"red\"``.\n    merge : bool, optional\n        Whether to merge sequential k-mer runs. Default is ``True``.\n    title : str, optional\n        Plot title. If ``None``, a default title is used.\n    dpi : int, optional\n        Output image resolution. Default is ``150``.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n    self._plot_panel(\n        ax,\n        query_name,\n        target_name,\n        dot_size=dot_size,\n        dot_color=dot_color,\n        rc_color=rc_color,\n        merge=merge,\n    )\n    if title is None:\n        title = f'{query_name} vs {target_name}'\n    ax.set_title(title, fontsize=10)\n    plt.tight_layout()\n    plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n    plt.close(fig)\n</code></pre>"},{"location":"api/functions/","title":"Low-Level Functions","text":"<p>These functions are implemented in Rust and exposed via PyO3. They provide fine-grained access to the underlying FM-index and k-mer machinery. For most use cases, the <code>SequenceIndex</code> class is more convenient.</p>"},{"location":"api/functions/#fasta-io","title":"FASTA I/O","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_read_fasta","title":"<code>py_read_fasta(path)</code>  <code>builtin</code>","text":"<p>Python binding: read sequences from a FASTA or gzipped FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the FASTA or FASTA.gz file.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping sequence name to sequence string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be opened or parsed.</p>"},{"location":"api/functions/#k-mer-operations","title":"K-mer Operations","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_build_kmer_set","title":"<code>py_build_kmer_set(seq, k)</code>  <code>builtin</code>","text":"<p>Python binding: build the set of unique k-mers in a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>The DNA sequence string (uppercase recommended).</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of unique k-mer strings found in the sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If k is 0 or the sequence is empty.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_find_kmer_coords","title":"<code>py_find_kmer_coords(seq, kmers)</code>  <code>builtin</code>","text":"<p>Python binding: find all positions of each k-mer in a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>The DNA sequence to search in.</p> required <code>kmers</code> <code>list[str]</code> <p>List of k-mer strings to search for.</p> required <p>Returns:</p> Type Description <code>dict[str, list[int]]</code> <p>Dictionary mapping each k-mer to its list of start positions (0-based).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is invalid or k-mers are inconsistent.</p>"},{"location":"api/functions/#merging-k-mer-runs","title":"Merging K-mer Runs","text":"<p>rusty-dot provides four merge functions covering all k-mer alignment orientations. <code>py_merge_runs</code> is the recommended entry-point for new code; the strand-specific functions are available for lower-level control.</p>"},{"location":"api/functions/#unified-entry-point","title":"Unified entry-point","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_runs","title":"<code>py_merge_runs(kmer_coords, query_kmer_positions, k, strand)</code>","text":"<p>Merge k-mer hits into contiguous blocks for either strand orientation.</p> <p>A unified entry-point that dispatches to the forward or reverse-complement merge algorithm based on <code>strand</code>.</p> <p>For <code>strand=\"+\"</code> the forward (co-linear diagonal) algorithm is used: <code>kmer_coords</code> holds positions of each k-mer in the target and <code>query_kmer_positions</code> holds positions of the same k-mer in the query.</p> <p>For <code>strand=\"-\"</code> both the anti-diagonal algorithm (:func:<code>py_merge_rev_runs</code>) and the co-diagonal algorithm (:func:<code>py_merge_rev_fwd_runs</code>) are applied to <code>kmer_coords</code> (positions of the reverse complement of each k-mer in the target).  Results from both algorithms are combined and deduplicated, so every valid RC alignment \u2014 whether the RC target positions increase or decrease as the query advances \u2014 is reported exactly once.</p> <p>Parameters:</p> Name Type Description Default <code>kmer_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to 0-based target positions.  For <code>strand=\"-\"</code>, these are the positions of the RC of each k-mer in the target.</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to 0-based query positions.</p> required <code>k</code> <code>int</code> <p>The k-mer length, used to compute (exclusive) end coordinates.</p> required <code>strand</code> <code>str</code> <p>Orientation of the match: <code>\"+\"</code> for forward (co-linear diagonal) or <code>\"-\"</code> for reverse-complement (both anti-diagonal and co-diagonal patterns are merged and returned together, deduplicated).</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int, str]]</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> 5-tuples.  Coordinates are 0-based; end positions are exclusive. <code>strand</code> echoes the input argument.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>strand</code> is neither <code>\"+\"</code> nor <code>\"-\"</code>.</p>"},{"location":"api/functions/#forward-strand-merge","title":"Forward-strand merge","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_kmer_runs","title":"<code>py_merge_kmer_runs(kmer_coords, query_kmer_positions, k)</code>  <code>builtin</code>","text":"<p>Python binding: merge sequential k-mer coordinate runs (forward strand).</p> <p>Parameters:</p> Name Type Description Default <code>kmer_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to list of target start positions (0-based).</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to list of query start positions (0-based).</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of (query_start, query_end, target_start, target_end) tuples. Coordinates are 0-based, with end positions exclusive.</p>"},{"location":"api/functions/#reverse-complement-merges","title":"Reverse-complement merges","text":"<p>Two complementary algorithms cover all reverse-complement alignment patterns:</p> Pattern When to use <code>py_merge_rev_runs</code> RC target positions decrease as query advances (query +1, target \u22121 per step) \u2014 standard inverted-repeat alignment where the two arms face each other <code>py_merge_rev_fwd_runs</code> RC target positions increase as query advances (query +1, target +1 per step) \u2014 both repeat arms run in the same left-to-right direction <p><code>py_merge_runs(strand=\"-\")</code> calls both and deduplicates the results automatically.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_rev_runs","title":"<code>py_merge_rev_runs(target_rev_coords, query_kmer_positions, k)</code>","text":"<p>Merge reverse-complement k-mer hits into contiguous anti-diagonal blocks.</p> <p>For every <code>(query_pos, target_rev_pos)</code> pair derived from the two mappings, this function groups hits by anti-diagonal (<code>query_pos + target_rev_pos</code>) and, within each anti-diagonal, merges consecutive hits where <code>query_pos</code> increments by 1 and <code>target_rev_pos</code> decrements by 1.</p> <p>Parameters:</p> Name Type Description Default <code>target_rev_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer string to the 0-based start positions of its reverse complement in the target sequence (as returned by <code>find_rev_coords_in_index</code>).</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer string to list of 0-based start positions in the query sequence.</p> required <code>k</code> <code>int</code> <p>The k-mer length, used to compute the (exclusive) end coordinates of each merged block.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> tuples representing merged <code>-</code>-strand match regions.  Coordinates are 0-based; end positions are exclusive.  <code>target_start</code> and <code>target_end</code> are the forward-strand boundaries of the RC region on the target.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_rev_fwd_runs","title":"<code>py_merge_rev_fwd_runs(target_rev_coords, query_kmer_positions, k)</code>","text":"<p>Merge RC k-mer hits co-linear on a forward diagonal into contiguous blocks.</p> <p>Handles the case where sequential query k-mers have their reverse complements at increasing positions in the target \u2014 i.e., as the query position advances by 1, the forward-strand target position of the RC match also advances by 1 (<code>t_rc - q = constant</code>).  This is complementary to :func:<code>py_merge_rev_runs</code>, which handles the anti-diagonal case (<code>t_rc</code> decreases as <code>q</code> increases).</p> <p>This pattern arises in inverted-repeat contexts where both repeat arms run in the same left-to-right direction along the forward strand:</p> <ul> <li>:func:<code>py_merge_rev_runs</code> \u2014 anti-diagonal (<code>q + t_rc = const</code>):   standard inverted repeat / reverse-complement alignment.</li> <li>:func:<code>py_merge_rev_fwd_runs</code> \u2014 forward diagonal (<code>t_rc - q = const</code>):   inverted-repeat case where both arms advance in the same direction.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>target_rev_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to the 0-based start positions of its reverse complement in the target sequence (as returned by <code>find_rev_coords_in_index</code>).</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to its 0-based start positions in the query sequence.</p> required <code>k</code> <code>int</code> <p>The k-mer length, used to compute (exclusive) end coordinates.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> tuples representing merged <code>-</code>-strand match regions where RC target positions advance together with query positions.  Coordinates are 0-based with end positions exclusive.</p>"},{"location":"api/functions/#paf-formatting","title":"PAF Formatting","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_coords_to_paf","title":"<code>py_coords_to_paf(matches, query_name, query_len, target_name, target_len)</code>  <code>builtin</code>","text":"<p>Python binding: convert coordinate tuples to PAF format strings.</p> <p>Parameters:</p> Name Type Description Default <code>matches</code> <code>list[tuple[int, int, int, int]]</code> <p>List of (query_start, query_end, target_start, target_end) tuples.</p> required <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>query_len</code> <code>int</code> <p>Total length of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>target_len</code> <code>int</code> <p>Total length of the target sequence.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of PAF format lines (tab-separated).</p>"},{"location":"api/functions/#index-serialization","title":"Index Serialization","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_save_index","title":"<code>py_save_index(path, sequences, k)</code>  <code>builtin</code>","text":"<p>Python binding: save an index collection to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to save the serialized index.</p> required <code>sequences</code> <code>dict[str, str]</code> <p>Dictionary of sequence name to sequence string.</p> required <code>k</code> <code>int</code> <p>The k-mer length used to build the index.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_load_index","title":"<code>py_load_index(path)</code>  <code>builtin</code>","text":"<p>Python binding: load an index collection from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the serialized index file.</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, list[str]], int]</code> <p>A tuple of (kmer_sets_dict, k) where kmer_sets_dict maps sequence names to their k-mer lists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If deserialization fails.</p>"},{"location":"api/paf_io/","title":"PAF I/O","text":"<p>This module provides classes and helpers for reading, writing, and reordering PAF (Pairwise mApping Format) alignment records.</p>"},{"location":"api/paf_io/#crossidx-multi-group-cross-index","title":"CrossIdx \u2014 Multi-group cross-index","text":"<p><code>CrossIdx</code> (formerly <code>CrossIndexPaf</code>) manages sequences divided into named groups and computes cross-group pairwise comparisons.  It is compatible with :class:<code>~rusty_dot.dotplot.DotPlotter</code>.</p>"},{"location":"api/paf_io/#alignment-scope-by-number-of-groups","title":"Alignment scope by number of groups","text":"<ul> <li>2 groups \u2014 alignments between the two groups only.</li> <li>3+ groups \u2014 all non-self ordered pairs of groups.   Use the <code>group_pairs</code> argument of <code>get_paf</code> to restrict to specific pairs.</li> </ul>"},{"location":"api/paf_io/#dotplotter-usage","title":"DotPlotter usage","text":"<pre><code>from rusty_dot.paf_io import CrossIdx\nfrom rusty_dot.dotplot import DotPlotter\n\ncross = CrossIdx(k=15)\ncross.load_fasta(\"assembly_a.fasta\", group=\"a\")\ncross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\nplotter = DotPlotter(cross)\nplotter.plot(\n    query_names=cross.sequence_names(group=\"a\"),\n    target_names=cross.sequence_names(group=\"b\"),\n    output_path=\"cross_plot.png\",\n)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx","title":"<code>CrossIdx</code>","text":"<p>Multi-group sequence index for cross-group pairwise comparisons.</p> <p>Sequences are organised into named groups (e.g. <code>'assembly_a'</code>, <code>'assembly_b'</code>).  Each sequence is stored in a shared :class:<code>~rusty_dot.SequenceIndex</code> under a <code>group:name</code> internal key, which keeps names unique even when the same sequence identifier appears in multiple groups.</p> <p>Alignment scope by number of groups</p> <ul> <li>2 groups \u2014 alignments are computed between the two groups only.</li> <li>3+ groups \u2014 alignments are computed for every non-self ordered pair   of groups.  Use the group_pairs argument of :meth:<code>get_paf</code> to   restrict to specific pairs.</li> </ul> <p>DotPlotter compatibility</p> <p><code>CrossIdx</code> exposes :meth:<code>get_sequence_length</code>, :meth:<code>compare_sequences_stranded</code>, and :meth:<code>sequence_names</code> so that it can be passed directly to :class:<code>~rusty_dot.dotplot.DotPlotter</code>::</p> <pre><code>cross = CrossIdx(k=15)\ncross.load_fasta(\"assembly_a.fasta\", group=\"a\")\ncross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\nfrom rusty_dot.dotplot import DotPlotter\nplotter = DotPlotter(cross)\nplotter.plot(\n    query_names=cross.sequence_names(group=\"a\"),\n    target_names=cross.sequence_names(group=\"b\"),\n    output_path=\"cross_plot.png\",\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>K-mer length to use for indexing and comparison.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rusty_dot.paf_io import CrossIdx\n&gt;&gt;&gt; cross = CrossIdx(k=10)\n&gt;&gt;&gt; cross.load_fasta(\"genome_a.fasta\", group=\"a\")\n&gt;&gt;&gt; cross.load_fasta(\"genome_b.fasta\", group=\"b\")\n&gt;&gt;&gt; paf_lines = cross.get_paf()\n</code></pre> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>class CrossIdx:\n    \"\"\"Multi-group sequence index for cross-group pairwise comparisons.\n\n    Sequences are organised into named groups (e.g. ``'assembly_a'``,\n    ``'assembly_b'``).  Each sequence is stored in a shared\n    :class:`~rusty_dot.SequenceIndex` under a ``group:name`` internal key,\n    which keeps names unique even when the same sequence identifier appears\n    in multiple groups.\n\n    **Alignment scope by number of groups**\n\n    * **2 groups** \u2014 alignments are computed between the two groups only.\n    * **3+ groups** \u2014 alignments are computed for every non-self ordered pair\n      of groups.  Use the *group_pairs* argument of :meth:`get_paf` to\n      restrict to specific pairs.\n\n    **DotPlotter compatibility**\n\n    ``CrossIdx`` exposes :meth:`get_sequence_length`,\n    :meth:`compare_sequences_stranded`, and :meth:`sequence_names` so that it\n    can be passed directly to :class:`~rusty_dot.dotplot.DotPlotter`::\n\n        cross = CrossIdx(k=15)\n        cross.load_fasta(\"assembly_a.fasta\", group=\"a\")\n        cross.load_fasta(\"assembly_b.fasta\", group=\"b\")\n\n        from rusty_dot.dotplot import DotPlotter\n        plotter = DotPlotter(cross)\n        plotter.plot(\n            query_names=cross.sequence_names(group=\"a\"),\n            target_names=cross.sequence_names(group=\"b\"),\n            output_path=\"cross_plot.png\",\n        )\n\n    Parameters\n    ----------\n    k : int\n        K-mer length to use for indexing and comparison.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from rusty_dot.paf_io import CrossIdx\n    &gt;&gt;&gt; cross = CrossIdx(k=10)\n    &gt;&gt;&gt; cross.load_fasta(\"genome_a.fasta\", group=\"a\")\n    &gt;&gt;&gt; cross.load_fasta(\"genome_b.fasta\", group=\"b\")\n    &gt;&gt;&gt; paf_lines = cross.get_paf()\n    \"\"\"\n\n    def __init__(self, k: int) -&gt; None:\n        \"\"\"Initialise an empty CrossIdx.\n\n        Parameters\n        ----------\n        k : int\n            K-mer length to use when building the sequence index.\n        \"\"\"\n        self._k: int = k\n        self._index: SequenceIndex = SequenceIndex(k=k)\n        # group_label -&gt; ordered list of original (un-prefixed) sequence names\n        self._groups: dict[str, list[str]] = {}\n        # Cached PAF records from the last :meth:`run_merge` call\n        self._paf_records: list[PafRecord] = []\n\n    # ------------------------------------------------------------------\n    # Internal helpers\n    # ------------------------------------------------------------------\n\n    @staticmethod\n    def _make_internal(group: str, name: str) -&gt; str:\n        \"\"\"Format an internal (prefixed) name for use in SequenceIndex.\"\"\"\n        return f'{group}:{name}'\n\n    @staticmethod\n    def _split_internal(internal: str) -&gt; tuple[str, str]:\n        \"\"\"Split ``'group:name'`` into ``(group, name)``.\"\"\"\n        group, _, name = internal.partition(':')\n        return group, name\n\n    # ------------------------------------------------------------------\n    # Adding sequences\n    # ------------------------------------------------------------------\n\n    def add_sequence(self, name: str, seq: str, group: str = 'a') -&gt; None:\n        \"\"\"Add a single sequence to the specified group.\n\n        Parameters\n        ----------\n        name : str\n            Sequence identifier (must be unique within the group).\n        seq : str\n            DNA sequence string.\n        group : str, optional\n            Group label.  Any non-empty string is accepted; ``':'`` is\n            forbidden because it is used as an internal separator.\n            Default is ``'a'``.\n\n        Raises\n        ------\n        ValueError\n            If *group* contains ``':'``.\n        \"\"\"\n        if ':' in group:\n            raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n        internal = self._make_internal(group, name)\n        self._index.add_sequence(internal, seq)\n        if group not in self._groups:\n            self._groups[group] = []\n        self._groups[group].append(name)\n\n    def load_fasta(self, path: str, group: str = 'a') -&gt; list[str]:\n        \"\"\"Load sequences from a FASTA file into the specified group.\n\n        Parameters\n        ----------\n        path : str\n            Path to a FASTA (``.fa`` / ``.fasta``) or gzipped FASTA file.\n        group : str, optional\n            Group label.  Default is ``'a'``.\n\n        Returns\n        -------\n        list[str]\n            The original (un-prefixed) sequence names that were loaded, in\n            file order.\n\n        Raises\n        ------\n        ValueError\n            If *group* contains ``':'``, or if the file cannot be parsed, or\n            if the FASTA file contains duplicate sequence names.\n        \"\"\"\n        if ':' in group:\n            raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n        from rusty_dot._rusty_dot import py_read_fasta\n\n        seqs = py_read_fasta(path)\n        if group not in self._groups:\n            self._groups[group] = []\n        names: list[str] = []\n        for name, seq in seqs.items():\n            internal = self._make_internal(group, name)\n            self._index.add_sequence(internal, seq)\n            self._groups[group].append(name)\n            names.append(name)\n        return names\n\n    # ------------------------------------------------------------------\n    # Properties and name helpers\n    # ------------------------------------------------------------------\n\n    @property\n    def group_names(self) -&gt; list[str]:\n        \"\"\"Return the list of group labels in insertion order.\n\n        Returns\n        -------\n        list[str]\n            Group labels.\n        \"\"\"\n        return list(self._groups.keys())\n\n    def sequence_names(self, group: str | None = None) -&gt; list[str]:\n        \"\"\"Return internal (``group:name``) identifiers suitable for DotPlotter.\n\n        Parameters\n        ----------\n        group : str or None, optional\n            If given, return only names from that group.  If ``None``\n            (default), return names from all groups.\n\n        Returns\n        -------\n        list[str]\n            Internal ``group:name`` strings in current :attr:`contig_order`.\n        \"\"\"\n        if group is not None:\n            return [self._make_internal(group, n) for n in self._groups.get(group, [])]\n        result: list[str] = []\n        for g, names in self._groups.items():\n            result.extend(self._make_internal(g, n) for n in names)\n        return result\n\n    @property\n    def contig_order(self) -&gt; dict[str, list[str]]:\n        \"\"\"Current contig order per group as original (un-prefixed) names.\n\n        Returns\n        -------\n        dict[str, list[str]]\n            Mapping of group label \u2192 ordered list of sequence names.\n            Updated in-place by :meth:`reorder_by_length` and\n            :meth:`reorder_for_colinearity`.\n        \"\"\"\n        return {g: list(names) for g, names in self._groups.items()}\n\n    # ------------------------------------------------------------------\n    # Backward-compatible properties (two-group a/b model)\n    # ------------------------------------------------------------------\n\n    @property\n    def query_names(self) -&gt; list[str]:\n        \"\"\"Un-prefixed names for group ``'a'`` (backward compatible).\n\n        Returns\n        -------\n        list[str]\n        \"\"\"\n        return list(self._groups.get('a', []))\n\n    @property\n    def target_names(self) -&gt; list[str]:\n        \"\"\"Un-prefixed names for group ``'b'`` (backward compatible).\n\n        Returns\n        -------\n        list[str]\n        \"\"\"\n        return list(self._groups.get('b', []))\n\n    # ------------------------------------------------------------------\n    # DotPlotter-compatible interface\n    # ------------------------------------------------------------------\n\n    def get_sequence_length(self, name: str) -&gt; int:\n        \"\"\"Return the length of the sequence identified by its internal name.\n\n        Parameters\n        ----------\n        name : str\n            Internal (``group:name``) identifier.\n\n        Returns\n        -------\n        int\n            Sequence length in bases.\n        \"\"\"\n        return self._index.get_sequence_length(name)\n\n    def compare_sequences_stranded(\n        self, name1: str, name2: str, merge: bool = True\n    ) -&gt; list:\n        \"\"\"Compare two sequences by their internal names, returning stranded matches.\n\n        Parameters\n        ----------\n        name1 : str\n            Internal name of the query sequence.\n        name2 : str\n            Internal name of the target sequence.\n        merge : bool, optional\n            Whether to merge consecutive co-linear k-mer runs.\n            Default is ``True``.\n\n        Returns\n        -------\n        list of (int, int, int, int, str)\n            List of ``(query_start, query_end, target_start, target_end, strand)``\n            tuples.\n        \"\"\"\n        return self._index.compare_sequences_stranded(name1, name2, merge)\n\n    # ------------------------------------------------------------------\n    # Contig reordering\n    # ------------------------------------------------------------------\n\n    def reorder_by_length(self, group: str | None = None) -&gt; None:\n        \"\"\"Reorder contigs within one or all groups by descending sequence length.\n\n        Updates :attr:`contig_order` in-place.\n\n        Parameters\n        ----------\n        group : str or None, optional\n            Group to reorder.  If ``None`` (default), all groups are reordered.\n        \"\"\"\n        groups_to_sort = [group] if group is not None else list(self._groups.keys())\n        for g in groups_to_sort:\n            self._groups[g].sort(\n                key=lambda n: self._index.get_sequence_length(\n                    self._make_internal(g, n)\n                ),\n                reverse=True,\n            )\n\n    def reorder_for_colinearity(self, query_group: str, target_group: str) -&gt; None:\n        \"\"\"Reorder sequences in two groups to maximise dotplot collinearity.\n\n        Uses the gravity-centre algorithm via\n        :meth:`~rusty_dot.SequenceIndex.optimal_contig_order`.  Updates\n        :attr:`contig_order` in-place for both groups.\n\n        Parameters\n        ----------\n        query_group : str\n            Group label for the query (y-axis / rows).\n        target_group : str\n            Group label for the target (x-axis / columns).\n\n        Raises\n        ------\n        KeyError\n            If either group label is not present in the index.\n        \"\"\"\n        q_internal = [\n            self._make_internal(query_group, n) for n in self._groups[query_group]\n        ]\n        t_internal = [\n            self._make_internal(target_group, n) for n in self._groups[target_group]\n        ]\n        sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n            q_internal, t_internal\n        )\n        self._groups[query_group] = [self._split_internal(n)[1] for n in sorted_q_int]\n        self._groups[target_group] = [self._split_internal(n)[1] for n in sorted_t_int]\n\n    # ------------------------------------------------------------------\n    # PAF output\n    # ------------------------------------------------------------------\n\n    def _get_default_group_pairs(self) -&gt; list[tuple[str, str]]:\n        \"\"\"Return default group pairs for alignment.\n\n        * 2 groups \u2192 one pair between the two groups.\n        * 3+ groups \u2192 all non-self ordered pairs.\n        \"\"\"\n        groups = list(self._groups.keys())\n        if len(groups) == 2:\n            return [(groups[0], groups[1])]\n        return [\n            (a, b) for i, a in enumerate(groups) for j, b in enumerate(groups) if i != j\n        ]\n\n    def get_paf(\n        self,\n        group_pairs: list[tuple[str, str]] | None = None,\n        merge: bool = True,\n    ) -&gt; list[str]:\n        \"\"\"Return PAF lines for cross-group sequence comparisons.\n\n        Parameters\n        ----------\n        group_pairs : list of (str, str) or None, optional\n            Explicit list of ``(query_group, target_group)`` pairs to compare.\n            If ``None`` (default):\n\n            * 2 groups \u2192 the single cross-group pair.\n            * 3+ groups \u2192 all non-self ordered pairs.\n        merge : bool, optional\n            Whether to merge consecutive co-linear k-mer runs before\n            generating PAF lines.  Default is ``True``.\n\n        Returns\n        -------\n        list[str]\n            PAF-formatted lines (12 tab-separated columns each).\n        \"\"\"\n        if group_pairs is None:\n            group_pairs = self._get_default_group_pairs()\n\n        paf_lines: list[str] = []\n        for query_group, target_group in group_pairs:\n            _log.info(\n                'CrossIdx: computing %d x %d pairwise alignments '\n                'between group %r (%d sequences) and group %r (%d sequences)',\n                len(self._groups.get(query_group, [])),\n                len(self._groups.get(target_group, [])),\n                query_group,\n                len(self._groups.get(query_group, [])),\n                target_group,\n                len(self._groups.get(target_group, [])),\n            )\n            for q_orig in self._groups.get(query_group, []):\n                for t_orig in self._groups.get(target_group, []):\n                    q_int = self._make_internal(query_group, q_orig)\n                    t_int = self._make_internal(target_group, t_orig)\n                    lines = self._index.get_paf(q_int, t_int, merge)\n                    for line in lines:\n                        fields = line.split('\\t')\n                        fields[0] = q_orig\n                        fields[5] = t_orig\n                        paf_lines.append('\\t'.join(fields))\n        return paf_lines\n\n    def run_merge(\n        self,\n        group_pairs: list[tuple[str, str]] | None = None,\n    ) -&gt; None:\n        \"\"\"Compute merged alignments and store the result as :attr:`_paf_records`.\n\n        Runs :meth:`get_paf` with ``merge=True`` and populates\n        ``self._paf_records`` so that the results can be inspected or passed\n        to a :class:`PafAlignment`.\n\n        Parameters\n        ----------\n        group_pairs : list of (str, str) or None, optional\n            Group pairs to compare (same semantics as :meth:`get_paf`).\n            Defaults to all cross-group pairs.\n        \"\"\"\n        paf_lines = self.get_paf(group_pairs=group_pairs, merge=True)\n        self._paf_records = [PafRecord.from_line(line) for line in paf_lines]\n\n    # ------------------------------------------------------------------\n    # Backward-compatible API (two-group a/b model)\n    # ------------------------------------------------------------------\n\n    def get_paf_all(self, merge: bool = True) -&gt; list[str]:\n        \"\"\"Return PAF lines for all cross-group comparisons.\n\n        Backward-compatible wrapper around :meth:`get_paf`.  When a group\n        ``'b'`` is present, computes ``a`` vs ``b`` alignments; otherwise\n        performs all-vs-all within group ``'a'``.\n\n        Parameters\n        ----------\n        merge : bool, optional\n            Whether to merge consecutive co-linear k-mer runs.\n            Default is ``True``.\n\n        Returns\n        -------\n        list[str]\n            PAF-formatted lines.\n        \"\"\"\n        if 'b' in self._groups and self._groups['b']:\n            return self.get_paf(group_pairs=[('a', 'b')], merge=merge)\n        # Single group or no group 'b': all-vs-all within group 'a'\n        names_a = self._groups.get('a', [])\n        _log.info(\n            'CrossIdx: computing all-vs-all pairwise alignments '\n            'within group a (%d sequences)',\n            len(names_a),\n        )\n        paf_lines: list[str] = []\n        for i, q_orig in enumerate(names_a):\n            for j, t_orig in enumerate(names_a):\n                if i == j:\n                    continue\n                q_int = self._make_internal('a', q_orig)\n                t_int = self._make_internal('a', t_orig)\n                lines = self._index.get_paf(q_int, t_int, merge)\n                for line in lines:\n                    fields = line.split('\\t')\n                    fields[0] = q_orig\n                    fields[5] = t_orig\n                    paf_lines.append('\\t'.join(fields))\n        return paf_lines\n\n    def reorder_contigs(\n        self,\n        query_names: list[str] | None = None,\n        target_names: list[str] | None = None,\n    ) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Sort contigs for maximum collinearity (backward-compatible, requires groups a and b).\n\n        Parameters\n        ----------\n        query_names : list[str] or None, optional\n            Original (un-prefixed) names for group ``'a'`` to reorder.\n            Defaults to all group-a sequences.\n        target_names : list[str] or None, optional\n            Original (un-prefixed) names for group ``'b'`` to reorder.\n            Defaults to all group-b sequences.\n\n        Returns\n        -------\n        tuple[list[str], list[str]]\n            ``(sorted_query_names, sorted_target_names)`` \u2014 both using original\n            un-prefixed names.\n\n        Raises\n        ------\n        ValueError\n            If group ``'b'`` is empty.  Use :meth:`reorder_for_colinearity` for\n            explicit group names.\n        \"\"\"\n        if 'b' not in self._groups or not self._groups['b']:\n            raise ValueError(\n                \"reorder_contigs requires group 'b' sequences; \"\n                'use reorder_for_colinearity for explicit group names.'\n            )\n        q_names = (\n            query_names if query_names is not None else list(self._groups.get('a', []))\n        )\n        t_names = (\n            target_names\n            if target_names is not None\n            else list(self._groups.get('b', []))\n        )\n        q_internal = [self._make_internal('a', n) for n in q_names]\n        t_internal = [self._make_internal('b', n) for n in t_names]\n        sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n            q_internal, t_internal\n        )\n        sorted_q = [self._split_internal(n)[1] for n in sorted_q_int]\n        sorted_t = [self._split_internal(n)[1] for n in sorted_t_int]\n        return sorted_q, sorted_t\n\n    # ------------------------------------------------------------------\n    # Dunder methods\n    # ------------------------------------------------------------------\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise machine-readable representation.\n\n        Returns\n        -------\n        str\n            ``CrossIdx(k=&lt;k&gt;, groups={&lt;label&gt;=&lt;n&gt;, ...})``.\n        \"\"\"\n        group_info = ', '.join(f'{g}={len(names)}' for g, names in self._groups.items())\n        return f'CrossIdx(k={self._k}, groups={{{group_info}}})'\n\n    def __str__(self) -&gt; str:\n        \"\"\"Return a human-readable stats summary.\n\n        Returns\n        -------\n        str\n            Multi-line summary of groups, sequence counts, and cached PAF\n            record count.\n        \"\"\"\n        n_total = sum(len(v) for v in self._groups.values())\n        lines = [f'CrossIdx (k={self._k})']\n        lines.append(f'  Total sequences : {n_total}')\n        for g, names in self._groups.items():\n            lines.append(f'  Group {g!r:12s}: {len(names):&gt;6d} sequences')\n        lines.append(f'  PAF records     : {len(self._paf_records)}')\n        return '\\n'.join(lines)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.group_names","title":"<code>group_names</code>  <code>property</code>","text":"<p>Return the list of group labels in insertion order.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Group labels.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.contig_order","title":"<code>contig_order</code>  <code>property</code>","text":"<p>Current contig order per group as original (un-prefixed) names.</p> <p>Returns:</p> Type Description <code>dict[str, list[str]]</code> <p>Mapping of group label \u2192 ordered list of sequence names. Updated in-place by :meth:<code>reorder_by_length</code> and :meth:<code>reorder_for_colinearity</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.query_names","title":"<code>query_names</code>  <code>property</code>","text":"<p>Un-prefixed names for group <code>'a'</code> (backward compatible).</p> <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.target_names","title":"<code>target_names</code>  <code>property</code>","text":"<p>Un-prefixed names for group <code>'b'</code> (backward compatible).</p> <p>Returns:</p> Type Description <code>list[str]</code>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.__init__","title":"<code>__init__(k)</code>","text":"<p>Initialise an empty CrossIdx.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>K-mer length to use when building the sequence index.</p> required Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __init__(self, k: int) -&gt; None:\n    \"\"\"Initialise an empty CrossIdx.\n\n    Parameters\n    ----------\n    k : int\n        K-mer length to use when building the sequence index.\n    \"\"\"\n    self._k: int = k\n    self._index: SequenceIndex = SequenceIndex(k=k)\n    # group_label -&gt; ordered list of original (un-prefixed) sequence names\n    self._groups: dict[str, list[str]] = {}\n    # Cached PAF records from the last :meth:`run_merge` call\n    self._paf_records: list[PafRecord] = []\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.add_sequence","title":"<code>add_sequence(name, seq, group='a')</code>","text":"<p>Add a single sequence to the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Sequence identifier (must be unique within the group).</p> required <code>seq</code> <code>str</code> <p>DNA sequence string.</p> required <code>group</code> <code>str</code> <p>Group label.  Any non-empty string is accepted; <code>':'</code> is forbidden because it is used as an internal separator. Default is <code>'a'</code>.</p> <code>'a'</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If group contains <code>':'</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def add_sequence(self, name: str, seq: str, group: str = 'a') -&gt; None:\n    \"\"\"Add a single sequence to the specified group.\n\n    Parameters\n    ----------\n    name : str\n        Sequence identifier (must be unique within the group).\n    seq : str\n        DNA sequence string.\n    group : str, optional\n        Group label.  Any non-empty string is accepted; ``':'`` is\n        forbidden because it is used as an internal separator.\n        Default is ``'a'``.\n\n    Raises\n    ------\n    ValueError\n        If *group* contains ``':'``.\n    \"\"\"\n    if ':' in group:\n        raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n    internal = self._make_internal(group, name)\n    self._index.add_sequence(internal, seq)\n    if group not in self._groups:\n        self._groups[group] = []\n    self._groups[group].append(name)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.load_fasta","title":"<code>load_fasta(path, group='a')</code>","text":"<p>Load sequences from a FASTA file into the specified group.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a FASTA (<code>.fa</code> / <code>.fasta</code>) or gzipped FASTA file.</p> required <code>group</code> <code>str</code> <p>Group label.  Default is <code>'a'</code>.</p> <code>'a'</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>The original (un-prefixed) sequence names that were loaded, in file order.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If group contains <code>':'</code>, or if the file cannot be parsed, or if the FASTA file contains duplicate sequence names.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def load_fasta(self, path: str, group: str = 'a') -&gt; list[str]:\n    \"\"\"Load sequences from a FASTA file into the specified group.\n\n    Parameters\n    ----------\n    path : str\n        Path to a FASTA (``.fa`` / ``.fasta``) or gzipped FASTA file.\n    group : str, optional\n        Group label.  Default is ``'a'``.\n\n    Returns\n    -------\n    list[str]\n        The original (un-prefixed) sequence names that were loaded, in\n        file order.\n\n    Raises\n    ------\n    ValueError\n        If *group* contains ``':'``, or if the file cannot be parsed, or\n        if the FASTA file contains duplicate sequence names.\n    \"\"\"\n    if ':' in group:\n        raise ValueError(f\"Group name must not contain ':', got {group!r}\")\n    from rusty_dot._rusty_dot import py_read_fasta\n\n    seqs = py_read_fasta(path)\n    if group not in self._groups:\n        self._groups[group] = []\n    names: list[str] = []\n    for name, seq in seqs.items():\n        internal = self._make_internal(group, name)\n        self._index.add_sequence(internal, seq)\n        self._groups[group].append(name)\n        names.append(name)\n    return names\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.sequence_names","title":"<code>sequence_names(group=None)</code>","text":"<p>Return internal (<code>group:name</code>) identifiers suitable for DotPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str or None</code> <p>If given, return only names from that group.  If <code>None</code> (default), return names from all groups.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Internal <code>group:name</code> strings in current :attr:<code>contig_order</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def sequence_names(self, group: str | None = None) -&gt; list[str]:\n    \"\"\"Return internal (``group:name``) identifiers suitable for DotPlotter.\n\n    Parameters\n    ----------\n    group : str or None, optional\n        If given, return only names from that group.  If ``None``\n        (default), return names from all groups.\n\n    Returns\n    -------\n    list[str]\n        Internal ``group:name`` strings in current :attr:`contig_order`.\n    \"\"\"\n    if group is not None:\n        return [self._make_internal(group, n) for n in self._groups.get(group, [])]\n    result: list[str] = []\n    for g, names in self._groups.items():\n        result.extend(self._make_internal(g, n) for n in names)\n    return result\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.get_sequence_length","title":"<code>get_sequence_length(name)</code>","text":"<p>Return the length of the sequence identified by its internal name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Internal (<code>group:name</code>) identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Sequence length in bases.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_sequence_length(self, name: str) -&gt; int:\n    \"\"\"Return the length of the sequence identified by its internal name.\n\n    Parameters\n    ----------\n    name : str\n        Internal (``group:name``) identifier.\n\n    Returns\n    -------\n    int\n        Sequence length in bases.\n    \"\"\"\n    return self._index.get_sequence_length(name)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.compare_sequences_stranded","title":"<code>compare_sequences_stranded(name1, name2, merge=True)</code>","text":"<p>Compare two sequences by their internal names, returning stranded matches.</p> <p>Parameters:</p> Name Type Description Default <code>name1</code> <code>str</code> <p>Internal name of the query sequence.</p> required <code>name2</code> <code>str</code> <p>Internal name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list of (int, int, int, int, str)</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> tuples.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def compare_sequences_stranded(\n    self, name1: str, name2: str, merge: bool = True\n) -&gt; list:\n    \"\"\"Compare two sequences by their internal names, returning stranded matches.\n\n    Parameters\n    ----------\n    name1 : str\n        Internal name of the query sequence.\n    name2 : str\n        Internal name of the target sequence.\n    merge : bool, optional\n        Whether to merge consecutive co-linear k-mer runs.\n        Default is ``True``.\n\n    Returns\n    -------\n    list of (int, int, int, int, str)\n        List of ``(query_start, query_end, target_start, target_end, strand)``\n        tuples.\n    \"\"\"\n    return self._index.compare_sequences_stranded(name1, name2, merge)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.reorder_by_length","title":"<code>reorder_by_length(group=None)</code>","text":"<p>Reorder contigs within one or all groups by descending sequence length.</p> <p>Updates :attr:<code>contig_order</code> in-place.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str or None</code> <p>Group to reorder.  If <code>None</code> (default), all groups are reordered.</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_by_length(self, group: str | None = None) -&gt; None:\n    \"\"\"Reorder contigs within one or all groups by descending sequence length.\n\n    Updates :attr:`contig_order` in-place.\n\n    Parameters\n    ----------\n    group : str or None, optional\n        Group to reorder.  If ``None`` (default), all groups are reordered.\n    \"\"\"\n    groups_to_sort = [group] if group is not None else list(self._groups.keys())\n    for g in groups_to_sort:\n        self._groups[g].sort(\n            key=lambda n: self._index.get_sequence_length(\n                self._make_internal(g, n)\n            ),\n            reverse=True,\n        )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.reorder_for_colinearity","title":"<code>reorder_for_colinearity(query_group, target_group)</code>","text":"<p>Reorder sequences in two groups to maximise dotplot collinearity.</p> <p>Uses the gravity-centre algorithm via :meth:<code>~rusty_dot.SequenceIndex.optimal_contig_order</code>.  Updates :attr:<code>contig_order</code> in-place for both groups.</p> <p>Parameters:</p> Name Type Description Default <code>query_group</code> <code>str</code> <p>Group label for the query (y-axis / rows).</p> required <code>target_group</code> <code>str</code> <p>Group label for the target (x-axis / columns).</p> required <p>Raises:</p> Type Description <code>KeyError</code> <p>If either group label is not present in the index.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_for_colinearity(self, query_group: str, target_group: str) -&gt; None:\n    \"\"\"Reorder sequences in two groups to maximise dotplot collinearity.\n\n    Uses the gravity-centre algorithm via\n    :meth:`~rusty_dot.SequenceIndex.optimal_contig_order`.  Updates\n    :attr:`contig_order` in-place for both groups.\n\n    Parameters\n    ----------\n    query_group : str\n        Group label for the query (y-axis / rows).\n    target_group : str\n        Group label for the target (x-axis / columns).\n\n    Raises\n    ------\n    KeyError\n        If either group label is not present in the index.\n    \"\"\"\n    q_internal = [\n        self._make_internal(query_group, n) for n in self._groups[query_group]\n    ]\n    t_internal = [\n        self._make_internal(target_group, n) for n in self._groups[target_group]\n    ]\n    sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n        q_internal, t_internal\n    )\n    self._groups[query_group] = [self._split_internal(n)[1] for n in sorted_q_int]\n    self._groups[target_group] = [self._split_internal(n)[1] for n in sorted_t_int]\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.get_paf","title":"<code>get_paf(group_pairs=None, merge=True)</code>","text":"<p>Return PAF lines for cross-group sequence comparisons.</p> <p>Parameters:</p> Name Type Description Default <code>group_pairs</code> <code>list of (str, str) or None</code> <p>Explicit list of <code>(query_group, target_group)</code> pairs to compare. If <code>None</code> (default):</p> <ul> <li>2 groups \u2192 the single cross-group pair.</li> <li>3+ groups \u2192 all non-self ordered pairs.</li> </ul> <code>None</code> <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF-formatted lines (12 tab-separated columns each).</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_paf(\n    self,\n    group_pairs: list[tuple[str, str]] | None = None,\n    merge: bool = True,\n) -&gt; list[str]:\n    \"\"\"Return PAF lines for cross-group sequence comparisons.\n\n    Parameters\n    ----------\n    group_pairs : list of (str, str) or None, optional\n        Explicit list of ``(query_group, target_group)`` pairs to compare.\n        If ``None`` (default):\n\n        * 2 groups \u2192 the single cross-group pair.\n        * 3+ groups \u2192 all non-self ordered pairs.\n    merge : bool, optional\n        Whether to merge consecutive co-linear k-mer runs before\n        generating PAF lines.  Default is ``True``.\n\n    Returns\n    -------\n    list[str]\n        PAF-formatted lines (12 tab-separated columns each).\n    \"\"\"\n    if group_pairs is None:\n        group_pairs = self._get_default_group_pairs()\n\n    paf_lines: list[str] = []\n    for query_group, target_group in group_pairs:\n        _log.info(\n            'CrossIdx: computing %d x %d pairwise alignments '\n            'between group %r (%d sequences) and group %r (%d sequences)',\n            len(self._groups.get(query_group, [])),\n            len(self._groups.get(target_group, [])),\n            query_group,\n            len(self._groups.get(query_group, [])),\n            target_group,\n            len(self._groups.get(target_group, [])),\n        )\n        for q_orig in self._groups.get(query_group, []):\n            for t_orig in self._groups.get(target_group, []):\n                q_int = self._make_internal(query_group, q_orig)\n                t_int = self._make_internal(target_group, t_orig)\n                lines = self._index.get_paf(q_int, t_int, merge)\n                for line in lines:\n                    fields = line.split('\\t')\n                    fields[0] = q_orig\n                    fields[5] = t_orig\n                    paf_lines.append('\\t'.join(fields))\n    return paf_lines\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.run_merge","title":"<code>run_merge(group_pairs=None)</code>","text":"<p>Compute merged alignments and store the result as :attr:<code>_paf_records</code>.</p> <p>Runs :meth:<code>get_paf</code> with <code>merge=True</code> and populates <code>self._paf_records</code> so that the results can be inspected or passed to a :class:<code>PafAlignment</code>.</p> <p>Parameters:</p> Name Type Description Default <code>group_pairs</code> <code>list of (str, str) or None</code> <p>Group pairs to compare (same semantics as :meth:<code>get_paf</code>). Defaults to all cross-group pairs.</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def run_merge(\n    self,\n    group_pairs: list[tuple[str, str]] | None = None,\n) -&gt; None:\n    \"\"\"Compute merged alignments and store the result as :attr:`_paf_records`.\n\n    Runs :meth:`get_paf` with ``merge=True`` and populates\n    ``self._paf_records`` so that the results can be inspected or passed\n    to a :class:`PafAlignment`.\n\n    Parameters\n    ----------\n    group_pairs : list of (str, str) or None, optional\n        Group pairs to compare (same semantics as :meth:`get_paf`).\n        Defaults to all cross-group pairs.\n    \"\"\"\n    paf_lines = self.get_paf(group_pairs=group_pairs, merge=True)\n    self._paf_records = [PafRecord.from_line(line) for line in paf_lines]\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.get_paf_all","title":"<code>get_paf_all(merge=True)</code>","text":"<p>Return PAF lines for all cross-group comparisons.</p> <p>Backward-compatible wrapper around :meth:<code>get_paf</code>.  When a group <code>'b'</code> is present, computes <code>a</code> vs <code>b</code> alignments; otherwise performs all-vs-all within group <code>'a'</code>.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF-formatted lines.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def get_paf_all(self, merge: bool = True) -&gt; list[str]:\n    \"\"\"Return PAF lines for all cross-group comparisons.\n\n    Backward-compatible wrapper around :meth:`get_paf`.  When a group\n    ``'b'`` is present, computes ``a`` vs ``b`` alignments; otherwise\n    performs all-vs-all within group ``'a'``.\n\n    Parameters\n    ----------\n    merge : bool, optional\n        Whether to merge consecutive co-linear k-mer runs.\n        Default is ``True``.\n\n    Returns\n    -------\n    list[str]\n        PAF-formatted lines.\n    \"\"\"\n    if 'b' in self._groups and self._groups['b']:\n        return self.get_paf(group_pairs=[('a', 'b')], merge=merge)\n    # Single group or no group 'b': all-vs-all within group 'a'\n    names_a = self._groups.get('a', [])\n    _log.info(\n        'CrossIdx: computing all-vs-all pairwise alignments '\n        'within group a (%d sequences)',\n        len(names_a),\n    )\n    paf_lines: list[str] = []\n    for i, q_orig in enumerate(names_a):\n        for j, t_orig in enumerate(names_a):\n            if i == j:\n                continue\n            q_int = self._make_internal('a', q_orig)\n            t_int = self._make_internal('a', t_orig)\n            lines = self._index.get_paf(q_int, t_int, merge)\n            for line in lines:\n                fields = line.split('\\t')\n                fields[0] = q_orig\n                fields[5] = t_orig\n                paf_lines.append('\\t'.join(fields))\n    return paf_lines\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.reorder_contigs","title":"<code>reorder_contigs(query_names=None, target_names=None)</code>","text":"<p>Sort contigs for maximum collinearity (backward-compatible, requires groups a and b).</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str] or None</code> <p>Original (un-prefixed) names for group <code>'a'</code> to reorder. Defaults to all group-a sequences.</p> <code>None</code> <code>target_names</code> <code>list[str] or None</code> <p>Original (un-prefixed) names for group <code>'b'</code> to reorder. Defaults to all group-b sequences.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> \u2014 both using original un-prefixed names.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If group <code>'b'</code> is empty.  Use :meth:<code>reorder_for_colinearity</code> for explicit group names.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_contigs(\n    self,\n    query_names: list[str] | None = None,\n    target_names: list[str] | None = None,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Sort contigs for maximum collinearity (backward-compatible, requires groups a and b).\n\n    Parameters\n    ----------\n    query_names : list[str] or None, optional\n        Original (un-prefixed) names for group ``'a'`` to reorder.\n        Defaults to all group-a sequences.\n    target_names : list[str] or None, optional\n        Original (un-prefixed) names for group ``'b'`` to reorder.\n        Defaults to all group-b sequences.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)`` \u2014 both using original\n        un-prefixed names.\n\n    Raises\n    ------\n    ValueError\n        If group ``'b'`` is empty.  Use :meth:`reorder_for_colinearity` for\n        explicit group names.\n    \"\"\"\n    if 'b' not in self._groups or not self._groups['b']:\n        raise ValueError(\n            \"reorder_contigs requires group 'b' sequences; \"\n            'use reorder_for_colinearity for explicit group names.'\n        )\n    q_names = (\n        query_names if query_names is not None else list(self._groups.get('a', []))\n    )\n    t_names = (\n        target_names\n        if target_names is not None\n        else list(self._groups.get('b', []))\n    )\n    q_internal = [self._make_internal('a', n) for n in q_names]\n    t_internal = [self._make_internal('b', n) for n in t_names]\n    sorted_q_int, sorted_t_int = self._index.optimal_contig_order(\n        q_internal, t_internal\n    )\n    sorted_q = [self._split_internal(n)[1] for n in sorted_q_int]\n    sorted_t = [self._split_internal(n)[1] for n in sorted_t_int]\n    return sorted_q, sorted_t\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise machine-readable representation.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>CrossIdx(k=&lt;k&gt;, groups={&lt;label&gt;=&lt;n&gt;, ...})</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise machine-readable representation.\n\n    Returns\n    -------\n    str\n        ``CrossIdx(k=&lt;k&gt;, groups={&lt;label&gt;=&lt;n&gt;, ...})``.\n    \"\"\"\n    group_info = ', '.join(f'{g}={len(names)}' for g, names in self._groups.items())\n    return f'CrossIdx(k={self._k}, groups={{{group_info}}})'\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.CrossIdx.__str__","title":"<code>__str__()</code>","text":"<p>Return a human-readable stats summary.</p> <p>Returns:</p> Type Description <code>str</code> <p>Multi-line summary of groups, sequence counts, and cached PAF record count.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Return a human-readable stats summary.\n\n    Returns\n    -------\n    str\n        Multi-line summary of groups, sequence counts, and cached PAF\n        record count.\n    \"\"\"\n    n_total = sum(len(v) for v in self._groups.values())\n    lines = [f'CrossIdx (k={self._k})']\n    lines.append(f'  Total sequences : {n_total}')\n    for g, names in self._groups.items():\n        lines.append(f'  Group {g!r:12s}: {len(names):&gt;6d} sequences')\n    lines.append(f'  PAF records     : {len(self._paf_records)}')\n    return '\\n'.join(lines)\n</code></pre>"},{"location":"api/paf_io/#pafalignment-alignment-record-collection","title":"PafAlignment \u2014 Alignment record collection","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord","title":"<code>PafRecord</code>  <code>dataclass</code>","text":"<p>A single PAF alignment record.</p> <p>The twelve required PAF columns are represented as typed attributes. Optional SAM-like tags (e.g. <code>tp:A:P</code>, <code>cg:Z:10M</code>) are stored in :attr:<code>tags</code>.  If a <code>cg:Z:</code> tag is present, CIGAR-derived alignment statistics are populated automatically.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Query sequence name (column 1).</p> required <code>query_len</code> <code>int</code> <p>Query sequence length (column 2).</p> required <code>query_start</code> <code>int</code> <p>Query start position, 0-based (column 3).</p> required <code>query_end</code> <code>int</code> <p>Query end position, exclusive (column 4).</p> required <code>strand</code> <code>str</code> <p>Relative strand: <code>\"+\"</code> or <code>\"-\"</code> (column 5).</p> required <code>target_name</code> <code>str</code> <p>Target sequence name (column 6).</p> required <code>target_len</code> <code>int</code> <p>Target sequence length (column 7).</p> required <code>target_start</code> <code>int</code> <p>Target start position, 0-based (column 8).</p> required <code>target_end</code> <code>int</code> <p>Target end position, exclusive (column 9).</p> required <code>residue_matches</code> <code>int</code> <p>Number of residue matches (column 10).</p> required <code>alignment_block_len</code> <code>int</code> <p>Number of bases in the alignment block (column 11).</p> required <code>mapping_quality</code> <code>int</code> <p>Mapping quality (0\u2013255; 255 = missing) (column 12).</p> required <code>tags</code> <code>dict[str, Any]</code> <p>Optional SAM-like tags decoded as <code>{tag_name: value}</code>.</p> <code>dict()</code> <code>cigar</code> <code>str or None</code> <p>CIGAR string from <code>cg:Z:</code> tag, or <code>None</code> if absent.</p> <code>None</code> <code>alignment_length</code> <code>int or None</code> <p>Target-span alignment length derived from CIGAR, or <code>None</code>.</p> <code>None</code> <code>n_matches</code> <code>int or None</code> <p>Count of exact-match bases (<code>=</code> ops) from CIGAR; falls back to <code>residue_matches</code> when only <code>M</code> ops are present.</p> <code>None</code> <code>n_mismatches</code> <code>int or None</code> <p>Count of mismatch bases (<code>X</code> ops) from CIGAR, or <code>None</code>.</p> <code>None</code> <code>n_gaps</code> <code>int or None</code> <p>Total number of gap bases (<code>I</code> + <code>D</code> bases) from CIGAR.</p> <code>None</code> <code>n_gap_bases</code> <code>int or None</code> <p>Same as <code>n_gaps</code> (alias kept for clarity).</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@dataclass\nclass PafRecord:\n    \"\"\"A single PAF alignment record.\n\n    The twelve required PAF columns are represented as typed attributes.\n    Optional SAM-like tags (e.g. ``tp:A:P``, ``cg:Z:10M``) are stored in\n    :attr:`tags`.  If a ``cg:Z:`` tag is present, CIGAR-derived alignment\n    statistics are populated automatically.\n\n    Parameters\n    ----------\n    query_name : str\n        Query sequence name (column 1).\n    query_len : int\n        Query sequence length (column 2).\n    query_start : int\n        Query start position, 0-based (column 3).\n    query_end : int\n        Query end position, exclusive (column 4).\n    strand : str\n        Relative strand: ``\"+\"`` or ``\"-\"`` (column 5).\n    target_name : str\n        Target sequence name (column 6).\n    target_len : int\n        Target sequence length (column 7).\n    target_start : int\n        Target start position, 0-based (column 8).\n    target_end : int\n        Target end position, exclusive (column 9).\n    residue_matches : int\n        Number of residue matches (column 10).\n    alignment_block_len : int\n        Number of bases in the alignment block (column 11).\n    mapping_quality : int\n        Mapping quality (0\u2013255; 255 = missing) (column 12).\n    tags : dict[str, Any]\n        Optional SAM-like tags decoded as ``{tag_name: value}``.\n    cigar : str or None\n        CIGAR string from ``cg:Z:`` tag, or ``None`` if absent.\n    alignment_length : int or None\n        Target-span alignment length derived from CIGAR, or ``None``.\n    n_matches : int or None\n        Count of exact-match bases (``=`` ops) from CIGAR; falls back to\n        ``residue_matches`` when only ``M`` ops are present.\n    n_mismatches : int or None\n        Count of mismatch bases (``X`` ops) from CIGAR, or ``None``.\n    n_gaps : int or None\n        Total number of gap bases (``I`` + ``D`` bases) from CIGAR.\n    n_gap_bases : int or None\n        Same as ``n_gaps`` (alias kept for clarity).\n    \"\"\"\n\n    query_name: str\n    query_len: int\n    query_start: int\n    query_end: int\n    strand: str\n    target_name: str\n    target_len: int\n    target_start: int\n    target_end: int\n    residue_matches: int\n    alignment_block_len: int\n    mapping_quality: int\n    tags: dict[str, Any] = field(default_factory=dict)\n    cigar: str | None = None\n    alignment_length: int | None = None\n    n_matches: int | None = None\n    n_mismatches: int | None = None\n    n_gaps: int | None = None\n    n_gap_bases: int | None = None\n\n    @property\n    def query_aligned_len(self) -&gt; int:\n        \"\"\"Return the aligned length on the query sequence.\n\n        Returns\n        -------\n        int\n            ``query_end - query_start``.\n        \"\"\"\n        return self.query_end - self.query_start\n\n    @property\n    def target_aligned_len(self) -&gt; int:\n        \"\"\"Return the aligned length on the target sequence.\n\n        Returns\n        -------\n        int\n            ``target_end - target_start``.\n        \"\"\"\n        return self.target_end - self.target_start\n\n    @classmethod\n    def from_line(cls, line: str) -&gt; 'PafRecord':\n        \"\"\"Parse a single PAF text line into a :class:`PafRecord`.\n\n        Parameters\n        ----------\n        line : str\n            A single PAF record line (tab-separated, trailing newline optional).\n\n        Returns\n        -------\n        PafRecord\n            The parsed record.\n\n        Raises\n        ------\n        ValueError\n            If the line has fewer than 12 tab-separated fields.\n        \"\"\"\n        fields = line.rstrip('\\n').split('\\t')\n        if len(fields) &lt; 12:\n            raise ValueError(\n                f'PAF line has {len(fields)} fields; expected at least 12: {line!r}'\n            )\n        tags: dict[str, Any] = {}\n        cigar: str | None = None\n        for tag_field in fields[12:]:\n            parts = tag_field.split(':', 2)\n            if len(parts) == 3:\n                tag_name, tag_type, tag_value = parts\n                if tag_type == 'i':\n                    tags[tag_name] = int(tag_value)\n                elif tag_type == 'f':\n                    tags[tag_name] = float(tag_value)\n                else:\n                    tags[tag_name] = tag_value\n                if tag_name == 'cg' and tag_type == 'Z':\n                    cigar = tag_value\n\n        residue_matches = int(fields[9])\n        stats: dict[str, int] = {}\n        if cigar is not None:\n            stats = _cigar_stats(cigar, residue_matches)\n\n        return cls(\n            query_name=fields[0],\n            query_len=int(fields[1]),\n            query_start=int(fields[2]),\n            query_end=int(fields[3]),\n            strand=fields[4],\n            target_name=fields[5],\n            target_len=int(fields[6]),\n            target_start=int(fields[7]),\n            target_end=int(fields[8]),\n            residue_matches=residue_matches,\n            alignment_block_len=int(fields[10]),\n            mapping_quality=int(fields[11]),\n            tags=tags,\n            cigar=cigar,\n            alignment_length=stats.get('alignment_length'),\n            n_matches=stats.get('n_matches'),\n            n_mismatches=stats.get('n_mismatches'),\n            n_gaps=stats.get('n_gaps'),\n            n_gap_bases=stats.get('n_gap_bases'),\n        )\n\n    def to_line(self) -&gt; str:\n        \"\"\"Serialise this record back to a PAF-format string (no trailing newline).\n\n        Returns\n        -------\n        str\n            Tab-separated PAF line with the 12 required columns.  Optional\n            tags are not included.\n        \"\"\"\n        return '\\t'.join(\n            str(v)\n            for v in [\n                self.query_name,\n                self.query_len,\n                self.query_start,\n                self.query_end,\n                self.strand,\n                self.target_name,\n                self.target_len,\n                self.target_start,\n                self.target_end,\n                self.residue_matches,\n                self.alignment_block_len,\n                self.mapping_quality,\n            ]\n        )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.query_aligned_len","title":"<code>query_aligned_len</code>  <code>property</code>","text":"<p>Return the aligned length on the query sequence.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>query_end - query_start</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.target_aligned_len","title":"<code>target_aligned_len</code>  <code>property</code>","text":"<p>Return the aligned length on the target sequence.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>target_end - target_start</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Parse a single PAF text line into a :class:<code>PafRecord</code>.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A single PAF record line (tab-separated, trailing newline optional).</p> required <p>Returns:</p> Type Description <code>PafRecord</code> <p>The parsed record.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the line has fewer than 12 tab-separated fields.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_line(cls, line: str) -&gt; 'PafRecord':\n    \"\"\"Parse a single PAF text line into a :class:`PafRecord`.\n\n    Parameters\n    ----------\n    line : str\n        A single PAF record line (tab-separated, trailing newline optional).\n\n    Returns\n    -------\n    PafRecord\n        The parsed record.\n\n    Raises\n    ------\n    ValueError\n        If the line has fewer than 12 tab-separated fields.\n    \"\"\"\n    fields = line.rstrip('\\n').split('\\t')\n    if len(fields) &lt; 12:\n        raise ValueError(\n            f'PAF line has {len(fields)} fields; expected at least 12: {line!r}'\n        )\n    tags: dict[str, Any] = {}\n    cigar: str | None = None\n    for tag_field in fields[12:]:\n        parts = tag_field.split(':', 2)\n        if len(parts) == 3:\n            tag_name, tag_type, tag_value = parts\n            if tag_type == 'i':\n                tags[tag_name] = int(tag_value)\n            elif tag_type == 'f':\n                tags[tag_name] = float(tag_value)\n            else:\n                tags[tag_name] = tag_value\n            if tag_name == 'cg' and tag_type == 'Z':\n                cigar = tag_value\n\n    residue_matches = int(fields[9])\n    stats: dict[str, int] = {}\n    if cigar is not None:\n        stats = _cigar_stats(cigar, residue_matches)\n\n    return cls(\n        query_name=fields[0],\n        query_len=int(fields[1]),\n        query_start=int(fields[2]),\n        query_end=int(fields[3]),\n        strand=fields[4],\n        target_name=fields[5],\n        target_len=int(fields[6]),\n        target_start=int(fields[7]),\n        target_end=int(fields[8]),\n        residue_matches=residue_matches,\n        alignment_block_len=int(fields[10]),\n        mapping_quality=int(fields[11]),\n        tags=tags,\n        cigar=cigar,\n        alignment_length=stats.get('alignment_length'),\n        n_matches=stats.get('n_matches'),\n        n_mismatches=stats.get('n_mismatches'),\n        n_gaps=stats.get('n_gaps'),\n        n_gap_bases=stats.get('n_gap_bases'),\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.to_line","title":"<code>to_line()</code>","text":"<p>Serialise this record back to a PAF-format string (no trailing newline).</p> <p>Returns:</p> Type Description <code>str</code> <p>Tab-separated PAF line with the 12 required columns.  Optional tags are not included.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def to_line(self) -&gt; str:\n    \"\"\"Serialise this record back to a PAF-format string (no trailing newline).\n\n    Returns\n    -------\n    str\n        Tab-separated PAF line with the 12 required columns.  Optional\n        tags are not included.\n    \"\"\"\n    return '\\t'.join(\n        str(v)\n        for v in [\n            self.query_name,\n            self.query_len,\n            self.query_start,\n            self.query_end,\n            self.strand,\n            self.target_name,\n            self.target_len,\n            self.target_start,\n            self.target_end,\n            self.residue_matches,\n            self.alignment_block_len,\n            self.mapping_quality,\n        ]\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment","title":"<code>PafAlignment</code>","text":"<p>A collection of PAF alignment records with contig-ordering utilities.</p> <p>Can be constructed from a file path or an iterable of :class:<code>PafRecord</code> objects.  Provides :meth:<code>reorder_contigs</code> to sort query and target sequence names so that a subsequent dotplot shows maximum collinearity.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>list of PafRecord</code> <p>The alignment records.</p> required <p>Examples:</p> <p>Load from a file and reorder contigs:</p> <pre><code>&gt;&gt;&gt; aln = PafAlignment.from_file(\"alignments.paf\")\n&gt;&gt;&gt; q_order, t_order = aln.reorder_contigs(aln.query_names, aln.target_names)\n</code></pre> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>class PafAlignment:\n    \"\"\"A collection of PAF alignment records with contig-ordering utilities.\n\n    Can be constructed from a file path or an iterable of :class:`PafRecord`\n    objects.  Provides :meth:`reorder_contigs` to sort query and target\n    sequence names so that a subsequent dotplot shows maximum collinearity.\n\n    Parameters\n    ----------\n    records : list of PafRecord\n        The alignment records.\n\n    Examples\n    --------\n    Load from a file and reorder contigs:\n\n    &gt;&gt;&gt; aln = PafAlignment.from_file(\"alignments.paf\")\n    &gt;&gt;&gt; q_order, t_order = aln.reorder_contigs(aln.query_names, aln.target_names)\n    \"\"\"\n\n    def __init__(self, records: list[PafRecord]) -&gt; None:\n        self.records: list[PafRecord] = records\n\n    # ------------------------------------------------------------------\n    # Constructors\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_file(cls, path: str | Path) -&gt; 'PafAlignment':\n        \"\"\"Load records from a PAF file.\n\n        Parameters\n        ----------\n        path : str or Path\n            Path to the PAF file.\n\n        Returns\n        -------\n        PafAlignment\n            New instance with all records loaded.\n        \"\"\"\n        return cls(list(parse_paf_file(path)))\n\n    @classmethod\n    def from_records(cls, records: Iterable[PafRecord]) -&gt; 'PafAlignment':\n        \"\"\"Construct from an iterable of :class:`PafRecord` objects.\n\n        Parameters\n        ----------\n        records : iterable of PafRecord\n            Source records.\n\n        Returns\n        -------\n        PafAlignment\n            New instance.\n        \"\"\"\n        return cls(list(records))\n\n    # ------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------\n\n    @property\n    def query_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of query sequence names (insertion order).\n\n        Returns\n        -------\n        list[str]\n            Unique query names in the order first seen.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.query_name] = None\n        return list(seen)\n\n    @property\n    def target_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of target sequence names (insertion order).\n\n        Returns\n        -------\n        list[str]\n            Unique target names in the order first seen.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.target_name] = None\n        return list(seen)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of records.\n\n        Returns\n        -------\n        int\n            Record count.\n        \"\"\"\n        return len(self.records)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise string representation.\n\n        Returns\n        -------\n        str\n            ``PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)``.\n        \"\"\"\n        return (\n            f'PafAlignment(records={len(self.records)}, '\n            f'queries={len(self.query_names)}, '\n            f'targets={len(self.target_names)})'\n        )\n\n    # ------------------------------------------------------------------\n    # Filtering\n    # ------------------------------------------------------------------\n\n    def filter_by_query(self, names: Iterable[str]) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` containing only the given query names.\n\n        Parameters\n        ----------\n        names : iterable of str\n            Query names to keep.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment.\n        \"\"\"\n        keep = set(names)\n        return PafAlignment([r for r in self.records if r.query_name in keep])\n\n    def filter_by_target(self, names: Iterable[str]) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` containing only the given target names.\n\n        Parameters\n        ----------\n        names : iterable of str\n            Target names to keep.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment.\n        \"\"\"\n        keep = set(names)\n        return PafAlignment([r for r in self.records if r.target_name in keep])\n\n    # ------------------------------------------------------------------\n    # Contig reordering\n    # ------------------------------------------------------------------\n\n    def reorder_contigs(\n        self,\n        query_names: list[str] | None = None,\n        target_names: list[str] | None = None,\n    ) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Sort query and target contigs to maximise collinearity in the dotplot.\n\n        Uses the gravity-centre algorithm: each contig is assigned a gravity\n        equal to the weighted mean position of its alignment blocks on the\n        opposing axis.  Contigs are then sorted by ascending gravity.\n\n        Parameters\n        ----------\n        query_names : list[str] or None, optional\n            Query contigs to reorder.  Defaults to :attr:`query_names`.\n        target_names : list[str] or None, optional\n            Target contigs to reorder.  Defaults to :attr:`target_names`.\n\n        Returns\n        -------\n        tuple[list[str], list[str]]\n            ``(sorted_query_names, sorted_target_names)``.\n        \"\"\"\n        q = query_names if query_names is not None else self.query_names\n        t = target_names if target_names is not None else self.target_names\n        return compute_gravity_contigs(self.records, q, t)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.query_names","title":"<code>query_names</code>  <code>property</code>","text":"<p>Return a deduplicated list of query sequence names (insertion order).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unique query names in the order first seen.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.target_names","title":"<code>target_names</code>  <code>property</code>","text":"<p>Return a deduplicated list of target sequence names (insertion order).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unique target names in the order first seen.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load records from a PAF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the PAF file.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>New instance with all records loaded.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; 'PafAlignment':\n    \"\"\"Load records from a PAF file.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the PAF file.\n\n    Returns\n    -------\n    PafAlignment\n        New instance with all records loaded.\n    \"\"\"\n    return cls(list(parse_paf_file(path)))\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.from_records","title":"<code>from_records(records)</code>  <code>classmethod</code>","text":"<p>Construct from an iterable of :class:<code>PafRecord</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable of PafRecord</code> <p>Source records.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>New instance.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_records(cls, records: Iterable[PafRecord]) -&gt; 'PafAlignment':\n    \"\"\"Construct from an iterable of :class:`PafRecord` objects.\n\n    Parameters\n    ----------\n    records : iterable of PafRecord\n        Source records.\n\n    Returns\n    -------\n    PafAlignment\n        New instance.\n    \"\"\"\n    return cls(list(records))\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of records.</p> <p>Returns:</p> Type Description <code>int</code> <p>Record count.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of records.\n\n    Returns\n    -------\n    int\n        Record count.\n    \"\"\"\n    return len(self.records)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise string representation.\n\n    Returns\n    -------\n    str\n        ``PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)``.\n    \"\"\"\n    return (\n        f'PafAlignment(records={len(self.records)}, '\n        f'queries={len(self.query_names)}, '\n        f'targets={len(self.target_names)})'\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_query","title":"<code>filter_by_query(names)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> containing only the given query names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>iterable of str</code> <p>Query names to keep.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_query(self, names: Iterable[str]) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` containing only the given query names.\n\n    Parameters\n    ----------\n    names : iterable of str\n        Query names to keep.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment.\n    \"\"\"\n    keep = set(names)\n    return PafAlignment([r for r in self.records if r.query_name in keep])\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_target","title":"<code>filter_by_target(names)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> containing only the given target names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>iterable of str</code> <p>Target names to keep.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_target(self, names: Iterable[str]) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` containing only the given target names.\n\n    Parameters\n    ----------\n    names : iterable of str\n        Target names to keep.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment.\n    \"\"\"\n    keep = set(names)\n    return PafAlignment([r for r in self.records if r.target_name in keep])\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.reorder_contigs","title":"<code>reorder_contigs(query_names=None, target_names=None)</code>","text":"<p>Sort query and target contigs to maximise collinearity in the dotplot.</p> <p>Uses the gravity-centre algorithm: each contig is assigned a gravity equal to the weighted mean position of its alignment blocks on the opposing axis.  Contigs are then sorted by ascending gravity.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str] or None</code> <p>Query contigs to reorder.  Defaults to :attr:<code>query_names</code>.</p> <code>None</code> <code>target_names</code> <code>list[str] or None</code> <p>Target contigs to reorder.  Defaults to :attr:<code>target_names</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_contigs(\n    self,\n    query_names: list[str] | None = None,\n    target_names: list[str] | None = None,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Sort query and target contigs to maximise collinearity in the dotplot.\n\n    Uses the gravity-centre algorithm: each contig is assigned a gravity\n    equal to the weighted mean position of its alignment blocks on the\n    opposing axis.  Contigs are then sorted by ascending gravity.\n\n    Parameters\n    ----------\n    query_names : list[str] or None, optional\n        Query contigs to reorder.  Defaults to :attr:`query_names`.\n    target_names : list[str] or None, optional\n        Target contigs to reorder.  Defaults to :attr:`target_names`.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)``.\n    \"\"\"\n    q = query_names if query_names is not None else self.query_names\n    t = target_names if target_names is not None else self.target_names\n    return compute_gravity_contigs(self.records, q, t)\n</code></pre>"},{"location":"api/paf_io/#functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.parse_paf_file","title":"<code>parse_paf_file(path)</code>","text":"<p>Yield :class:<code>PafRecord</code> objects from a PAF file.</p> <p>Lines beginning with <code>#</code> are treated as comments and skipped.  Empty lines are also skipped.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the PAF file.</p> required <p>Yields:</p> Type Description <code>PafRecord</code> <p>One record per non-comment, non-empty line.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If <code>path</code> does not exist.</p> <code>ValueError</code> <p>If a line cannot be parsed as a PAF record.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def parse_paf_file(path: str | Path) -&gt; Generator[PafRecord, None, None]:\n    \"\"\"Yield :class:`PafRecord` objects from a PAF file.\n\n    Lines beginning with ``#`` are treated as comments and skipped.  Empty\n    lines are also skipped.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the PAF file.\n\n    Yields\n    ------\n    PafRecord\n        One record per non-comment, non-empty line.\n\n    Raises\n    ------\n    FileNotFoundError\n        If ``path`` does not exist.\n    ValueError\n        If a line cannot be parsed as a PAF record.\n    \"\"\"\n    path = Path(path)\n    with path.open('r', encoding='utf-8') as fh:\n        for line in fh:\n            line = line.rstrip('\\n')\n            if not line or line.startswith('#'):\n                continue\n            yield PafRecord.from_line(line)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.compute_gravity_contigs","title":"<code>compute_gravity_contigs(records, query_names, target_names)</code>","text":"<p>Return query and target contig names sorted by gravity centre.</p> <p>For each query contig the gravity centre is the weighted mean of target mid-point positions (normalised by the total target span) across all alignment records that involve that contig.  Target contigs are sorted symmetrically against the query axis.</p> <p>Contigs with no alignment records receive a gravity of <code>float(\"inf\")</code> and are placed at the end of the sorted list.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable of PafRecord</code> <p>Alignment records to use for computing gravity centres.</p> required <code>query_names</code> <code>list[str]</code> <p>The query contig names to reorder.</p> required <code>target_names</code> <code>list[str]</code> <p>The target contig names to reorder.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> ordered by ascending gravity centre.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def compute_gravity_contigs(\n    records: Iterable[PafRecord],\n    query_names: list[str],\n    target_names: list[str],\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Return query and target contig names sorted by gravity centre.\n\n    For each query contig the gravity centre is the weighted mean of target\n    mid-point positions (normalised by the total target span) across all\n    alignment records that involve that contig.  Target contigs are sorted\n    symmetrically against the query axis.\n\n    Contigs with no alignment records receive a gravity of ``float(\"inf\")``\n    and are placed at the end of the sorted list.\n\n    Parameters\n    ----------\n    records : iterable of PafRecord\n        Alignment records to use for computing gravity centres.\n    query_names : list[str]\n        The query contig names to reorder.\n    target_names : list[str]\n        The target contig names to reorder.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)`` ordered by ascending\n        gravity centre.\n    \"\"\"\n    query_set = set(query_names)\n    target_set = set(target_names)\n\n    # Collect all records into a list and build sequence-length maps from them.\n    q_len_map: dict[str, int] = {}\n    t_len_map: dict[str, int] = {}\n    all_records: list[PafRecord] = []\n    for rec in records:\n        all_records.append(rec)\n        q_len_map[rec.query_name] = rec.query_len\n        t_len_map[rec.target_name] = rec.target_len\n\n    # Build cumulative target offsets using actual sequence lengths.\n    t_offsets: dict[str, int] = {}\n    t_off = 0\n    for t in target_names:\n        t_offsets[t] = t_off\n        t_off += t_len_map.get(t, 1)\n    total_target_len = max(t_off, 1)\n\n    # Build cumulative query offsets using actual sequence lengths.\n    q_offsets_real: dict[str, int] = {}\n    q_off = 0\n    for q in query_names:\n        q_offsets_real[q] = q_off\n        q_off += q_len_map.get(q, 1)\n    total_query_len = max(q_off, 1)\n\n    # Accumulate weighted positions.\n    q_weight: dict[str, float] = dict.fromkeys(query_names, 0.0)\n    q_wpos: dict[str, float] = dict.fromkeys(query_names, 0.0)\n    t_weight: dict[str, float] = dict.fromkeys(target_names, 0.0)\n    t_wpos: dict[str, float] = dict.fromkeys(target_names, 0.0)\n\n    for rec in all_records:\n        if rec.query_name not in query_set or rec.target_name not in target_set:\n            continue\n        size = float(rec.alignment_block_len or (rec.query_end - rec.query_start))\n        if size &lt;= 0:\n            continue\n\n        # Target gravity from query's perspective.\n        t_mid = (\n            t_offsets.get(rec.target_name, 0)\n            + (rec.target_start + rec.target_end) / 2.0\n        )\n        q_weight[rec.query_name] += size\n        q_wpos[rec.query_name] += size * t_mid\n\n        # Query gravity from target's perspective.\n        q_mid = (\n            q_offsets_real.get(rec.query_name, 0)\n            + (rec.query_start + rec.query_end) / 2.0\n        )\n        t_weight[rec.target_name] += size\n        t_wpos[rec.target_name] += size * q_mid\n\n    def _gravity(name: str, wt: dict, wp: dict, total: float) -&gt; float:\n        w = wt.get(name, 0.0)\n        return (wp.get(name, 0.0) / w / total) if w &gt; 0 else float('inf')\n\n    def _sort_key_with_len(\n        name: str,\n        wt: dict,\n        wp: dict,\n        total: float,\n        len_map: dict,\n    ) -&gt; tuple:\n        g = _gravity(name, wt, wp, total)\n        if g == float('inf'):\n            # Unmatched: sort after matched (1 &gt; 0), then by descending length\n            return (1, -len_map.get(name, 0))\n        return (0, g)\n\n    sorted_q = sorted(\n        query_names,\n        key=lambda n: _sort_key_with_len(\n            n, q_weight, q_wpos, total_target_len, q_len_map\n        ),\n    )\n    sorted_t = sorted(\n        target_names,\n        key=lambda n: _sort_key_with_len(\n            n, t_weight, t_wpos, total_query_len, t_len_map\n        ),\n    )\n    return sorted_q, sorted_t\n</code></pre>"},{"location":"api/sequence_index/","title":"SequenceIndex","text":"<p>The <code>SequenceIndex</code> class is the primary interface for building and querying FM-index-backed sequence comparison data. It is implemented in Rust (via PyO3) for maximum performance.</p>"},{"location":"api/sequence_index/#how-multiple-sequences-are-stored","title":"How multiple sequences are stored","text":"<p>Each sequence added to a <code>SequenceIndex</code> receives its own independent FM-index, built by rust-bio. The rust-bio FM-index is a read-only data structure that is constructed once for a given sequence and cannot be extended or updated after construction.</p> <p>This means:</p> <ul> <li>Adding sequences accumulates independent indexes. Calling <code>add_sequence</code> or <code>load_fasta</code> multiple times grows the collection \u2014 each call creates a new, isolated FM-index for that sequence only and does not affect any existing FM-index.</li> <li><code>load_fasta</code> can be called multiple times. Each call parses a file and adds its sequences to the collection, preserving all sequences that were added previously. Two calls on two separate FASTA files will leave the index containing all sequences from both files.</li> <li>Re-using a name emits a warning and overwrites. If <code>add_sequence</code> or a FASTA record uses a name that already exists in the index, a <code>UserWarning</code> is emitted and the existing entry (and its FM-index) is replaced with a new one for the new sequence.</li> <li>Duplicate names within a FASTA file raise an error. If a FASTA file contains two records with the same sequence name, <code>load_fasta</code> raises a <code>ValueError</code> before adding any sequences from that file to the index.</li> <li>Pairwise comparisons use two independent FM-indexes. <code>compare_sequences</code> and <code>compare_sequences_stranded</code> look up the two named sequences from the dictionary and compare their individual FM-indexes \u2014 no combined or merged FM-index is ever created.</li> </ul> <pre><code>from rusty_dot import SequenceIndex\nimport warnings\n\nidx = SequenceIndex(k=15)\n\n# Each call adds a new independent FM-index entry\nidx.add_sequence(\"contig1\", \"ACGT\" * 100)\nidx.add_sequence(\"contig2\", \"TTTT\" * 100)\nprint(idx.sequence_names())   # ['contig1', 'contig2']\n\n# load_fasta accumulates \u2014 sequences from both files are kept\nidx.load_fasta(\"assembly_a.fasta\")\nidx.load_fasta(\"assembly_b.fasta\")\nprint(len(idx.sequence_names()))  # total from both files plus the two above\n\n# Re-using a name emits a UserWarning then replaces the entry\nwith warnings.catch_warnings(record=True) as w:\n    warnings.simplefilter(\"always\")\n    idx.add_sequence(\"contig1\", \"GGGG\" * 100)   # overwrites old contig1\nassert len(w) == 1                               # exactly one warning emitted\nassert issubclass(w[0].category, UserWarning)    # warned before overwriting\nprint(idx.get_sequence_length(\"contig1\"))        # 400 (the new sequence)\n\n# load_fasta raises ValueError if the FASTA file itself has duplicate names\ntry:\n    idx.load_fasta(\"file_with_dup_names.fasta\")\nexcept ValueError as e:\n    print(e)   # \"duplicate sequence name 'seq1' in FASTA file '...'\"\n</code></pre>"},{"location":"api/sequence_index/#class","title":"Class","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex","title":"<code>SequenceIndex</code>","text":"<p>FM-index backed sequence comparison engine.</p> <p>Each sequence added to the index receives its own independent FM-index built by rust-bio.  The FM-index is constructed once per sequence and cannot be extended after construction, so adding more sequences never modifies an existing FM-index \u2014 it only creates a new one for the newly added sequence.</p> <p>The index behaves as a dictionary of per-sequence FM-indexes:</p> <ul> <li>:meth:<code>add_sequence</code> and :meth:<code>load_fasta</code> add new entries to   the collection; calling either method multiple times accumulates   sequences rather than replacing the collection.</li> <li>If a sequence name already exists in the index, a <code>UserWarning</code> is   emitted and the existing entry is overwritten with a new FM-index   for the new sequence.</li> <li>:meth:<code>load_fasta</code> raises <code>ValueError</code> if the FASTA file itself   contains duplicate sequence names.</li> <li>Pairwise comparisons (:meth:<code>compare_sequences</code>,   :meth:<code>compare_sequences_stranded</code>) always operate on exactly two   independent FM-indexes.</li> </ul> <p>The k-mer length <code>k</code> is fixed at construction time and applies to all sequences held in the index.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The k-mer length to use for indexing and comparison.</p> required <p>Examples:</p> <p>Build an index from individual sequences:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\")\n&gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\")\n&gt;&gt;&gt; idx.sequence_names()\n['seq1', 'seq2']\n</code></pre> <p>Accumulate sequences from multiple FASTA files:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=15)\n&gt;&gt;&gt; idx.load_fasta(\"assembly_a.fasta\")   # adds seqs from file A\n&gt;&gt;&gt; idx.load_fasta(\"assembly_b.fasta\")   # adds seqs from file B, keeps file A seqs\n&gt;&gt;&gt; matches = idx.compare_sequences(\"seq1\", \"seq2\")\n</code></pre> <p>Overwrite a sequence by re-using its name:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGT\")\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"GGGGGGGG\")  # silently replaces the previous seq1\n</code></pre>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex-attributes","title":"Attributes","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.k","title":"<code>k</code>  <code>property</code>","text":"<p>The k-mer length used for this index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The k-mer length supplied at construction time.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex-functions","title":"Functions","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__init__","title":"<code>__init__(k)</code>","text":"<p>Initialise an empty SequenceIndex.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The k-mer length to use for indexing and comparison. Must be greater than zero.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>k</code> is zero.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.add_sequence","title":"<code>add_sequence(name, seq)</code>","text":"<p>Add a single sequence to the index.</p> <p>Builds a new independent FM-index for <code>seq</code> using rust-bio and stores it alongside the k-mer set and raw sequence bytes.  Each call creates a separate FM-index for that sequence only \u2014 the rust-bio FM-index cannot be extended after construction, so adding sequences never modifies existing FM-indexes.</p> <p>Calling <code>add_sequence</code> does not affect any other sequence already in the index.  Sequences accumulate: calling this method N times with N distinct names results in an index holding N independent FM-indexes.</p> <p>If a sequence named <code>name</code> already exists in the index, a <code>UserWarning</code> is emitted and the existing entry is overwritten with a new FM-index for the new <code>seq</code>.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the sequence.  Re-using an existing name emits a :class:<code>UserWarning</code> and replaces that sequence (and its FM-index).</p> required <code>seq</code> <code>str</code> <p>DNA sequence string. Uppercase is recommended; lowercase input is accepted and treated as uppercase.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the FM-index cannot be built (e.g., invalid characters).</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>If <code>name</code> already exists in the index (the existing entry is overwritten).</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.load_fasta","title":"<code>load_fasta(path)</code>","text":"<p>Load all sequences from a FASTA or gzipped FASTA file.</p> <p>Parses the file with needletail (automatic gzip detection) and builds a fresh independent FM-index for each record.</p> <p>Sequences already in the index are preserved \u2014 <code>load_fasta</code> only adds new entries (or overwrites entries whose name already exists in the index).  Calling <code>load_fasta</code> on two separate files accumulates all sequences from both files in the same index.</p> <p>If the FASTA file contains duplicate sequence names (two records with the same identifier), a <code>ValueError</code> is raised before any sequences are added to the index.</p> <p>If a record's name already exists in the index, a <code>UserWarning</code> is emitted and the existing entry is overwritten with the new sequence.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a FASTA (<code>.fa</code>, <code>.fasta</code>) or gzipped FASTA (<code>.fa.gz</code>, <code>.fasta.gz</code>) file.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Sequence names (record identifiers) that were added, in the order they appear in the file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be opened or parsed, or if the file contains duplicate sequence names.</p> <p>Warns:</p> Type Description <code>UserWarning</code> <p>For each record whose name already exists in the index (those entries are overwritten).</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.sequence_names","title":"<code>sequence_names()</code>","text":"<p>Return all sequence names currently held in the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unordered list of sequence identifiers.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_kmer_set","title":"<code>get_kmer_set(name)</code>","text":"<p>Return the set of unique k-mers for a named sequence.</p> <p>Only k-mers composed entirely of the characters A, C, G, T are included (k-mers containing N or other IUPAC codes are excluded).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The sequence identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>The set of unique k-mer strings (length <code>k</code>) found in the sequence.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_sequence_length","title":"<code>get_sequence_length(name)</code>","text":"<p>Return the length of a named sequence in base pairs.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The sequence identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sequence length in base pairs (not including any internal sentinel character).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.compare_sequences","title":"<code>compare_sequences(query_name, target_name, merge=True)</code>","text":"<p>Find shared k-mer matches between two sequences.</p> <p>Intersects the k-mer sets of the two sequences and looks up the coordinates of each shared k-mer in both FM-indexes.  Uses the smaller k-mer set as the probe for efficiency.</p> <p>When <code>merge=True</code> (default) consecutive k-mer hits on the same co-linear diagonal are merged into a single coordinate block. Results for each <code>(query_name, target_name, merge)</code> combination are cached; repeated calls with the same arguments are free.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence (defines the y-axis in a dotplot).</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence (defines the x-axis in a dotplot).</p> required <code>merge</code> <code>bool</code> <p>When <code>True</code> (default), merge consecutive co-linear k-mer hits into contiguous coordinate blocks.  When <code>False</code>, every individual k-mer hit is returned as its own block.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> coordinate tuples.  All coordinates are 0-based; end positions are exclusive.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either <code>query_name</code> or <code>target_name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_paf","title":"<code>get_paf(query_name, target_name, merge=True)</code>","text":"<p>Return PAF-formatted alignment strings for a sequence pair.</p> <p>Calls <code>compare_sequences</code> internally (using the cache if available) and formats the result as 12-column PAF lines.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF lines as tab-separated strings.  Each line has 12 fields: query name, query length, query start, query end, strand, target name, target length, target start, target end, residue matches, alignment block length, mapping quality.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_paf_all","title":"<code>get_paf_all(merge=True)</code>","text":"<p>Return PAF-formatted strings for every ordered sequence pair.</p> <p>Calls :meth:<code>get_paf</code> for every <code>(i, j)</code> pair where <code>i != j</code>, populating the comparison cache as a side-effect.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>All PAF lines for every pairwise comparison, one line per match.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.precompute_all_pairs","title":"<code>precompute_all_pairs(merge=True)</code>","text":"<p>Pre-calculate comparisons for every ordered sequence pair.</p> <p>Iterates over all <code>(i, j)</code> pairs where <code>i != j</code> and calls <code>compare_sequences</code> for each, populating the cache.  Subsequent individual calls to <code>compare_sequences</code> for any pair will then be served from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>Ordered list of <code>(query_name, target_name)</code> pairs that were computed.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.compare_sequences_stranded","title":"<code>compare_sequences_stranded(query_name, target_name, merge=True)</code>","text":"<p>Find shared k-mer matches between two sequences on both strands.</p> <p>In addition to the forward (<code>+</code>) strand matches returned by :meth:<code>compare_sequences</code>, this method also searches for k-mers in the query whose reverse complement appears in the target, reporting those as <code>\"-\"</code> strand matches.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge co-linear k-mer runs.  Forward runs are merged by diagonal; reverse runs are merged by anti-diagonal. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int, str]]</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> tuples.  Coordinates are 0-based; end positions are exclusive. <code>strand</code> is <code>\"+\"</code> for forward matches and <code>\"-\"</code> for reverse-complement matches.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.optimal_contig_order","title":"<code>optimal_contig_order(query_names, target_names)</code>","text":"<p>Return query and target contig names sorted for maximum collinearity.</p> <p>Uses the gravity-centre algorithm: for each query contig the gravity is the weighted mean of target mid-point positions (normalised by total target span) across all matches.  Query contigs with no matches are placed at the end.  The same algorithm is applied symmetrically to reorder the target contigs.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str]</code> <p>Names of the query sequences to reorder.</p> required <code>target_names</code> <code>list[str]</code> <p>Names of the target sequences to use as the reference axis.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> ordered by ascending gravity centre.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If any sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.save","title":"<code>save(path)</code>","text":"<p>Serialise the index to a binary file.</p> <p>Stores the original sequence bytes and k-mer sets using bincode. The FM-index is rebuilt from the sequence bytes when the file is loaded, so the on-disk format is compact and version-independent.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Destination file path.  The file is created or overwritten.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be created or serialisation fails.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.load","title":"<code>load(path)</code>","text":"<p>Load sequences from a previously serialised index file.</p> <p>Deserialises sequence bytes and k-mer sets from a file written by <code>save</code>, then rebuilds the FM-index for each sequence in memory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a binary index file produced by <code>save</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be read, deserialisation fails, or the k-mer length stored in the file does not match <code>self.k</code>.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of sequences currently held in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>Count of indexed sequences.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation of the index.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string of the form <code>SequenceIndex(k=&lt;k&gt;, sequences=&lt;n&gt;)</code>.</p>"},{"location":"tutorials/all_vs_all_two_indices/","title":"All-vs-All Dotplot Between Two Sequence Indices","text":"In\u00a0[\u00a0]: Copied! <pre>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\nfrom rusty_dot.paf_io import CrossIndexPaf, PafAlignment, PafRecord\n</pre> from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter from rusty_dot.paf_io import CrossIndexPaf, PafAlignment, PafRecord In\u00a0[\u00a0]: Copied! <pre># Sequences for \"genome A\" \u2014 three contigs of different lengths\ngenome_a = {\n    'contigA1': 'ACGTACGTACGTACGTACGT' * 10,   # 200 bp\n    'contigA2': 'TACGTACGTACGTACGTACG' * 5,    # 100 bp\n    'contigA3': 'GCGCGCGCGCGCGCGCGCGC' * 3,   # 60 bp\n}\n\n# Sequences for \"genome B\" \u2014 three contigs\ngenome_b = {\n    'contigB1': 'ACGTACGTACGTACGTACGT' * 8,   # 160 bp  (similar to contigA1)\n    'contigB2': 'GCGCGCGCGCGCGCGCGCGC' * 4,  # 80 bp   (similar to contigA3)\n    'contigB3': 'TTTTAAAAAGGGGCCCCTTTT' * 2,  # 42 bp   (no matches)\n}\n</pre> # Sequences for \"genome A\" \u2014 three contigs of different lengths genome_a = {     'contigA1': 'ACGTACGTACGTACGTACGT' * 10,   # 200 bp     'contigA2': 'TACGTACGTACGTACGTACG' * 5,    # 100 bp     'contigA3': 'GCGCGCGCGCGCGCGCGCGC' * 3,   # 60 bp }  # Sequences for \"genome B\" \u2014 three contigs genome_b = {     'contigB1': 'ACGTACGTACGTACGTACGT' * 8,   # 160 bp  (similar to contigA1)     'contigB2': 'GCGCGCGCGCGCGCGCGCGC' * 4,  # 80 bp   (similar to contigA3)     'contigB3': 'TTTTAAAAAGGGGCCCCTTTT' * 2,  # 42 bp   (no matches) } In\u00a0[\u00a0]: Copied! <pre>cross = CrossIndexPaf(k=10)\n\nfor name, seq in genome_a.items():\n    cross.add_sequence(name, seq, group='a')\n\nfor name, seq in genome_b.items():\n    cross.add_sequence(name, seq, group='b')\n\nprint(cross)\n</pre> cross = CrossIndexPaf(k=10)  for name, seq in genome_a.items():     cross.add_sequence(name, seq, group='a')  for name, seq in genome_b.items():     cross.add_sequence(name, seq, group='b')  print(cross) In\u00a0[\u00a0]: Copied! <pre>paf_lines = cross.get_paf_all(merge=True)\n\nprint(f'Total PAF lines: {len(paf_lines)}')\nfor line in paf_lines[:5]:\n    print(line)\n</pre> paf_lines = cross.get_paf_all(merge=True)  print(f'Total PAF lines: {len(paf_lines)}') for line in paf_lines[:5]:     print(line) In\u00a0[\u00a0]: Copied! <pre>records = [PafRecord.from_line(line) for line in paf_lines]\naln = PafAlignment.from_records(records)\n\nq_sorted, t_sorted = aln.reorder_contigs(\n    query_names=cross.query_names,\n    target_names=cross.target_names,\n)\n\nprint('Sorted query (genome A) contigs:', q_sorted)\nprint('Sorted target (genome B) contigs:', t_sorted)\n</pre> records = [PafRecord.from_line(line) for line in paf_lines] aln = PafAlignment.from_records(records)  q_sorted, t_sorted = aln.reorder_contigs(     query_names=cross.query_names,     target_names=cross.target_names, )  print('Sorted query (genome A) contigs:', q_sorted) print('Sorted target (genome B) contigs:', t_sorted) <p>Note: Contigs with no cross-group matches (e.g. <code>contigB3</code>) are placed at the end, sorted by descending length.</p> In\u00a0[\u00a0]: Copied! <pre>combined_idx = SequenceIndex(k=10)\n\nfor name, seq in genome_a.items():\n    combined_idx.add_sequence(name, seq)\n\nfor name, seq in genome_b.items():\n    combined_idx.add_sequence(name, seq)\n\nprint(combined_idx)\n</pre> combined_idx = SequenceIndex(k=10)  for name, seq in genome_a.items():     combined_idx.add_sequence(name, seq)  for name, seq in genome_b.items():     combined_idx.add_sequence(name, seq)  print(combined_idx) In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(combined_idx)\n\nplotter.plot(\n    query_names=q_sorted,\n    target_names=t_sorted,\n    output_path='/tmp/cross_index_dotplot.png',\n    figsize_per_panel=4.0,\n    scale_sequences=True,\n    title='Genome A vs Genome B \u2014 collinearity-sorted contigs',\n    dpi=100,\n)\n\nfrom IPython.display import Image\nImage('/tmp/cross_index_dotplot.png')\n</pre> plotter = DotPlotter(combined_idx)  plotter.plot(     query_names=q_sorted,     target_names=t_sorted,     output_path='/tmp/cross_index_dotplot.png',     figsize_per_panel=4.0,     scale_sequences=True,     title='Genome A vs Genome B \u2014 collinearity-sorted contigs',     dpi=100, )  from IPython.display import Image Image('/tmp/cross_index_dotplot.png') In\u00a0[\u00a0]: Copied! <pre>q_opt, t_opt = cross.reorder_contigs()\nprint('Optimal query order:', q_opt)\nprint('Optimal target order:', t_opt)\n</pre> q_opt, t_opt = cross.reorder_contigs() print('Optimal query order:', q_opt) print('Optimal target order:', t_opt)"},{"location":"tutorials/all_vs_all_two_indices/#all-vs-all-dotplot-between-two-sequence-indices","title":"All-vs-All Dotplot Between Two Sequence Indices\u00b6","text":"<p>This tutorial demonstrates how to compare sequences from two separate FASTA files (e.g. two genome assemblies) using <code>CrossIndexPaf</code>.  Each FASTA file is assigned to its own group, and pairwise alignments are computed between all sequences in group A and all sequences in group B.</p>"},{"location":"tutorials/all_vs_all_two_indices/#overview","title":"Overview\u00b6","text":"<ol> <li>Create a <code>CrossIndexPaf</code> and load two FASTA files into groups A and B.</li> <li>Retrieve all cross-group PAF alignments with <code>get_paf_all()</code>.</li> <li>Build a <code>PafAlignment</code> from those records for contig reordering.</li> <li>Plot the sorted all-vs-all dotplot with <code>DotPlotter</code>.</li> </ol>"},{"location":"tutorials/all_vs_all_two_indices/#1-create-example-sequences","title":"1. Create example sequences\u00b6","text":"<p>For demonstration we build two small sets of sequences in memory.  In real usage you would call <code>cross.load_fasta('genome_a.fasta', group='a')</code> and <code>cross.load_fasta('genome_b.fasta', group='b')</code>.</p>"},{"location":"tutorials/all_vs_all_two_indices/#2-build-a-crossindexpaf","title":"2. Build a CrossIndexPaf\u00b6","text":"<p><code>CrossIndexPaf</code> holds one internal <code>SequenceIndex</code> that contains sequences from both groups, using internal prefixes (<code>a:</code> / <code>b:</code>) to prevent name collisions.</p>"},{"location":"tutorials/all_vs_all_two_indices/#3-retrieve-all-cross-group-paf-alignments","title":"3. Retrieve all cross-group PAF alignments\u00b6","text":""},{"location":"tutorials/all_vs_all_two_indices/#4-build-a-pafalignment-for-contig-reordering","title":"4. Build a PafAlignment for contig reordering\u00b6","text":"<p>Parse the raw PAF strings into <code>PafRecord</code> objects so we can use the <code>reorder_contigs</code> method to maximise collinearity.</p>"},{"location":"tutorials/all_vs_all_two_indices/#5-build-a-combined-index-for-plotting","title":"5. Build a combined index for plotting\u00b6","text":"<p><code>DotPlotter</code> requires a single <code>SequenceIndex</code> containing all sequences to be plotted.  We create one by adding sequences from both genomes.</p>"},{"location":"tutorials/all_vs_all_two_indices/#6-plot-the-all-vs-all-dotplot-with-relative-scaling","title":"6. Plot the all-vs-all dotplot with relative scaling\u00b6","text":"<p>Pass <code>scale_sequences=True</code> so that each subplot's width and height are proportional to the lengths of the compared sequences.</p>"},{"location":"tutorials/all_vs_all_two_indices/#using-crossindexpafreorder_contigs-directly","title":"Using <code>CrossIndexPaf.reorder_contigs</code> directly\u00b6","text":"<p>A convenience wrapper is also available on the <code>CrossIndexPaf</code> object itself, which internally calls <code>SequenceIndex.optimal_contig_order</code>.</p>"},{"location":"tutorials/dotplot_tutorial/","title":"Dotplot Visualization Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import tempfile\nimport os\n\nfrom rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n</pre> import tempfile import os  from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter In\u00a0[\u00a0]: Copied! <pre># Helper to create a reverse complement\ndef revcomp(seq):\n    table = str.maketrans('ACGTacgt', 'TGCAtgca')\n    return seq.translate(table)[::-1]\n\n\nunit = 'ACGTACGTACGT'  # 12 bp repeat unit\nseq_a = unit * 10  # 120 bp  \u2014 the reference\nseq_b = 'T' + unit * 9 + 'T'  # 120 bp  \u2014 shifted by 1\nseq_c = revcomp(unit * 5) + unit * 5  # 120 bp  \u2014 half inverted\n\nidx = SequenceIndex(k=8)\nidx.add_sequence('reference', seq_a)\nidx.add_sequence('shifted', seq_b)\nidx.add_sequence('partial_inv', seq_c)\n\nprint(f'Index: {idx}')\n</pre> # Helper to create a reverse complement def revcomp(seq):     table = str.maketrans('ACGTacgt', 'TGCAtgca')     return seq.translate(table)[::-1]   unit = 'ACGTACGTACGT'  # 12 bp repeat unit seq_a = unit * 10  # 120 bp  \u2014 the reference seq_b = 'T' + unit * 9 + 'T'  # 120 bp  \u2014 shifted by 1 seq_c = revcomp(unit * 5) + unit * 5  # 120 bp  \u2014 half inverted  idx = SequenceIndex(k=8) idx.add_sequence('reference', seq_a) idx.add_sequence('shifted', seq_b) idx.add_sequence('partial_inv', seq_c)  print(f'Index: {idx}') In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(idx)\n\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    all_vs_all_path = fh.name\n\nplotter.plot(\n    output_path=all_vs_all_path,\n    title='All vs All',\n)\nprint(f'Saved: {all_vs_all_path}  ({os.path.getsize(all_vs_all_path)} bytes)')\n</pre> plotter = DotPlotter(idx)  with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     all_vs_all_path = fh.name  plotter.plot(     output_path=all_vs_all_path,     title='All vs All', ) print(f'Saved: {all_vs_all_path}  ({os.path.getsize(all_vs_all_path)} bytes)') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    subset_path = fh.name\n\nplotter.plot(\n    query_names=['reference', 'shifted'],\n    target_names=['partial_inv'],\n    output_path=subset_path,\n    title='Reference &amp; Shifted vs Partial Inversion',\n)\nprint(f'Subset plot saved: {subset_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     subset_path = fh.name  plotter.plot(     query_names=['reference', 'shifted'],     target_names=['partial_inv'],     output_path=subset_path,     title='Reference &amp; Shifted vs Partial Inversion', ) print(f'Subset plot saved: {subset_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    single_path = fh.name\n\nplotter.plot_single(\n    query_name='reference',\n    target_name='shifted',\n    output_path=single_path,\n    figsize=(5, 5),\n    title='reference vs shifted',\n)\nprint(f'Single-pair plot saved: {single_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     single_path = fh.name  plotter.plot_single(     query_name='reference',     target_name='shifted',     output_path=single_path,     figsize=(5, 5),     title='reference vs shifted', ) print(f'Single-pair plot saved: {single_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    styled_path = fh.name\n\nplotter.plot(\n    output_path=styled_path,\n    dot_size=1.5,\n    dot_color='crimson',\n    dpi=200,\n    title='Custom style: crimson, dpi=200',\n)\nprint(f'Styled plot saved: {styled_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     styled_path = fh.name  plotter.plot(     output_path=styled_path,     dot_size=1.5,     dot_color='crimson',     dpi=200,     title='Custom style: crimson, dpi=200', ) print(f'Styled plot saved: {styled_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    unmerged_path = fh.name\n\nplotter.plot_single(\n    query_name='reference',\n    target_name='shifted',\n    output_path=unmerged_path,\n    merge=False,\n    title='reference vs shifted (unmerged k-mer hits)',\n)\nprint(f'Unmerged plot saved: {unmerged_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     unmerged_path = fh.name  plotter.plot_single(     query_name='reference',     target_name='shifted',     output_path=unmerged_path,     merge=False,     title='reference vs shifted (unmerged k-mer hits)', ) print(f'Unmerged plot saved: {unmerged_path}') In\u00a0[\u00a0]: Copied! <pre>for dpi in [72, 150, 300]:\n    with tempfile.NamedTemporaryFile(suffix=f'_dpi{dpi}.png', delete=False) as fh:\n        path = fh.name\n    plotter.plot_single(\n        'reference',\n        'shifted',\n        output_path=path,\n        dpi=dpi,\n        title=f'DPI = {dpi}',\n    )\n    size_kb = os.path.getsize(path) / 1024\n    print(f'DPI={dpi:4d}  file size={size_kb:.1f} kB  path={path}')\n</pre> for dpi in [72, 150, 300]:     with tempfile.NamedTemporaryFile(suffix=f'_dpi{dpi}.png', delete=False) as fh:         path = fh.name     plotter.plot_single(         'reference',         'shifted',         output_path=path,         dpi=dpi,         title=f'DPI = {dpi}',     )     size_kb = os.path.getsize(path) / 1024     print(f'DPI={dpi:4d}  file size={size_kb:.1f} kB  path={path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    large_path = fh.name\n\nplotter.plot(\n    output_path=large_path,\n    figsize_per_panel=6.0,  # each panel is 6\u00d76 inches\n    title='Large panels (6 inches each)',\n)\nprint(f'Large-panel plot saved: {large_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     large_path = fh.name  plotter.plot(     output_path=large_path,     figsize_per_panel=6.0,  # each panel is 6\u00d76 inches     title='Large panels (6 inches each)', ) print(f'Large-panel plot saved: {large_path}')"},{"location":"tutorials/dotplot_tutorial/#dotplot-visualization-tutorial","title":"Dotplot Visualization Tutorial\u00b6","text":"<p>This notebook explores all visualisation options provided by the <code>DotPlotter</code> class.</p> <p>A dot plot (or dotplot) is a classic bioinformatics visualisation that displays all shared subsequences between two sequences.  Each dot represents a shared k-mer; diagonal runs of dots indicate conserved regions.  Inversions appear as anti-diagonal lines.</p>"},{"location":"tutorials/dotplot_tutorial/#1-build-a-test-index","title":"1. Build a test index\u00b6","text":"<p>We create three artificial sequences with different overlap patterns:</p>"},{"location":"tutorials/dotplot_tutorial/#2-all-vs-all-dotplot-default-settings","title":"2. All-vs-all dotplot (default settings)\u00b6","text":"<p><code>DotPlotter.plot()</code> without arguments produces an all-vs-all grid using all sequences in the index.</p>"},{"location":"tutorials/dotplot_tutorial/#3-subset-specific-query-and-target-sets","title":"3. Subset: specific query and target sets\u00b6","text":"<p>Pass <code>query_names</code> and <code>target_names</code> to restrict the grid to a subset of sequences.</p>"},{"location":"tutorials/dotplot_tutorial/#4-single-pair-dotplot","title":"4. Single-pair dotplot\u00b6","text":"<p><code>plot_single</code> renders one comparison panel with its own figure size and title.</p>"},{"location":"tutorials/dotplot_tutorial/#5-customising-dot-appearance","title":"5. Customising dot appearance\u00b6","text":"<p>All plotting methods accept <code>dot_size</code> and <code>dot_color</code> to control the appearance of match lines.</p>"},{"location":"tutorials/dotplot_tutorial/#6-controlling-merge-behaviour","title":"6. Controlling merge behaviour\u00b6","text":"<p>When <code>merge=True</code> (default), consecutive co-linear k-mer hits are merged into single lines. Set <code>merge=False</code> to display every individual k-mer hit as its own point \u2014 useful for inspecting raw k-mer density.</p>"},{"location":"tutorials/dotplot_tutorial/#7-output-resolution","title":"7. Output resolution\u00b6","text":"<p>Use the <code>dpi</code> parameter to control the resolution of the saved image. Higher DPI is better for print-quality figures.</p>"},{"location":"tutorials/dotplot_tutorial/#8-panel-size-control","title":"8. Panel size control\u00b6","text":"<p>For all-vs-all grids, <code>figsize_per_panel</code> controls the size (in inches) of each subplot panel.</p>"},{"location":"tutorials/dotplot_tutorial/#summary-of-dotplotter-parameters","title":"Summary of DotPlotter parameters\u00b6","text":"Parameter Default Description <code>query_names</code> <code>None</code> List of query sequence names (rows); <code>None</code> = all <code>target_names</code> <code>None</code> List of target sequence names (columns); <code>None</code> = all <code>output_path</code> <code>\"dotplot.png\"</code> Output file path <code>figsize_per_panel</code> <code>4.0</code> Inches per subplot panel (all-vs-all only) <code>figsize</code> <code>(6, 6)</code> Total figure size for <code>plot_single</code> <code>dot_size</code> <code>0.5</code> Line/marker size for each match <code>dot_color</code> <code>\"blue\"</code> Colour of match lines <code>merge</code> <code>True</code> Merge co-linear k-mer runs into blocks <code>title</code> <code>None</code> Figure title <code>dpi</code> <code>150</code> Output image resolution"},{"location":"tutorials/minimap2_paf_tutorial/","title":"Visualising Minimap2 Alignments with rusty-dot","text":"In\u00a0[\u00a0]: Copied! <pre>import subprocess\nfrom pathlib import Path\n\nfrom rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\nfrom rusty_dot.paf_io import PafAlignment, PafRecord, parse_paf_file\n</pre> import subprocess from pathlib import Path  from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter from rusty_dot.paf_io import PafAlignment, PafRecord, parse_paf_file In\u00a0[\u00a0]: Copied! <pre># \u2500\u2500 Adjust these paths \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nQUERY_FASTA = 'genome_a.fasta'   # query assembly (rows in the dotplot)\nTARGET_FASTA = 'genome_b.fasta'  # target assembly (columns in the dotplot)\nPAF_OUTPUT = 'alignments.paf'\n# \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\ntry:\n    result = subprocess.run(\n        ['minimap2', '-x', 'asm5', '--cs', TARGET_FASTA, QUERY_FASTA],\n        capture_output=True,\n        text=True,\n        check=True,\n    )\n    Path(PAF_OUTPUT).write_text(result.stdout)\n    print(f'Alignment complete.  Wrote {len(result.stdout.splitlines())} records to {PAF_OUTPUT}')\nexcept (FileNotFoundError, subprocess.CalledProcessError) as exc:\n    print(f'minimap2 not available or alignment failed: {exc}')\n    print('Falling back to synthetic PAF data in Section 3.')\n    PAF_OUTPUT = None\n</pre> # \u2500\u2500 Adjust these paths \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 QUERY_FASTA = 'genome_a.fasta'   # query assembly (rows in the dotplot) TARGET_FASTA = 'genome_b.fasta'  # target assembly (columns in the dotplot) PAF_OUTPUT = 'alignments.paf' # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  try:     result = subprocess.run(         ['minimap2', '-x', 'asm5', '--cs', TARGET_FASTA, QUERY_FASTA],         capture_output=True,         text=True,         check=True,     )     Path(PAF_OUTPUT).write_text(result.stdout)     print(f'Alignment complete.  Wrote {len(result.stdout.splitlines())} records to {PAF_OUTPUT}') except (FileNotFoundError, subprocess.CalledProcessError) as exc:     print(f'minimap2 not available or alignment failed: {exc}')     print('Falling back to synthetic PAF data in Section 3.')     PAF_OUTPUT = None In\u00a0[\u00a0]: Copied! <pre>if PAF_OUTPUT and Path(PAF_OUTPUT).exists():\n    records = list(parse_paf_file(PAF_OUTPUT))\n    print(f'Loaded {len(records)} alignment records')\n    if records:\n        r = records[0]\n        print(f'  query: {r.query_name} ({r.query_len:,} bp)')\n        print(f'  target: {r.target_name} ({r.target_len:,} bp)')\n        print(f'  strand: {r.strand}')\n        if r.cigar:\n            print(f'  CIGAR-derived identity: {r.n_matches / max(r.alignment_length, 1):.2%}')\n</pre> if PAF_OUTPUT and Path(PAF_OUTPUT).exists():     records = list(parse_paf_file(PAF_OUTPUT))     print(f'Loaded {len(records)} alignment records')     if records:         r = records[0]         print(f'  query: {r.query_name} ({r.query_len:,} bp)')         print(f'  target: {r.target_name} ({r.target_len:,} bp)')         print(f'  strand: {r.strand}')         if r.cigar:             print(f'  CIGAR-derived identity: {r.n_matches / max(r.alignment_length, 1):.2%}') In\u00a0[\u00a0]: Copied! <pre>SYNTHETIC_PAF = \"\"\"\\\ncontigA1\\t200\\t0\\t180\\t+\\tcontigB1\\t160\\t0\\t160\\t155\\t160\\t60\ncontigA2\\t100\\t10\\t90\\t+\\tcontigB2\\t80\\t5\\t75\\t65\\t70\\t60\ncontigA1\\t200\\t50\\t120\\t-\\tcontigB2\\t80\\t0\\t70\\t65\\t70\\t30\n\"\"\"\n\nPAF_FILE = '/tmp/synthetic_alignments.paf'\nwith open(PAF_FILE, 'w') as fh:\n    fh.write(SYNTHETIC_PAF)\n\nif PAF_OUTPUT is None:\n    PAF_OUTPUT = PAF_FILE\n\nprint(f'Using PAF file: {PAF_OUTPUT}')\n</pre> SYNTHETIC_PAF = \"\"\"\\ contigA1\\t200\\t0\\t180\\t+\\tcontigB1\\t160\\t0\\t160\\t155\\t160\\t60 contigA2\\t100\\t10\\t90\\t+\\tcontigB2\\t80\\t5\\t75\\t65\\t70\\t60 contigA1\\t200\\t50\\t120\\t-\\tcontigB2\\t80\\t0\\t70\\t65\\t70\\t30 \"\"\"  PAF_FILE = '/tmp/synthetic_alignments.paf' with open(PAF_FILE, 'w') as fh:     fh.write(SYNTHETIC_PAF)  if PAF_OUTPUT is None:     PAF_OUTPUT = PAF_FILE  print(f'Using PAF file: {PAF_OUTPUT}') In\u00a0[\u00a0]: Copied! <pre>aln = PafAlignment.from_file(PAF_OUTPUT)\nprint(aln)\n\nq_sorted, t_sorted = aln.reorder_contigs()\nprint('Sorted query contigs:', q_sorted)\nprint('Sorted target contigs:', t_sorted)\n</pre> aln = PafAlignment.from_file(PAF_OUTPUT) print(aln)  q_sorted, t_sorted = aln.reorder_contigs() print('Sorted query contigs:', q_sorted) print('Sorted target contigs:', t_sorted) In\u00a0[\u00a0]: Copied! <pre># Build a mapping of sequence name -&gt; length from the PAF records\nseq_lens = {}\nfor rec in aln.records:\n    seq_lens[rec.query_name] = rec.query_len\n    seq_lens[rec.target_name] = rec.target_len\n\n# Create synthetic sequences of the correct length for illustration\nimport random, string\nrandom.seed(42)\nBASES = 'ACGT'\n\nidx = SequenceIndex(k=10)\nfor name, length in seq_lens.items():\n    seq = ''.join(random.choices(BASES, k=length))\n    idx.add_sequence(name, seq)\n\nprint(idx)\n</pre> # Build a mapping of sequence name -&gt; length from the PAF records seq_lens = {} for rec in aln.records:     seq_lens[rec.query_name] = rec.query_len     seq_lens[rec.target_name] = rec.target_len  # Create synthetic sequences of the correct length for illustration import random, string random.seed(42) BASES = 'ACGT'  idx = SequenceIndex(k=10) for name, length in seq_lens.items():     seq = ''.join(random.choices(BASES, k=length))     idx.add_sequence(name, seq)  print(idx) In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(idx)\n\n# Use the sorted contig order; scale panels by sequence length\nplot_q = [n for n in q_sorted if n in seq_lens]\nplot_t = [n for n in t_sorted if n in seq_lens]\n\nplotter.plot(\n    query_names=plot_q or list(seq_lens.keys()),\n    target_names=plot_t or list(seq_lens.keys()),\n    output_path='/tmp/minimap2_dotplot.png',\n    figsize_per_panel=4.0,\n    scale_sequences=True,\n    title='Minimap2 alignment \u2014 sorted contigs',\n    dpi=100,\n)\n\nfrom IPython.display import Image\nImage('/tmp/minimap2_dotplot.png')\n</pre> plotter = DotPlotter(idx)  # Use the sorted contig order; scale panels by sequence length plot_q = [n for n in q_sorted if n in seq_lens] plot_t = [n for n in t_sorted if n in seq_lens]  plotter.plot(     query_names=plot_q or list(seq_lens.keys()),     target_names=plot_t or list(seq_lens.keys()),     output_path='/tmp/minimap2_dotplot.png',     figsize_per_panel=4.0,     scale_sequences=True,     title='Minimap2 alignment \u2014 sorted contigs',     dpi=100, )  from IPython.display import Image Image('/tmp/minimap2_dotplot.png')"},{"location":"tutorials/minimap2_paf_tutorial/#visualising-minimap2-alignments-with-rusty-dot","title":"Visualising Minimap2 Alignments with rusty-dot\u00b6","text":"<p>This tutorial shows how to align two genome assemblies with minimap2 and visualise the output PAF file as an all-vs-all dotplot using rusty-dot.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#prerequisites","title":"Prerequisites\u00b6","text":"<ul> <li>minimap2 installed and available on <code>PATH</code></li> <li>Two FASTA files to compare (e.g. two assemblies, or one assembly aligned to a reference)</li> </ul>"},{"location":"tutorials/minimap2_paf_tutorial/#workflow","title":"Workflow\u00b6","text":"<ol> <li>Align assemblies with minimap2 to produce a PAF file.</li> <li>Load the PAF file with <code>PafAlignment.from_file()</code>.</li> <li>Optionally reorder contigs for maximum collinearity.</li> <li>Build a <code>SequenceIndex</code> for dot-plot rendering and plot.</li> </ol>"},{"location":"tutorials/minimap2_paf_tutorial/#1-align-two-assemblies-with-minimap2","title":"1. Align two assemblies with minimap2\u00b6","text":"<p>Replace the paths below with your own FASTA files.  The <code>asm5</code> preset is suitable for comparing assemblies with &lt; 5% divergence.</p> <pre>minimap2 -x asm5 --cs genome_b.fasta genome_a.fasta &gt; alignments.paf\n</pre> <p>The cell below runs minimap2 programmatically.  If minimap2 is not available, skip to Section 3 where we create synthetic PAF data.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#2-inspect-cigar-statistics-optional","title":"2. Inspect CIGAR statistics (optional)\u00b6","text":"<p>When minimap2 is run with <code>--cs</code> the PAF file contains <code>cg:Z:</code> CIGAR tags.  <code>PafRecord</code> parses these automatically.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#3-synthetic-example-minimap2-not-available","title":"3. Synthetic example (minimap2 not available)\u00b6","text":"<p>If minimap2 is not installed we create a small synthetic PAF file that mirrors what minimap2 would produce.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#4-load-paf-and-reorder-contigs-for-maximum-collinearity","title":"4. Load PAF and reorder contigs for maximum collinearity\u00b6","text":"<p><code>PafAlignment.reorder_contigs()</code> uses a gravity-centre algorithm to sort contigs so the dotplot shows maximum collinearity along the diagonal.  Unmatched contigs are placed at the end, sorted by descending length.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#5-build-a-sequenceindex-and-plot","title":"5. Build a SequenceIndex and plot\u00b6","text":"<p>We need a <code>SequenceIndex</code> to render the dotplot.  Here we add synthetic sequences whose lengths match the records in the PAF file.</p> <p>Tip: For real data, use <code>idx.load_fasta('genome_a.fasta')</code> and <code>idx.load_fasta('genome_b.fasta')</code> instead.</p>"},{"location":"tutorials/minimap2_paf_tutorial/#summary","title":"Summary\u00b6","text":"Step Tool Purpose Align <code>minimap2 -x asm5</code> Generate PAF alignments Load <code>PafAlignment.from_file()</code> Parse PAF records Sort <code>aln.reorder_contigs()</code> Maximise collinearity Index <code>SequenceIndex.load_fasta()</code> Build k-mer index for rendering Plot <code>DotPlotter.plot(scale_sequences=True)</code> Visualise with relative scaling <p>The <code>scale_sequences=True</code> option ensures each subplot's dimensions are proportional to the actual lengths of the compared sequences, so short and long contigs are not artificially stretched to the same size.</p>"},{"location":"tutorials/paf_workflow/","title":"PAF Workflow Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import tempfile\nimport os\n\nfrom rusty_dot import SequenceIndex, py_coords_to_paf\nfrom rusty_dot.paf_io import (\n    PafRecord,\n    PafAlignment,\n    parse_paf_file,\n)\n</pre> import tempfile import os  from rusty_dot import SequenceIndex, py_coords_to_paf from rusty_dot.paf_io import (     PafRecord,     PafAlignment,     parse_paf_file, ) In\u00a0[\u00a0]: Copied! <pre># Build a small index\nidx = SequenceIndex(k=10)\nunit = 'ACGTACGTACGT'\nidx.add_sequence('query', unit * 8)  # 96 bp\nidx.add_sequence('target', ('T' + unit * 7 + 'T'))  # 98 bp\n\n# Get PAF lines\npaf_lines = idx.get_paf('query', 'target', merge=True)\nprint(f'Generated {len(paf_lines)} PAF lines')\nprint('\\nPAF columns (first record):')\ncol_names = [\n    'query_name',\n    'query_len',\n    'query_start',\n    'query_end',\n    'strand',\n    'target_name',\n    'target_len',\n    'target_start',\n    'target_end',\n    'residue_matches',\n    'block_len',\n    'mapq',\n]\nif paf_lines:\n    for col, val in zip(col_names, paf_lines[0].split('\\t')):\n        print(f'  {col:20s}: {val}')\n</pre> # Build a small index idx = SequenceIndex(k=10) unit = 'ACGTACGTACGT' idx.add_sequence('query', unit * 8)  # 96 bp idx.add_sequence('target', ('T' + unit * 7 + 'T'))  # 98 bp  # Get PAF lines paf_lines = idx.get_paf('query', 'target', merge=True) print(f'Generated {len(paf_lines)} PAF lines') print('\\nPAF columns (first record):') col_names = [     'query_name',     'query_len',     'query_start',     'query_end',     'strand',     'target_name',     'target_len',     'target_start',     'target_end',     'residue_matches',     'block_len',     'mapq', ] if paf_lines:     for col, val in zip(col_names, paf_lines[0].split('\\t')):         print(f'  {col:20s}: {val}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    paf_path = fh.name\n    for line in paf_lines:\n        fh.write(line + '\\n')\n\nprint(f'PAF file written: {paf_path}')\nprint(f'File size: {os.path.getsize(paf_path)} bytes')\n</pre> with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     paf_path = fh.name     for line in paf_lines:         fh.write(line + '\\n')  print(f'PAF file written: {paf_path}') print(f'File size: {os.path.getsize(paf_path)} bytes') In\u00a0[\u00a0]: Copied! <pre>records = list(parse_paf_file(paf_path))\nprint(f'Loaded {len(records)} records')\n\nif records:\n    rec = records[0]\n    print('\\nFirst record:')\n    print(\n        f'  query:   {rec.query_name}  [{rec.query_start}-{rec.query_end}]  len={rec.query_len}'\n    )\n    print(\n        f'  target:  {rec.target_name}  [{rec.target_start}-{rec.target_end}]  len={rec.target_len}'\n    )\n    print(f'  strand:  {rec.strand}')\n    print(f'  matches: {rec.residue_matches}')\n    print(f'  q_aligned_len: {rec.query_aligned_len}')\n    print(f'  t_aligned_len: {rec.target_aligned_len}')\n</pre> records = list(parse_paf_file(paf_path)) print(f'Loaded {len(records)} records')  if records:     rec = records[0]     print('\\nFirst record:')     print(         f'  query:   {rec.query_name}  [{rec.query_start}-{rec.query_end}]  len={rec.query_len}'     )     print(         f'  target:  {rec.target_name}  [{rec.target_start}-{rec.target_end}]  len={rec.target_len}'     )     print(f'  strand:  {rec.strand}')     print(f'  matches: {rec.residue_matches}')     print(f'  q_aligned_len: {rec.query_aligned_len}')     print(f'  t_aligned_len: {rec.target_aligned_len}') In\u00a0[\u00a0]: Copied! <pre>line = 'query\\t96\\t5\\t90\\t+\\ttarget\\t98\\t5\\t90\\t80\\t85\\t255\\ttp:A:P\\tcg:Z:10=5X20=3I30='\nrec = PafRecord.from_line(line)\n\nprint('Parsed PafRecord:')\nprint(f'  cigar:            {rec.cigar}')\nprint(f'  alignment_length: {rec.alignment_length}')\nprint(f'  n_matches:        {rec.n_matches}')\nprint(f'  n_mismatches:     {rec.n_mismatches}')\nprint(f'  n_gaps:           {rec.n_gaps}')\nprint(f'  n_gap_bases:      {rec.n_gap_bases}')\nprint(f'  tags:             {rec.tags}')\n</pre> line = 'query\\t96\\t5\\t90\\t+\\ttarget\\t98\\t5\\t90\\t80\\t85\\t255\\ttp:A:P\\tcg:Z:10=5X20=3I30=' rec = PafRecord.from_line(line)  print('Parsed PafRecord:') print(f'  cigar:            {rec.cigar}') print(f'  alignment_length: {rec.alignment_length}') print(f'  n_matches:        {rec.n_matches}') print(f'  n_mismatches:     {rec.n_mismatches}') print(f'  n_gaps:           {rec.n_gaps}') print(f'  n_gap_bases:      {rec.n_gap_bases}') print(f'  tags:             {rec.tags}') In\u00a0[\u00a0]: Copied! <pre>print(rec.to_line())\n</pre> print(rec.to_line()) In\u00a0[\u00a0]: Copied! <pre># Load from the PAF file we created earlier\naln = PafAlignment.from_file(paf_path)\nprint(aln)\nprint(f'Query names:  {aln.query_names}')\nprint(f'Target names: {aln.target_names}')\n</pre> # Load from the PAF file we created earlier aln = PafAlignment.from_file(paf_path) print(aln) print(f'Query names:  {aln.query_names}') print(f'Target names: {aln.target_names}') In\u00a0[\u00a0]: Copied! <pre># Construct from a list of records\naln2 = PafAlignment.from_records(records)\nprint(f'from_records: {aln2}')\n</pre> # Construct from a list of records aln2 = PafAlignment.from_records(records) print(f'from_records: {aln2}') In\u00a0[\u00a0]: Copied! <pre># Filter to a specific query\nfiltered_q = aln.filter_by_query(['query'])\nprint(f\"filter_by_query(['query']): {filtered_q}\")\n\n# Filter to a specific target\nfiltered_t = aln.filter_by_target(['target'])\nprint(f\"filter_by_target(['target']): {filtered_t}\")\n</pre> # Filter to a specific query filtered_q = aln.filter_by_query(['query']) print(f\"filter_by_query(['query']): {filtered_q}\")  # Filter to a specific target filtered_t = aln.filter_by_target(['target']) print(f\"filter_by_target(['target']): {filtered_t}\") In\u00a0[\u00a0]: Copied! <pre># Build a multi-contig index to demonstrate reordering\nidx_multi = SequenceIndex(k=8)\nunit = 'ACGTACGTACGT'\nidx_multi.add_sequence('qA', unit * 5)\nidx_multi.add_sequence('qB', 'GCGCGCGCGCGCGCGCGCGC' * 3)\nidx_multi.add_sequence('tA', unit * 5)\nidx_multi.add_sequence('tB', ('T' + unit) * 4)\n\n# Write all-vs-all PAF\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    multi_paf_path = fh.name\n    for q in ['qA', 'qB']:\n        for t in ['tA', 'tB']:\n            for line in idx_multi.get_paf(q, t):\n                fh.write(line + '\\n')\n\naln_multi = PafAlignment.from_file(multi_paf_path)\nprint(f'Multi-contig alignment: {aln_multi}')\n\nq_sorted, t_sorted = aln_multi.reorder_contigs(\n    query_names=['qA', 'qB'],\n    target_names=['tA', 'tB'],\n)\nprint(f'Reordered queries:  {q_sorted}')\nprint(f'Reordered targets:  {t_sorted}')\n</pre> # Build a multi-contig index to demonstrate reordering idx_multi = SequenceIndex(k=8) unit = 'ACGTACGTACGT' idx_multi.add_sequence('qA', unit * 5) idx_multi.add_sequence('qB', 'GCGCGCGCGCGCGCGCGCGC' * 3) idx_multi.add_sequence('tA', unit * 5) idx_multi.add_sequence('tB', ('T' + unit) * 4)  # Write all-vs-all PAF with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     multi_paf_path = fh.name     for q in ['qA', 'qB']:         for t in ['tA', 'tB']:             for line in idx_multi.get_paf(q, t):                 fh.write(line + '\\n')  aln_multi = PafAlignment.from_file(multi_paf_path) print(f'Multi-contig alignment: {aln_multi}')  q_sorted, t_sorted = aln_multi.reorder_contigs(     query_names=['qA', 'qB'],     target_names=['tA', 'tB'], ) print(f'Reordered queries:  {q_sorted}') print(f'Reordered targets:  {t_sorted}') In\u00a0[\u00a0]: Copied! <pre>matches = [\n    (0, 50, 10, 60),\n    (55, 90, 65, 100),\n]\n\npaf_strings = py_coords_to_paf(\n    matches,\n    query_name='my_query',\n    query_len=100,\n    target_name='my_target',\n    target_len=120,\n)\n\nfor line in paf_strings:\n    print(line)\n</pre> matches = [     (0, 50, 10, 60),     (55, 90, 65, 100), ]  paf_strings = py_coords_to_paf(     matches,     query_name='my_query',     query_len=100,     target_name='my_target',     target_len=120, )  for line in paf_strings:     print(line) In\u00a0[\u00a0]: Copied! <pre># Pre-compute to populate the cache\nidx_multi.precompute_all_pairs(merge=True)\n\nq_order, t_order = idx_multi.optimal_contig_order(\n    query_names=['qA', 'qB'],\n    target_names=['tA', 'tB'],\n)\nprint(f'Optimal query order:  {q_order}')\nprint(f'Optimal target order: {t_order}')\n</pre> # Pre-compute to populate the cache idx_multi.precompute_all_pairs(merge=True)  q_order, t_order = idx_multi.optimal_contig_order(     query_names=['qA', 'qB'],     target_names=['tA', 'tB'], ) print(f'Optimal query order:  {q_order}') print(f'Optimal target order: {t_order}')"},{"location":"tutorials/paf_workflow/#paf-workflow-tutorial","title":"PAF Workflow Tutorial\u00b6","text":"<p>This notebook demonstrates the full PAF (Pairwise mApping Format) workflow in rusty-dot:</p> <ol> <li>Generating PAF output from a <code>SequenceIndex</code></li> <li>Writing PAF output to a file</li> <li>Reading PAF files back with <code>parse_paf_file</code> and <code>PafAlignment</code></li> <li>Parsing CIGAR strings for alignment statistics</li> <li>Filtering and reordering contigs with <code>PafAlignment.reorder_contigs</code></li> <li>Using the low-level <code>py_coords_to_paf</code> function</li> </ol> <p>PAF is a tab-separated, 12-column format used by many alignment tools.  It is the primary output format of rusty-dot.</p>"},{"location":"tutorials/paf_workflow/#1-generate-paf-output-from-a-sequenceindex","title":"1. Generate PAF output from a SequenceIndex\u00b6","text":"<p>The easiest way to produce PAF lines is <code>SequenceIndex.get_paf</code>.</p>"},{"location":"tutorials/paf_workflow/#2-write-paf-to-a-file","title":"2. Write PAF to a file\u00b6","text":"<p>PAF is a plain text format \u2014 just write each line with a newline.</p>"},{"location":"tutorials/paf_workflow/#3-read-a-paf-file-with-parse_paf_file","title":"3. Read a PAF file with parse_paf_file\u00b6","text":"<p><code>parse_paf_file</code> is a generator that yields <code>PafRecord</code> objects one at a time. Comment lines (starting with <code>#</code>) and blank lines are skipped.</p>"},{"location":"tutorials/paf_workflow/#4-parsing-a-paf-record-from-a-string","title":"4. Parsing a PAF record from a string\u00b6","text":"<p><code>PafRecord.from_line</code> parses a single PAF line string.</p>"},{"location":"tutorials/paf_workflow/#5-serialise-a-pafrecord-back-to-a-string","title":"5. Serialise a PafRecord back to a string\u00b6","text":"<p><code>to_line()</code> recreates the 12-column PAF string (tags are not re-emitted).</p>"},{"location":"tutorials/paf_workflow/#6-pafalignment-collection-with-contig-reordering","title":"6. PafAlignment \u2014 collection with contig reordering\u00b6","text":"<p><code>PafAlignment</code> wraps a list of <code>PafRecord</code> objects and provides filtering and gravity-based contig reordering.</p>"},{"location":"tutorials/paf_workflow/#filtering","title":"Filtering\u00b6","text":""},{"location":"tutorials/paf_workflow/#gravity-based-contig-reordering","title":"Gravity-based contig reordering\u00b6","text":"<p><code>reorder_contigs</code> sorts query and target names so that a subsequent dotplot shows maximum collinearity.  Each contig is assigned a gravity equal to the weighted mean position of its alignment blocks on the opposing axis.</p>"},{"location":"tutorials/paf_workflow/#7-low-level-py_coords_to_paf","title":"7. Low-level: py_coords_to_paf\u00b6","text":"<p><code>py_coords_to_paf</code> converts raw coordinate tuples to PAF strings without going through a <code>SequenceIndex</code>.  It is useful when you have coordinate data from another source.</p>"},{"location":"tutorials/paf_workflow/#8-using-sequenceindexoptimal_contig_order","title":"8. Using SequenceIndex.optimal_contig_order\u00b6","text":"<p>The <code>SequenceIndex</code> also exposes a built-in gravity-based ordering via <code>optimal_contig_order</code>, which uses the cached comparison results.</p>"},{"location":"tutorials/paf_workflow/#summary","title":"Summary\u00b6","text":"Task API Generate PAF lines <code>SequenceIndex.get_paf(query, target)</code> Parse a PAF file <code>parse_paf_file(path)</code> or <code>PafAlignment.from_file(path)</code> Parse a single line <code>PafRecord.from_line(line)</code> Serialise a record <code>PafRecord.to_line()</code> Filter records <code>PafAlignment.filter_by_query(names)</code> / <code>filter_by_target(names)</code> Reorder contigs <code>PafAlignment.reorder_contigs()</code> or <code>SequenceIndex.optimal_contig_order()</code> Convert coords to PAF <code>py_coords_to_paf(matches, ...)</code>"},{"location":"tutorials/quickstart/","title":"Quick Start Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n\nprint('rusty-dot imported successfully')\n</pre> from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter  print('rusty-dot imported successfully') In\u00a0[\u00a0]: Copied! <pre># Create an index with k=10\nidx = SequenceIndex(k=10)\nprint(idx)  # SequenceIndex(k=10, sequences=0)\n</pre> # Create an index with k=10 idx = SequenceIndex(k=10) print(idx)  # SequenceIndex(k=10, sequences=0) In\u00a0[\u00a0]: Copied! <pre># Two sequences with a shared region\nseq_a = 'ACGTACGTACGTACGTACGT' * 5  # 100 bp\nseq_b = 'TACGTACGTACGTACGTACG' * 5  # 100 bp (shifted by 1 bp)\nseq_c = 'GCGCGCGCGCGCGCGCGCGC' * 5  # 100 bp (different content)\n\nidx.add_sequence('seq_a', seq_a)\nidx.add_sequence('seq_b', seq_b)\nidx.add_sequence('seq_c', seq_c)\n\nprint(f'Indexed sequences: {idx.sequence_names()}')\nprint(f'Total sequences: {len(idx)}')\n</pre> # Two sequences with a shared region seq_a = 'ACGTACGTACGTACGTACGT' * 5  # 100 bp seq_b = 'TACGTACGTACGTACGTACG' * 5  # 100 bp (shifted by 1 bp) seq_c = 'GCGCGCGCGCGCGCGCGCGC' * 5  # 100 bp (different content)  idx.add_sequence('seq_a', seq_a) idx.add_sequence('seq_b', seq_b) idx.add_sequence('seq_c', seq_c)  print(f'Indexed sequences: {idx.sequence_names()}') print(f'Total sequences: {len(idx)}') In\u00a0[\u00a0]: Copied! <pre># How many unique 10-mers does each sequence have?\nfor name in idx.sequence_names():\n    kset = idx.get_kmer_set(name)\n    print(\n        f'{name}: {len(kset)} unique k-mers, length={idx.get_sequence_length(name)} bp'\n    )\n</pre> # How many unique 10-mers does each sequence have? for name in idx.sequence_names():     kset = idx.get_kmer_set(name)     print(         f'{name}: {len(kset)} unique k-mers, length={idx.get_sequence_length(name)} bp'     ) In\u00a0[\u00a0]: Copied! <pre>matches = idx.compare_sequences('seq_a', 'seq_b', merge=True)\nprint(f'seq_a vs seq_b: {len(matches)} match blocks')\nfor m in matches[:5]:\n    q_start, q_end, t_start, t_end = m\n    print(\n        f'  query [{q_start}-{q_end}]  target [{t_start}-{t_end}]  length={q_end - q_start}'\n    )\n</pre> matches = idx.compare_sequences('seq_a', 'seq_b', merge=True) print(f'seq_a vs seq_b: {len(matches)} match blocks') for m in matches[:5]:     q_start, q_end, t_start, t_end = m     print(         f'  query [{q_start}-{q_end}]  target [{t_start}-{t_end}]  length={q_end - q_start}'     ) In\u00a0[\u00a0]: Copied! <pre># Fewer matches between unrelated sequences\nmatches_ac = idx.compare_sequences('seq_a', 'seq_c', merge=True)\nprint(f'seq_a vs seq_c: {len(matches_ac)} match blocks')\n</pre> # Fewer matches between unrelated sequences matches_ac = idx.compare_sequences('seq_a', 'seq_c', merge=True) print(f'seq_a vs seq_c: {len(matches_ac)} match blocks') In\u00a0[\u00a0]: Copied! <pre>stranded = idx.compare_sequences_stranded('seq_a', 'seq_b', merge=True)\nfwd = [m for m in stranded if m[4] == '+']\nrev = [m for m in stranded if m[4] == '-']\nprint(f'Forward matches: {len(fwd)}, Reverse-complement matches: {len(rev)}')\n</pre> stranded = idx.compare_sequences_stranded('seq_a', 'seq_b', merge=True) fwd = [m for m in stranded if m[4] == '+'] rev = [m for m in stranded if m[4] == '-'] print(f'Forward matches: {len(fwd)}, Reverse-complement matches: {len(rev)}') In\u00a0[\u00a0]: Copied! <pre>paf_lines = idx.get_paf('seq_a', 'seq_b', merge=True)\nprint(f'PAF lines: {len(paf_lines)}')\nprint('\\nFirst PAF line:')\nif paf_lines:\n    fields = paf_lines[0].split('\\t')\n    labels = [\n        'query',\n        'q_len',\n        'q_start',\n        'q_end',\n        'strand',\n        'target',\n        't_len',\n        't_start',\n        't_end',\n        'matches',\n        'block_len',\n        'mapq',\n    ]\n    for label, value in zip(labels, fields):\n        print(f'  {label:12s}: {value}')\n</pre> paf_lines = idx.get_paf('seq_a', 'seq_b', merge=True) print(f'PAF lines: {len(paf_lines)}') print('\\nFirst PAF line:') if paf_lines:     fields = paf_lines[0].split('\\t')     labels = [         'query',         'q_len',         'q_start',         'q_end',         'strand',         'target',         't_len',         't_start',         't_end',         'matches',         'block_len',         'mapq',     ]     for label, value in zip(labels, fields):         print(f'  {label:12s}: {value}') In\u00a0[\u00a0]: Copied! <pre># Save PAF output to a file\nimport tempfile\nimport os\n\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    paf_path = fh.name\n    for line in paf_lines:\n        fh.write(line + '\\n')\n\nprint(f'PAF saved to: {paf_path}')\nprint(f'File size: {os.path.getsize(paf_path)} bytes')\n</pre> # Save PAF output to a file import tempfile import os  with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     paf_path = fh.name     for line in paf_lines:         fh.write(line + '\\n')  print(f'PAF saved to: {paf_path}') print(f'File size: {os.path.getsize(paf_path)} bytes') In\u00a0[\u00a0]: Copied! <pre>import tempfile\nimport gzip\n\nfasta_content = '&gt;seq1\\nACGTACGTACGTACGTACGT\\n&gt;seq2\\nTACGTACGTACGTACGTACG\\n'\n\n# Plain FASTA\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.fasta', delete=False) as fh:\n    fh.write(fasta_content)\n    plain_path = fh.name\n\n# Gzipped FASTA\nwith tempfile.NamedTemporaryFile(suffix='.fasta.gz', delete=False) as fh:\n    gz_path = fh.name\nwith gzip.open(gz_path, 'wt') as fh:\n    fh.write(fasta_content)\n\n# Load into a fresh index\nidx2 = SequenceIndex(k=10)\nnames = idx2.load_fasta(plain_path)\nprint(f'Loaded from plain FASTA: {names}')\n\nidx3 = SequenceIndex(k=10)\nnames_gz = idx3.load_fasta(gz_path)\nprint(f'Loaded from gzipped FASTA: {names_gz}')\n</pre> import tempfile import gzip  fasta_content = '&gt;seq1\\nACGTACGTACGTACGTACGT\\n&gt;seq2\\nTACGTACGTACGTACGTACG\\n'  # Plain FASTA with tempfile.NamedTemporaryFile(mode='w', suffix='.fasta', delete=False) as fh:     fh.write(fasta_content)     plain_path = fh.name  # Gzipped FASTA with tempfile.NamedTemporaryFile(suffix='.fasta.gz', delete=False) as fh:     gz_path = fh.name with gzip.open(gz_path, 'wt') as fh:     fh.write(fasta_content)  # Load into a fresh index idx2 = SequenceIndex(k=10) names = idx2.load_fasta(plain_path) print(f'Loaded from plain FASTA: {names}')  idx3 = SequenceIndex(k=10) names_gz = idx3.load_fasta(gz_path) print(f'Loaded from gzipped FASTA: {names_gz}') In\u00a0[\u00a0]: Copied! <pre>import tempfile\n\n# Save\nwith tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as fh:\n    idx_path = fh.name\n\nidx.save(idx_path)\nprint(f'Index saved to: {idx_path}')\nprint(f'File size: {os.path.getsize(idx_path)} bytes')\n\n# Load into a new index (k must match)\nidx_loaded = SequenceIndex(k=10)\nidx_loaded.load(idx_path)\nprint(f'Loaded index: {idx_loaded}')\nprint(f'Sequences: {idx_loaded.sequence_names()}')\n</pre> import tempfile  # Save with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as fh:     idx_path = fh.name  idx.save(idx_path) print(f'Index saved to: {idx_path}') print(f'File size: {os.path.getsize(idx_path)} bytes')  # Load into a new index (k must match) idx_loaded = SequenceIndex(k=10) idx_loaded.load(idx_path) print(f'Loaded index: {idx_loaded}') print(f'Sequences: {idx_loaded.sequence_names()}') In\u00a0[\u00a0]: Copied! <pre>pairs = idx.precompute_all_pairs(merge=True)\nprint(f'Pre-computed {len(pairs)} pairs:')\nfor q, t in pairs:\n    print(f'  {q} vs {t}')\n</pre> pairs = idx.precompute_all_pairs(merge=True) print(f'Pre-computed {len(pairs)} pairs:') for q, t in pairs:     print(f'  {q} vs {t}') In\u00a0[\u00a0]: Copied! <pre>import tempfile\n\nplotter = DotPlotter(idx)\n\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    out_path = fh.name\n\nplotter.plot(output_path=out_path, title='Quick Start Dotplot')\nprint(f'Dotplot saved to: {out_path}')\n</pre> import tempfile  plotter = DotPlotter(idx)  with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     out_path = fh.name  plotter.plot(output_path=out_path, title='Quick Start Dotplot') print(f'Dotplot saved to: {out_path}')"},{"location":"tutorials/quickstart/#quick-start-tutorial","title":"Quick Start Tutorial\u00b6","text":"<p>This notebook demonstrates the core workflow of rusty-dot: building a sequence index, finding shared k-mer matches, generating PAF-format alignments, and visualising results as a dotplot.</p>"},{"location":"tutorials/quickstart/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Install rusty-dot following the Installation guide, then run:</p> <pre>pip install jupyter\n</pre>"},{"location":"tutorials/quickstart/#1-import-the-package","title":"1. Import the package\u00b6","text":""},{"location":"tutorials/quickstart/#2-build-a-sequenceindex","title":"2. Build a SequenceIndex\u00b6","text":"<p><code>SequenceIndex</code> is the core class.  You supply the k-mer length <code>k</code> at construction time. A larger <code>k</code> reduces spurious matches but may miss shorter conserved regions.</p>"},{"location":"tutorials/quickstart/#3-add-sequences-directly","title":"3. Add sequences directly\u00b6","text":"<p>Use <code>add_sequence(name, seq)</code> to add individual sequences. These are stored in-memory and indexed immediately.</p>"},{"location":"tutorials/quickstart/#4-query-the-index","title":"4. Query the index\u00b6","text":""},{"location":"tutorials/quickstart/#4a-inspect-k-mer-sets","title":"4a. Inspect k-mer sets\u00b6","text":""},{"location":"tutorials/quickstart/#4b-find-shared-k-mer-matches","title":"4b. Find shared k-mer matches\u00b6","text":"<p><code>compare_sequences</code> intersects the k-mer sets and returns <code>(query_start, query_end, target_start, target_end)</code> tuples.</p>"},{"location":"tutorials/quickstart/#4c-stranded-matches","title":"4c. Stranded matches\u00b6","text":"<p><code>compare_sequences_stranded</code> additionally searches for reverse-complement matches, returning a 5-tuple <code>(q_start, q_end, t_start, t_end, strand)</code> where strand is <code>\"+\"</code> or <code>\"-\"</code>.</p>"},{"location":"tutorials/quickstart/#5-paf-output","title":"5. PAF output\u00b6","text":"<p>PAF (Pairwise mApping Format) is a standard tab-separated format for alignment records. <code>get_paf</code> returns a list of 12-column PAF strings.</p>"},{"location":"tutorials/quickstart/#6-load-from-fasta-files","title":"6. Load from FASTA files\u00b6","text":"<p><code>load_fasta</code> reads plain or gzipped FASTA files with automatic format detection.</p>"},{"location":"tutorials/quickstart/#7-save-and-load-the-index","title":"7. Save and load the index\u00b6","text":"<p>Indexes can be serialised to disk and reloaded, avoiding the need to reprocess large FASTA files.</p>"},{"location":"tutorials/quickstart/#8-pre-compute-all-pairs","title":"8. Pre-compute all pairs\u00b6","text":"<p>For repeated queries over the same dataset, <code>precompute_all_pairs</code> fills the result cache for every ordered <code>(i, j)</code> pair in one go.</p>"},{"location":"tutorials/quickstart/#9-simple-dotplot","title":"9. Simple dotplot\u00b6","text":"<p>The <code>DotPlotter</code> class wraps the index to generate publication-ready dotplot images. See the Dotplot Visualization tutorial for full details.</p>"},{"location":"tutorials/quickstart/#next-steps","title":"Next steps\u00b6","text":"<ul> <li>Dotplot Visualization tutorial \u2014 all plot customisation options.</li> <li>PAF Workflow tutorial \u2014 loading PAF files, CIGAR parsing, and contig reordering.</li> <li>API Reference \u2014 complete documentation for every class and function.</li> </ul>"}]}
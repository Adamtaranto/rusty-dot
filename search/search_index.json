{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"rusty-dot","text":"<p>rusty-dot is a Rust + PyO3 tool for making fast dot plot comparisons of DNA sequences using a Rust FM-Index.</p>"},{"location":"#overview","title":"Overview","text":"<p>rusty-dot provides a high-performance toolkit for pairwise DNA sequence comparison and visualisation. At its core, it builds an FM-index (via rust-bio) for each sequence and uses k-mer set intersection to efficiently find shared subsequences between any two sequences in the collection.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Fast FM-index construction via Rust + PyO3 bindings</li> <li>Read FASTA / gzipped FASTA files via needletail</li> <li>Build FM-indexes per sequence using rust-bio</li> <li>K-mer set intersection for efficient shared k-mer lookup</li> <li>Merge sequential k-mer runs into contiguous match blocks</li> <li>PAF format output for alignment records</li> <li>FM-index serialization/deserialization with serde + bincode</li> <li>All-vs-all dotplot visualization with matplotlib</li> <li>Full Python bindings via PyO3</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n\n# Build index for two sequences\nidx = SequenceIndex(k=15)\nidx.load_fasta(\"genome1.fasta\")\nidx.load_fasta(\"genome2.fasta\")\n\n# Get PAF-format alignments\nfor line in idx.get_paf(\"seq1\", \"seq2\"):\n    print(line)\n\n# Generate dotplot\nplotter = DotPlotter(idx)\nplotter.plot(output_path=\"dotplot.png\")\n</code></pre>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Installation \u2014 how to install rusty-dot and its dependencies.</li> <li>Tutorials \u2014 step-by-step Jupyter notebook walkthroughs.</li> <li>API Reference \u2014 full documentation for all classes and functions.</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or later</li> <li>A working Rust toolchain (for building from source)</li> <li>maturin \u2265 1.0</li> </ul>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<p>Clone the repository and build the Rust extension with maturin:</p> <pre><code>git clone https://github.com/Adamtaranto/rusty-dot.git\ncd rusty-dot\npip install maturin\nmaturin develop --release\n</code></pre> <p>The <code>--release</code> flag enables full Rust compiler optimisations, which is strongly recommended for any non-trivial dataset.</p>"},{"location":"installation/#install-python-dependencies","title":"Install Python dependencies","text":"<p>rusty-dot depends on:</p> Package Purpose <code>matplotlib \u2265 3.5</code> Dotplot visualisation <code>numpy \u2265 1.21</code> Array operations used by matplotlib <p>These are declared as package dependencies and will be installed automatically by pip.</p>"},{"location":"installation/#optional-documentation-dependencies","title":"Optional: documentation dependencies","text":"<p>To build the documentation locally:</p> <pre><code>pip install rusty-dot[docs]\nmkdocs serve\n</code></pre>"},{"location":"installation/#verify-the-installation","title":"Verify the installation","text":"<pre><code>import rusty_dot\nprint(rusty_dot.__version__)  # 0.1.0\n\nfrom rusty_dot import SequenceIndex\nidx = SequenceIndex(k=10)\nidx.add_sequence(\"test\", \"ACGTACGTACGT\")\nprint(idx)  # SequenceIndex(k=10, sequences=1)\n</code></pre>"},{"location":"api/","title":"API Reference","text":"<p>rusty-dot exposes its functionality through the following classes and functions.</p>"},{"location":"api/#classes","title":"Classes","text":"Class Module Description <code>SequenceIndex</code> <code>rusty_dot</code> Rust-backed FM-index for sequence comparison <code>DotPlotter</code> <code>rusty_dot.dotplot</code> All-vs-all dotplot visualisation <code>PafRecord</code> <code>rusty_dot.paf_io</code> Single PAF alignment record <code>PafAlignment</code> <code>rusty_dot.paf_io</code> Collection of PAF records with reordering utilities"},{"location":"api/#functions","title":"Functions","text":"Function Module Description <code>py_read_fasta</code> <code>rusty_dot</code> Read a FASTA or gzipped FASTA file <code>py_build_kmer_set</code> <code>rusty_dot</code> Build the k-mer set for a sequence <code>py_find_kmer_coords</code> <code>rusty_dot</code> Find k-mer positions in a sequence via FM-index <code>py_merge_kmer_runs</code> <code>rusty_dot</code> Merge co-linear k-mer hits into blocks <code>py_coords_to_paf</code> <code>rusty_dot</code> Convert coordinate tuples to PAF lines <code>py_save_index</code> <code>rusty_dot</code> Serialise an index collection to disk <code>py_load_index</code> <code>rusty_dot</code> Load a serialised index from disk <code>parse_paf_file</code> <code>rusty_dot.paf_io</code> Yield PAF records from a file <code>compute_gravity_contigs</code> <code>rusty_dot.paf_io</code> Sort contigs by gravity centre"},{"location":"api/dotplot/","title":"DotPlotter","text":"<p>The <code>DotPlotter</code> class generates all-vs-all dotplot figures from a populated <code>SequenceIndex</code>.</p>"},{"location":"api/dotplot/#class","title":"Class","text":""},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter","title":"<code>DotPlotter</code>","text":"<p>Generate all-vs-all dotplots for sets of DNA sequences.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>SequenceIndex</code> <p>A SequenceIndex with the sequences to plot.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from rusty_dot import SequenceIndex\n&gt;&gt;&gt; from rusty_dot.dotplot import DotPlotter\n&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\" * 10)\n&gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\" * 10)\n&gt;&gt;&gt; plotter = DotPlotter(idx)\n&gt;&gt;&gt; plotter.plot(output_path=\"dotplot.png\")\n</code></pre> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>class DotPlotter:\n    \"\"\"Generate all-vs-all dotplots for sets of DNA sequences.\n\n    Parameters\n    ----------\n    index : SequenceIndex\n        A SequenceIndex with the sequences to plot.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from rusty_dot import SequenceIndex\n    &gt;&gt;&gt; from rusty_dot.dotplot import DotPlotter\n    &gt;&gt;&gt; idx = SequenceIndex(k=10)\n    &gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\" * 10)\n    &gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\" * 10)\n    &gt;&gt;&gt; plotter = DotPlotter(idx)\n    &gt;&gt;&gt; plotter.plot(output_path=\"dotplot.png\")\n    \"\"\"\n\n    def __init__(self, index: SequenceIndex) -&gt; None:\n        \"\"\"Initialise the DotPlotter.\n\n        Parameters\n        ----------\n        index : SequenceIndex\n            A populated SequenceIndex instance.\n        \"\"\"\n        self.index = index\n\n    def plot(\n        self,\n        query_names: Optional[list[str]] = None,\n        target_names: Optional[list[str]] = None,\n        output_path: Union[str, Path] = 'dotplot.png',\n        figsize_per_panel: float = 4.0,\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        merge: bool = True,\n        title: Optional[str] = None,\n        dpi: int = 150,\n    ) -&gt; None:\n        \"\"\"Plot an all-vs-all dotplot grid.\n\n        If both ``query_names`` and ``target_names`` are provided, the plot\n        will show each query sequence (rows) against each target sequence\n        (columns). If only one set is provided, or neither, all pairwise\n        combinations within the available sequences are plotted.\n\n        Parameters\n        ----------\n        query_names : list[str], optional\n            Sequence names for the y-axis (rows). If ``None``, uses all\n            sequences in the index.\n        target_names : list[str], optional\n            Sequence names for the x-axis (columns). If ``None``, uses all\n            sequences in the index.\n        output_path : str or Path, optional\n            Output image file path. Default is ``\"dotplot.png\"``.\n        figsize_per_panel : float, optional\n            Size in inches for each subplot panel. Default is ``4.0``.\n        dot_size : float, optional\n            Size of each dot in the scatter plot. Default is ``0.5``.\n        dot_color : str, optional\n            Colour for match dots. Default is ``\"blue\"``.\n        merge : bool, optional\n            Whether to merge sequential k-mer runs before plotting.\n            Default is ``True``.\n        title : str, optional\n            Overall figure title. If ``None``, no title is added.\n        dpi : int, optional\n            Resolution of the output image. Default is ``150``.\n        \"\"\"\n        all_names = self.index.sequence_names()\n        if not all_names:\n            raise ValueError('No sequences in the index.')\n\n        if query_names is None:\n            query_names = sorted(all_names)\n        if target_names is None:\n            target_names = sorted(all_names)\n\n        nrows = len(query_names)\n        ncols = len(target_names)\n\n        fig_w = figsize_per_panel * ncols\n        fig_h = figsize_per_panel * nrows\n\n        fig, axes = plt.subplots(\n            nrows,\n            ncols,\n            figsize=(fig_w, fig_h),\n            squeeze=False,\n        )\n\n        for row_idx, q_name in enumerate(query_names):\n            for col_idx, t_name in enumerate(target_names):\n                ax = axes[row_idx][col_idx]\n                self._plot_panel(\n                    ax,\n                    q_name,\n                    t_name,\n                    dot_size=dot_size,\n                    dot_color=dot_color,\n                    merge=merge,\n                )\n\n        if title:\n            fig.suptitle(title, fontsize=14, y=1.01)\n\n        plt.tight_layout()\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n        plt.close(fig)\n\n    def _plot_panel(\n        self,\n        ax: plt.Axes,\n        query_name: str,\n        target_name: str,\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        merge: bool = True,\n    ) -&gt; None:\n        \"\"\"Render a single comparison panel onto the given Axes.\n\n        Parameters\n        ----------\n        ax : matplotlib.axes.Axes\n            The axes to draw on.\n        query_name : str\n            Name of the query sequence (y-axis).\n        target_name : str\n            Name of the target sequence (x-axis).\n        dot_size : float, optional\n            Marker size. Default is ``0.5``.\n        dot_color : str, optional\n            Marker colour. Default is ``\"blue\"``.\n        merge : bool, optional\n            Whether to merge sequential runs. Default is ``True``.\n        \"\"\"\n        q_len = self.index.get_sequence_length(query_name)\n        t_len = self.index.get_sequence_length(target_name)\n\n        matches = self.index.compare_sequences(query_name, target_name, merge)\n\n        # Draw match lines/dots\n        for q_start, q_end, t_start, t_end in matches:\n            # Draw a line from (t_start, q_start) to (t_end, q_end)\n            ax.plot(\n                [t_start, t_end],\n                [q_start, q_end],\n                color=dot_color,\n                linewidth=dot_size,\n                alpha=0.7,\n            )\n\n        ax.set_xlim(0, t_len)\n        ax.set_ylim(0, q_len)\n        ax.invert_yaxis()\n        ax.set_xlabel(target_name, fontsize=8)\n        ax.set_ylabel(query_name, fontsize=8)\n        ax.tick_params(axis='both', labelsize=6)\n        ax.set_aspect('auto')\n\n    def plot_single(\n        self,\n        query_name: str,\n        target_name: str,\n        output_path: Union[str, Path] = 'dotplot.png',\n        figsize: tuple[float, float] = (6.0, 6.0),\n        dot_size: float = 0.5,\n        dot_color: str = 'blue',\n        merge: bool = True,\n        title: Optional[str] = None,\n        dpi: int = 150,\n    ) -&gt; None:\n        \"\"\"Plot a single pairwise dotplot.\n\n        Parameters\n        ----------\n        query_name : str\n            Name of the query sequence (y-axis).\n        target_name : str\n            Name of the target sequence (x-axis).\n        output_path : str or Path, optional\n            Output image file path. Default is ``\"dotplot.png\"``.\n        figsize : tuple[float, float], optional\n            Figure size as (width, height) in inches. Default is ``(6, 6)``.\n        dot_size : float, optional\n            Marker/line size for each match. Default is ``0.5``.\n        dot_color : str, optional\n            Colour for matches. Default is ``\"blue\"``.\n        merge : bool, optional\n            Whether to merge sequential k-mer runs. Default is ``True``.\n        title : str, optional\n            Plot title. If ``None``, a default title is used.\n        dpi : int, optional\n            Output image resolution. Default is ``150``.\n        \"\"\"\n        fig, ax = plt.subplots(figsize=figsize)\n        self._plot_panel(\n            ax,\n            query_name,\n            target_name,\n            dot_size=dot_size,\n            dot_color=dot_color,\n            merge=merge,\n        )\n        if title is None:\n            title = f'{query_name} vs {target_name}'\n        ax.set_title(title, fontsize=10)\n        plt.tight_layout()\n        plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n        plt.close(fig)\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter-functions","title":"Functions","text":""},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.__init__","title":"<code>__init__(index)</code>","text":"<p>Initialise the DotPlotter.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>SequenceIndex</code> <p>A populated SequenceIndex instance.</p> required Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def __init__(self, index: SequenceIndex) -&gt; None:\n    \"\"\"Initialise the DotPlotter.\n\n    Parameters\n    ----------\n    index : SequenceIndex\n        A populated SequenceIndex instance.\n    \"\"\"\n    self.index = index\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot","title":"<code>plot(query_names=None, target_names=None, output_path='dotplot.png', figsize_per_panel=4.0, dot_size=0.5, dot_color='blue', merge=True, title=None, dpi=150)</code>","text":"<p>Plot an all-vs-all dotplot grid.</p> <p>If both <code>query_names</code> and <code>target_names</code> are provided, the plot will show each query sequence (rows) against each target sequence (columns). If only one set is provided, or neither, all pairwise combinations within the available sequences are plotted.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str]</code> <p>Sequence names for the y-axis (rows). If <code>None</code>, uses all sequences in the index.</p> <code>None</code> <code>target_names</code> <code>list[str]</code> <p>Sequence names for the x-axis (columns). If <code>None</code>, uses all sequences in the index.</p> <code>None</code> <code>output_path</code> <code>str or Path</code> <p>Output image file path. Default is <code>\"dotplot.png\"</code>.</p> <code>'dotplot.png'</code> <code>figsize_per_panel</code> <code>float</code> <p>Size in inches for each subplot panel. Default is <code>4.0</code>.</p> <code>4.0</code> <code>dot_size</code> <code>float</code> <p>Size of each dot in the scatter plot. Default is <code>0.5</code>.</p> <code>0.5</code> <code>dot_color</code> <code>str</code> <p>Colour for match dots. Default is <code>\"blue\"</code>.</p> <code>'blue'</code> <code>merge</code> <code>bool</code> <p>Whether to merge sequential k-mer runs before plotting. Default is <code>True</code>.</p> <code>True</code> <code>title</code> <code>str</code> <p>Overall figure title. If <code>None</code>, no title is added.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Resolution of the output image. Default is <code>150</code>.</p> <code>150</code> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot(\n    self,\n    query_names: Optional[list[str]] = None,\n    target_names: Optional[list[str]] = None,\n    output_path: Union[str, Path] = 'dotplot.png',\n    figsize_per_panel: float = 4.0,\n    dot_size: float = 0.5,\n    dot_color: str = 'blue',\n    merge: bool = True,\n    title: Optional[str] = None,\n    dpi: int = 150,\n) -&gt; None:\n    \"\"\"Plot an all-vs-all dotplot grid.\n\n    If both ``query_names`` and ``target_names`` are provided, the plot\n    will show each query sequence (rows) against each target sequence\n    (columns). If only one set is provided, or neither, all pairwise\n    combinations within the available sequences are plotted.\n\n    Parameters\n    ----------\n    query_names : list[str], optional\n        Sequence names for the y-axis (rows). If ``None``, uses all\n        sequences in the index.\n    target_names : list[str], optional\n        Sequence names for the x-axis (columns). If ``None``, uses all\n        sequences in the index.\n    output_path : str or Path, optional\n        Output image file path. Default is ``\"dotplot.png\"``.\n    figsize_per_panel : float, optional\n        Size in inches for each subplot panel. Default is ``4.0``.\n    dot_size : float, optional\n        Size of each dot in the scatter plot. Default is ``0.5``.\n    dot_color : str, optional\n        Colour for match dots. Default is ``\"blue\"``.\n    merge : bool, optional\n        Whether to merge sequential k-mer runs before plotting.\n        Default is ``True``.\n    title : str, optional\n        Overall figure title. If ``None``, no title is added.\n    dpi : int, optional\n        Resolution of the output image. Default is ``150``.\n    \"\"\"\n    all_names = self.index.sequence_names()\n    if not all_names:\n        raise ValueError('No sequences in the index.')\n\n    if query_names is None:\n        query_names = sorted(all_names)\n    if target_names is None:\n        target_names = sorted(all_names)\n\n    nrows = len(query_names)\n    ncols = len(target_names)\n\n    fig_w = figsize_per_panel * ncols\n    fig_h = figsize_per_panel * nrows\n\n    fig, axes = plt.subplots(\n        nrows,\n        ncols,\n        figsize=(fig_w, fig_h),\n        squeeze=False,\n    )\n\n    for row_idx, q_name in enumerate(query_names):\n        for col_idx, t_name in enumerate(target_names):\n            ax = axes[row_idx][col_idx]\n            self._plot_panel(\n                ax,\n                q_name,\n                t_name,\n                dot_size=dot_size,\n                dot_color=dot_color,\n                merge=merge,\n            )\n\n    if title:\n        fig.suptitle(title, fontsize=14, y=1.01)\n\n    plt.tight_layout()\n    plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n    plt.close(fig)\n</code></pre>"},{"location":"api/dotplot/#rusty_dot.dotplot.DotPlotter.plot_single","title":"<code>plot_single(query_name, target_name, output_path='dotplot.png', figsize=(6.0, 6.0), dot_size=0.5, dot_color='blue', merge=True, title=None, dpi=150)</code>","text":"<p>Plot a single pairwise dotplot.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence (y-axis).</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence (x-axis).</p> required <code>output_path</code> <code>str or Path</code> <p>Output image file path. Default is <code>\"dotplot.png\"</code>.</p> <code>'dotplot.png'</code> <code>figsize</code> <code>tuple[float, float]</code> <p>Figure size as (width, height) in inches. Default is <code>(6, 6)</code>.</p> <code>(6.0, 6.0)</code> <code>dot_size</code> <code>float</code> <p>Marker/line size for each match. Default is <code>0.5</code>.</p> <code>0.5</code> <code>dot_color</code> <code>str</code> <p>Colour for matches. Default is <code>\"blue\"</code>.</p> <code>'blue'</code> <code>merge</code> <code>bool</code> <p>Whether to merge sequential k-mer runs. Default is <code>True</code>.</p> <code>True</code> <code>title</code> <code>str</code> <p>Plot title. If <code>None</code>, a default title is used.</p> <code>None</code> <code>dpi</code> <code>int</code> <p>Output image resolution. Default is <code>150</code>.</p> <code>150</code> Source code in <code>python/rusty_dot/dotplot.py</code> <pre><code>def plot_single(\n    self,\n    query_name: str,\n    target_name: str,\n    output_path: Union[str, Path] = 'dotplot.png',\n    figsize: tuple[float, float] = (6.0, 6.0),\n    dot_size: float = 0.5,\n    dot_color: str = 'blue',\n    merge: bool = True,\n    title: Optional[str] = None,\n    dpi: int = 150,\n) -&gt; None:\n    \"\"\"Plot a single pairwise dotplot.\n\n    Parameters\n    ----------\n    query_name : str\n        Name of the query sequence (y-axis).\n    target_name : str\n        Name of the target sequence (x-axis).\n    output_path : str or Path, optional\n        Output image file path. Default is ``\"dotplot.png\"``.\n    figsize : tuple[float, float], optional\n        Figure size as (width, height) in inches. Default is ``(6, 6)``.\n    dot_size : float, optional\n        Marker/line size for each match. Default is ``0.5``.\n    dot_color : str, optional\n        Colour for matches. Default is ``\"blue\"``.\n    merge : bool, optional\n        Whether to merge sequential k-mer runs. Default is ``True``.\n    title : str, optional\n        Plot title. If ``None``, a default title is used.\n    dpi : int, optional\n        Output image resolution. Default is ``150``.\n    \"\"\"\n    fig, ax = plt.subplots(figsize=figsize)\n    self._plot_panel(\n        ax,\n        query_name,\n        target_name,\n        dot_size=dot_size,\n        dot_color=dot_color,\n        merge=merge,\n    )\n    if title is None:\n        title = f'{query_name} vs {target_name}'\n    ax.set_title(title, fontsize=10)\n    plt.tight_layout()\n    plt.savefig(str(output_path), dpi=dpi, bbox_inches='tight')\n    plt.close(fig)\n</code></pre>"},{"location":"api/functions/","title":"Low-Level Functions","text":"<p>These functions are implemented in Rust and exposed via PyO3. They provide fine-grained access to the underlying FM-index and k-mer machinery. For most use cases, the <code>SequenceIndex</code> class is more convenient.</p>"},{"location":"api/functions/#fasta-io","title":"FASTA I/O","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_read_fasta","title":"<code>py_read_fasta(path)</code>  <code>builtin</code>","text":"<p>Python binding: read sequences from a FASTA or gzipped FASTA file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the FASTA or FASTA.gz file.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary mapping sequence name to sequence string.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be opened or parsed.</p>"},{"location":"api/functions/#k-mer-operations","title":"K-mer Operations","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_build_kmer_set","title":"<code>py_build_kmer_set(seq, k)</code>  <code>builtin</code>","text":"<p>Python binding: build the set of unique k-mers in a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>The DNA sequence string (uppercase recommended).</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>Set of unique k-mer strings found in the sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If k is 0 or the sequence is empty.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_find_kmer_coords","title":"<code>py_find_kmer_coords(seq, kmers)</code>  <code>builtin</code>","text":"<p>Python binding: find all positions of each k-mer in a sequence.</p> <p>Parameters:</p> Name Type Description Default <code>seq</code> <code>str</code> <p>The DNA sequence to search in.</p> required <code>kmers</code> <code>list[str]</code> <p>List of k-mer strings to search for.</p> required <p>Returns:</p> Type Description <code>dict[str, list[int]]</code> <p>Dictionary mapping each k-mer to its list of start positions (0-based).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence is invalid or k-mers are inconsistent.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_merge_kmer_runs","title":"<code>py_merge_kmer_runs(kmer_coords, query_kmer_positions, k)</code>  <code>builtin</code>","text":"<p>Python binding: merge sequential k-mer coordinate runs (forward strand).</p> <p>Parameters:</p> Name Type Description Default <code>kmer_coords</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to list of target start positions (0-based).</p> required <code>query_kmer_positions</code> <code>dict[str, list[int]]</code> <p>Mapping of k-mer to list of query start positions (0-based).</p> required <code>k</code> <code>int</code> <p>The k-mer length.</p> required <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of (query_start, query_end, target_start, target_end) tuples. Coordinates are 0-based, with end positions exclusive.</p>"},{"location":"api/functions/#paf-formatting","title":"PAF Formatting","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_coords_to_paf","title":"<code>py_coords_to_paf(matches, query_name, query_len, target_name, target_len)</code>  <code>builtin</code>","text":"<p>Python binding: convert coordinate tuples to PAF format strings.</p> <p>Parameters:</p> Name Type Description Default <code>matches</code> <code>list[tuple[int, int, int, int]]</code> <p>List of (query_start, query_end, target_start, target_end) tuples.</p> required <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>query_len</code> <code>int</code> <p>Total length of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>target_len</code> <code>int</code> <p>Total length of the target sequence.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of PAF format lines (tab-separated).</p>"},{"location":"api/functions/#index-serialization","title":"Index Serialization","text":""},{"location":"api/functions/#rusty_dot._rusty_dot.py_save_index","title":"<code>py_save_index(path, sequences, k)</code>  <code>builtin</code>","text":"<p>Python binding: save an index collection to a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to save the serialized index.</p> required <code>sequences</code> <code>dict[str, str]</code> <p>Dictionary of sequence name to sequence string.</p> required <code>k</code> <code>int</code> <p>The k-mer length used to build the index.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If serialization fails.</p>"},{"location":"api/functions/#rusty_dot._rusty_dot.py_load_index","title":"<code>py_load_index(path)</code>  <code>builtin</code>","text":"<p>Python binding: load an index collection from a file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the serialized index file.</p> required <p>Returns:</p> Type Description <code>tuple[dict[str, list[str]], int]</code> <p>A tuple of (kmer_sets_dict, k) where kmer_sets_dict maps sequence names to their k-mer lists.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If deserialization fails.</p>"},{"location":"api/paf_io/","title":"PAF I/O","text":"<p>This module provides classes and helpers for reading, writing, and reordering PAF (Pairwise mApping Format) alignment records.</p>"},{"location":"api/paf_io/#classes","title":"Classes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord","title":"<code>PafRecord</code>  <code>dataclass</code>","text":"<p>A single PAF alignment record.</p> <p>The twelve required PAF columns are represented as typed attributes. Optional SAM-like tags (e.g. <code>tp:A:P</code>, <code>cg:Z:10M</code>) are stored in :attr:<code>tags</code>.  If a <code>cg:Z:</code> tag is present, CIGAR-derived alignment statistics are populated automatically.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Query sequence name (column 1).</p> required <code>query_len</code> <code>int</code> <p>Query sequence length (column 2).</p> required <code>query_start</code> <code>int</code> <p>Query start position, 0-based (column 3).</p> required <code>query_end</code> <code>int</code> <p>Query end position, exclusive (column 4).</p> required <code>strand</code> <code>str</code> <p>Relative strand: <code>\"+\"</code> or <code>\"-\"</code> (column 5).</p> required <code>target_name</code> <code>str</code> <p>Target sequence name (column 6).</p> required <code>target_len</code> <code>int</code> <p>Target sequence length (column 7).</p> required <code>target_start</code> <code>int</code> <p>Target start position, 0-based (column 8).</p> required <code>target_end</code> <code>int</code> <p>Target end position, exclusive (column 9).</p> required <code>residue_matches</code> <code>int</code> <p>Number of residue matches (column 10).</p> required <code>alignment_block_len</code> <code>int</code> <p>Number of bases in the alignment block (column 11).</p> required <code>mapping_quality</code> <code>int</code> <p>Mapping quality (0\u2013255; 255 = missing) (column 12).</p> required <code>tags</code> <code>dict[str, Any]</code> <p>Optional SAM-like tags decoded as <code>{tag_name: value}</code>.</p> <code>dict()</code> <code>cigar</code> <code>str or None</code> <p>CIGAR string from <code>cg:Z:</code> tag, or <code>None</code> if absent.</p> <code>None</code> <code>alignment_length</code> <code>int or None</code> <p>Target-span alignment length derived from CIGAR, or <code>None</code>.</p> <code>None</code> <code>n_matches</code> <code>int or None</code> <p>Count of exact-match bases (<code>=</code> ops) from CIGAR; falls back to <code>residue_matches</code> when only <code>M</code> ops are present.</p> <code>None</code> <code>n_mismatches</code> <code>int or None</code> <p>Count of mismatch bases (<code>X</code> ops) from CIGAR, or <code>None</code>.</p> <code>None</code> <code>n_gaps</code> <code>int or None</code> <p>Total number of gap bases (<code>I</code> + <code>D</code> bases) from CIGAR.</p> <code>None</code> <code>n_gap_bases</code> <code>int or None</code> <p>Same as <code>n_gaps</code> (alias kept for clarity).</p> <code>None</code> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@dataclass\nclass PafRecord:\n    \"\"\"A single PAF alignment record.\n\n    The twelve required PAF columns are represented as typed attributes.\n    Optional SAM-like tags (e.g. ``tp:A:P``, ``cg:Z:10M``) are stored in\n    :attr:`tags`.  If a ``cg:Z:`` tag is present, CIGAR-derived alignment\n    statistics are populated automatically.\n\n    Parameters\n    ----------\n    query_name : str\n        Query sequence name (column 1).\n    query_len : int\n        Query sequence length (column 2).\n    query_start : int\n        Query start position, 0-based (column 3).\n    query_end : int\n        Query end position, exclusive (column 4).\n    strand : str\n        Relative strand: ``\"+\"`` or ``\"-\"`` (column 5).\n    target_name : str\n        Target sequence name (column 6).\n    target_len : int\n        Target sequence length (column 7).\n    target_start : int\n        Target start position, 0-based (column 8).\n    target_end : int\n        Target end position, exclusive (column 9).\n    residue_matches : int\n        Number of residue matches (column 10).\n    alignment_block_len : int\n        Number of bases in the alignment block (column 11).\n    mapping_quality : int\n        Mapping quality (0\u2013255; 255 = missing) (column 12).\n    tags : dict[str, Any]\n        Optional SAM-like tags decoded as ``{tag_name: value}``.\n    cigar : str or None\n        CIGAR string from ``cg:Z:`` tag, or ``None`` if absent.\n    alignment_length : int or None\n        Target-span alignment length derived from CIGAR, or ``None``.\n    n_matches : int or None\n        Count of exact-match bases (``=`` ops) from CIGAR; falls back to\n        ``residue_matches`` when only ``M`` ops are present.\n    n_mismatches : int or None\n        Count of mismatch bases (``X`` ops) from CIGAR, or ``None``.\n    n_gaps : int or None\n        Total number of gap bases (``I`` + ``D`` bases) from CIGAR.\n    n_gap_bases : int or None\n        Same as ``n_gaps`` (alias kept for clarity).\n    \"\"\"\n\n    query_name: str\n    query_len: int\n    query_start: int\n    query_end: int\n    strand: str\n    target_name: str\n    target_len: int\n    target_start: int\n    target_end: int\n    residue_matches: int\n    alignment_block_len: int\n    mapping_quality: int\n    tags: dict[str, Any] = field(default_factory=dict)\n    cigar: str | None = None\n    alignment_length: int | None = None\n    n_matches: int | None = None\n    n_mismatches: int | None = None\n    n_gaps: int | None = None\n    n_gap_bases: int | None = None\n\n    @property\n    def query_aligned_len(self) -&gt; int:\n        \"\"\"Return the aligned length on the query sequence.\n\n        Returns\n        -------\n        int\n            ``query_end - query_start``.\n        \"\"\"\n        return self.query_end - self.query_start\n\n    @property\n    def target_aligned_len(self) -&gt; int:\n        \"\"\"Return the aligned length on the target sequence.\n\n        Returns\n        -------\n        int\n            ``target_end - target_start``.\n        \"\"\"\n        return self.target_end - self.target_start\n\n    @classmethod\n    def from_line(cls, line: str) -&gt; 'PafRecord':\n        \"\"\"Parse a single PAF text line into a :class:`PafRecord`.\n\n        Parameters\n        ----------\n        line : str\n            A single PAF record line (tab-separated, trailing newline optional).\n\n        Returns\n        -------\n        PafRecord\n            The parsed record.\n\n        Raises\n        ------\n        ValueError\n            If the line has fewer than 12 tab-separated fields.\n        \"\"\"\n        fields = line.rstrip('\\n').split('\\t')\n        if len(fields) &lt; 12:\n            raise ValueError(\n                f'PAF line has {len(fields)} fields; expected at least 12: {line!r}'\n            )\n        tags: dict[str, Any] = {}\n        cigar: str | None = None\n        for tag_field in fields[12:]:\n            parts = tag_field.split(':', 2)\n            if len(parts) == 3:\n                tag_name, tag_type, tag_value = parts\n                if tag_type == 'i':\n                    tags[tag_name] = int(tag_value)\n                elif tag_type == 'f':\n                    tags[tag_name] = float(tag_value)\n                else:\n                    tags[tag_name] = tag_value\n                if tag_name == 'cg' and tag_type == 'Z':\n                    cigar = tag_value\n\n        residue_matches = int(fields[9])\n        stats: dict[str, int] = {}\n        if cigar is not None:\n            stats = _cigar_stats(cigar, residue_matches)\n\n        return cls(\n            query_name=fields[0],\n            query_len=int(fields[1]),\n            query_start=int(fields[2]),\n            query_end=int(fields[3]),\n            strand=fields[4],\n            target_name=fields[5],\n            target_len=int(fields[6]),\n            target_start=int(fields[7]),\n            target_end=int(fields[8]),\n            residue_matches=residue_matches,\n            alignment_block_len=int(fields[10]),\n            mapping_quality=int(fields[11]),\n            tags=tags,\n            cigar=cigar,\n            alignment_length=stats.get('alignment_length'),\n            n_matches=stats.get('n_matches'),\n            n_mismatches=stats.get('n_mismatches'),\n            n_gaps=stats.get('n_gaps'),\n            n_gap_bases=stats.get('n_gap_bases'),\n        )\n\n    def to_line(self) -&gt; str:\n        \"\"\"Serialise this record back to a PAF-format string (no trailing newline).\n\n        Returns\n        -------\n        str\n            Tab-separated PAF line with the 12 required columns.  Optional\n            tags are not included.\n        \"\"\"\n        return '\\t'.join(\n            str(v)\n            for v in [\n                self.query_name,\n                self.query_len,\n                self.query_start,\n                self.query_end,\n                self.strand,\n                self.target_name,\n                self.target_len,\n                self.target_start,\n                self.target_end,\n                self.residue_matches,\n                self.alignment_block_len,\n                self.mapping_quality,\n            ]\n        )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.query_aligned_len","title":"<code>query_aligned_len</code>  <code>property</code>","text":"<p>Return the aligned length on the query sequence.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>query_end - query_start</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.target_aligned_len","title":"<code>target_aligned_len</code>  <code>property</code>","text":"<p>Return the aligned length on the target sequence.</p> <p>Returns:</p> Type Description <code>int</code> <p><code>target_end - target_start</code>.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.from_line","title":"<code>from_line(line)</code>  <code>classmethod</code>","text":"<p>Parse a single PAF text line into a :class:<code>PafRecord</code>.</p> <p>Parameters:</p> Name Type Description Default <code>line</code> <code>str</code> <p>A single PAF record line (tab-separated, trailing newline optional).</p> required <p>Returns:</p> Type Description <code>PafRecord</code> <p>The parsed record.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the line has fewer than 12 tab-separated fields.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_line(cls, line: str) -&gt; 'PafRecord':\n    \"\"\"Parse a single PAF text line into a :class:`PafRecord`.\n\n    Parameters\n    ----------\n    line : str\n        A single PAF record line (tab-separated, trailing newline optional).\n\n    Returns\n    -------\n    PafRecord\n        The parsed record.\n\n    Raises\n    ------\n    ValueError\n        If the line has fewer than 12 tab-separated fields.\n    \"\"\"\n    fields = line.rstrip('\\n').split('\\t')\n    if len(fields) &lt; 12:\n        raise ValueError(\n            f'PAF line has {len(fields)} fields; expected at least 12: {line!r}'\n        )\n    tags: dict[str, Any] = {}\n    cigar: str | None = None\n    for tag_field in fields[12:]:\n        parts = tag_field.split(':', 2)\n        if len(parts) == 3:\n            tag_name, tag_type, tag_value = parts\n            if tag_type == 'i':\n                tags[tag_name] = int(tag_value)\n            elif tag_type == 'f':\n                tags[tag_name] = float(tag_value)\n            else:\n                tags[tag_name] = tag_value\n            if tag_name == 'cg' and tag_type == 'Z':\n                cigar = tag_value\n\n    residue_matches = int(fields[9])\n    stats: dict[str, int] = {}\n    if cigar is not None:\n        stats = _cigar_stats(cigar, residue_matches)\n\n    return cls(\n        query_name=fields[0],\n        query_len=int(fields[1]),\n        query_start=int(fields[2]),\n        query_end=int(fields[3]),\n        strand=fields[4],\n        target_name=fields[5],\n        target_len=int(fields[6]),\n        target_start=int(fields[7]),\n        target_end=int(fields[8]),\n        residue_matches=residue_matches,\n        alignment_block_len=int(fields[10]),\n        mapping_quality=int(fields[11]),\n        tags=tags,\n        cigar=cigar,\n        alignment_length=stats.get('alignment_length'),\n        n_matches=stats.get('n_matches'),\n        n_mismatches=stats.get('n_mismatches'),\n        n_gaps=stats.get('n_gaps'),\n        n_gap_bases=stats.get('n_gap_bases'),\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafRecord.to_line","title":"<code>to_line()</code>","text":"<p>Serialise this record back to a PAF-format string (no trailing newline).</p> <p>Returns:</p> Type Description <code>str</code> <p>Tab-separated PAF line with the 12 required columns.  Optional tags are not included.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def to_line(self) -&gt; str:\n    \"\"\"Serialise this record back to a PAF-format string (no trailing newline).\n\n    Returns\n    -------\n    str\n        Tab-separated PAF line with the 12 required columns.  Optional\n        tags are not included.\n    \"\"\"\n    return '\\t'.join(\n        str(v)\n        for v in [\n            self.query_name,\n            self.query_len,\n            self.query_start,\n            self.query_end,\n            self.strand,\n            self.target_name,\n            self.target_len,\n            self.target_start,\n            self.target_end,\n            self.residue_matches,\n            self.alignment_block_len,\n            self.mapping_quality,\n        ]\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment","title":"<code>PafAlignment</code>","text":"<p>A collection of PAF alignment records with contig-ordering utilities.</p> <p>Can be constructed from a file path or an iterable of :class:<code>PafRecord</code> objects.  Provides :meth:<code>reorder_contigs</code> to sort query and target sequence names so that a subsequent dotplot shows maximum collinearity.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>list of PafRecord</code> <p>The alignment records.</p> required <p>Examples:</p> <p>Load from a file and reorder contigs:</p> <pre><code>&gt;&gt;&gt; aln = PafAlignment.from_file(\"alignments.paf\")\n&gt;&gt;&gt; q_order, t_order = aln.reorder_contigs(aln.query_names, aln.target_names)\n</code></pre> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>class PafAlignment:\n    \"\"\"A collection of PAF alignment records with contig-ordering utilities.\n\n    Can be constructed from a file path or an iterable of :class:`PafRecord`\n    objects.  Provides :meth:`reorder_contigs` to sort query and target\n    sequence names so that a subsequent dotplot shows maximum collinearity.\n\n    Parameters\n    ----------\n    records : list of PafRecord\n        The alignment records.\n\n    Examples\n    --------\n    Load from a file and reorder contigs:\n\n    &gt;&gt;&gt; aln = PafAlignment.from_file(\"alignments.paf\")\n    &gt;&gt;&gt; q_order, t_order = aln.reorder_contigs(aln.query_names, aln.target_names)\n    \"\"\"\n\n    def __init__(self, records: list[PafRecord]) -&gt; None:\n        self.records: list[PafRecord] = records\n\n    # ------------------------------------------------------------------\n    # Constructors\n    # ------------------------------------------------------------------\n\n    @classmethod\n    def from_file(cls, path: str | Path) -&gt; 'PafAlignment':\n        \"\"\"Load records from a PAF file.\n\n        Parameters\n        ----------\n        path : str or Path\n            Path to the PAF file.\n\n        Returns\n        -------\n        PafAlignment\n            New instance with all records loaded.\n        \"\"\"\n        return cls(list(parse_paf_file(path)))\n\n    @classmethod\n    def from_records(cls, records: Iterable[PafRecord]) -&gt; 'PafAlignment':\n        \"\"\"Construct from an iterable of :class:`PafRecord` objects.\n\n        Parameters\n        ----------\n        records : iterable of PafRecord\n            Source records.\n\n        Returns\n        -------\n        PafAlignment\n            New instance.\n        \"\"\"\n        return cls(list(records))\n\n    # ------------------------------------------------------------------\n    # Properties\n    # ------------------------------------------------------------------\n\n    @property\n    def query_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of query sequence names (insertion order).\n\n        Returns\n        -------\n        list[str]\n            Unique query names in the order first seen.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.query_name] = None\n        return list(seen)\n\n    @property\n    def target_names(self) -&gt; list[str]:\n        \"\"\"Return a deduplicated list of target sequence names (insertion order).\n\n        Returns\n        -------\n        list[str]\n            Unique target names in the order first seen.\n        \"\"\"\n        seen: dict[str, None] = {}\n        for rec in self.records:\n            seen[rec.target_name] = None\n        return list(seen)\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of records.\n\n        Returns\n        -------\n        int\n            Record count.\n        \"\"\"\n        return len(self.records)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a concise string representation.\n\n        Returns\n        -------\n        str\n            ``PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)``.\n        \"\"\"\n        return (\n            f'PafAlignment(records={len(self.records)}, '\n            f'queries={len(self.query_names)}, '\n            f'targets={len(self.target_names)})'\n        )\n\n    # ------------------------------------------------------------------\n    # Filtering\n    # ------------------------------------------------------------------\n\n    def filter_by_query(self, names: Iterable[str]) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` containing only the given query names.\n\n        Parameters\n        ----------\n        names : iterable of str\n            Query names to keep.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment.\n        \"\"\"\n        keep = set(names)\n        return PafAlignment([r for r in self.records if r.query_name in keep])\n\n    def filter_by_target(self, names: Iterable[str]) -&gt; 'PafAlignment':\n        \"\"\"Return a new :class:`PafAlignment` containing only the given target names.\n\n        Parameters\n        ----------\n        names : iterable of str\n            Target names to keep.\n\n        Returns\n        -------\n        PafAlignment\n            Filtered alignment.\n        \"\"\"\n        keep = set(names)\n        return PafAlignment([r for r in self.records if r.target_name in keep])\n\n    # ------------------------------------------------------------------\n    # Contig reordering\n    # ------------------------------------------------------------------\n\n    def reorder_contigs(\n        self,\n        query_names: list[str] | None = None,\n        target_names: list[str] | None = None,\n    ) -&gt; tuple[list[str], list[str]]:\n        \"\"\"Sort query and target contigs to maximise collinearity in the dotplot.\n\n        Uses the gravity-centre algorithm: each contig is assigned a gravity\n        equal to the weighted mean position of its alignment blocks on the\n        opposing axis.  Contigs are then sorted by ascending gravity.\n\n        Parameters\n        ----------\n        query_names : list[str] or None, optional\n            Query contigs to reorder.  Defaults to :attr:`query_names`.\n        target_names : list[str] or None, optional\n            Target contigs to reorder.  Defaults to :attr:`target_names`.\n\n        Returns\n        -------\n        tuple[list[str], list[str]]\n            ``(sorted_query_names, sorted_target_names)``.\n        \"\"\"\n        q = query_names if query_names is not None else self.query_names\n        t = target_names if target_names is not None else self.target_names\n        return compute_gravity_contigs(self.records, q, t)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment-attributes","title":"Attributes","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.query_names","title":"<code>query_names</code>  <code>property</code>","text":"<p>Return a deduplicated list of query sequence names (insertion order).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unique query names in the order first seen.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.target_names","title":"<code>target_names</code>  <code>property</code>","text":"<p>Return a deduplicated list of target sequence names (insertion order).</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unique target names in the order first seen.</p>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment-functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.from_file","title":"<code>from_file(path)</code>  <code>classmethod</code>","text":"<p>Load records from a PAF file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the PAF file.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>New instance with all records loaded.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_file(cls, path: str | Path) -&gt; 'PafAlignment':\n    \"\"\"Load records from a PAF file.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the PAF file.\n\n    Returns\n    -------\n    PafAlignment\n        New instance with all records loaded.\n    \"\"\"\n    return cls(list(parse_paf_file(path)))\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.from_records","title":"<code>from_records(records)</code>  <code>classmethod</code>","text":"<p>Construct from an iterable of :class:<code>PafRecord</code> objects.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable of PafRecord</code> <p>Source records.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>New instance.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>@classmethod\ndef from_records(cls, records: Iterable[PafRecord]) -&gt; 'PafAlignment':\n    \"\"\"Construct from an iterable of :class:`PafRecord` objects.\n\n    Parameters\n    ----------\n    records : iterable of PafRecord\n        Source records.\n\n    Returns\n    -------\n    PafAlignment\n        New instance.\n    \"\"\"\n    return cls(list(records))\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of records.</p> <p>Returns:</p> Type Description <code>int</code> <p>Record count.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of records.\n\n    Returns\n    -------\n    int\n        Record count.\n    \"\"\"\n    return len(self.records)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation.</p> <p>Returns:</p> Type Description <code>str</code> <p><code>PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a concise string representation.\n\n    Returns\n    -------\n    str\n        ``PafAlignment(records=&lt;n&gt;, queries=&lt;q&gt;, targets=&lt;t&gt;)``.\n    \"\"\"\n    return (\n        f'PafAlignment(records={len(self.records)}, '\n        f'queries={len(self.query_names)}, '\n        f'targets={len(self.target_names)})'\n    )\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_query","title":"<code>filter_by_query(names)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> containing only the given query names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>iterable of str</code> <p>Query names to keep.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_query(self, names: Iterable[str]) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` containing only the given query names.\n\n    Parameters\n    ----------\n    names : iterable of str\n        Query names to keep.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment.\n    \"\"\"\n    keep = set(names)\n    return PafAlignment([r for r in self.records if r.query_name in keep])\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.filter_by_target","title":"<code>filter_by_target(names)</code>","text":"<p>Return a new :class:<code>PafAlignment</code> containing only the given target names.</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>iterable of str</code> <p>Target names to keep.</p> required <p>Returns:</p> Type Description <code>PafAlignment</code> <p>Filtered alignment.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def filter_by_target(self, names: Iterable[str]) -&gt; 'PafAlignment':\n    \"\"\"Return a new :class:`PafAlignment` containing only the given target names.\n\n    Parameters\n    ----------\n    names : iterable of str\n        Target names to keep.\n\n    Returns\n    -------\n    PafAlignment\n        Filtered alignment.\n    \"\"\"\n    keep = set(names)\n    return PafAlignment([r for r in self.records if r.target_name in keep])\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.PafAlignment.reorder_contigs","title":"<code>reorder_contigs(query_names=None, target_names=None)</code>","text":"<p>Sort query and target contigs to maximise collinearity in the dotplot.</p> <p>Uses the gravity-centre algorithm: each contig is assigned a gravity equal to the weighted mean position of its alignment blocks on the opposing axis.  Contigs are then sorted by ascending gravity.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str] or None</code> <p>Query contigs to reorder.  Defaults to :attr:<code>query_names</code>.</p> <code>None</code> <code>target_names</code> <code>list[str] or None</code> <p>Target contigs to reorder.  Defaults to :attr:<code>target_names</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code>.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def reorder_contigs(\n    self,\n    query_names: list[str] | None = None,\n    target_names: list[str] | None = None,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Sort query and target contigs to maximise collinearity in the dotplot.\n\n    Uses the gravity-centre algorithm: each contig is assigned a gravity\n    equal to the weighted mean position of its alignment blocks on the\n    opposing axis.  Contigs are then sorted by ascending gravity.\n\n    Parameters\n    ----------\n    query_names : list[str] or None, optional\n        Query contigs to reorder.  Defaults to :attr:`query_names`.\n    target_names : list[str] or None, optional\n        Target contigs to reorder.  Defaults to :attr:`target_names`.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)``.\n    \"\"\"\n    q = query_names if query_names is not None else self.query_names\n    t = target_names if target_names is not None else self.target_names\n    return compute_gravity_contigs(self.records, q, t)\n</code></pre>"},{"location":"api/paf_io/#functions","title":"Functions","text":""},{"location":"api/paf_io/#rusty_dot.paf_io.parse_paf_file","title":"<code>parse_paf_file(path)</code>","text":"<p>Yield :class:<code>PafRecord</code> objects from a PAF file.</p> <p>Lines beginning with <code>#</code> are treated as comments and skipped.  Empty lines are also skipped.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str or Path</code> <p>Path to the PAF file.</p> required <p>Yields:</p> Type Description <code>PafRecord</code> <p>One record per non-comment, non-empty line.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If <code>path</code> does not exist.</p> <code>ValueError</code> <p>If a line cannot be parsed as a PAF record.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def parse_paf_file(path: str | Path) -&gt; Generator[PafRecord, None, None]:\n    \"\"\"Yield :class:`PafRecord` objects from a PAF file.\n\n    Lines beginning with ``#`` are treated as comments and skipped.  Empty\n    lines are also skipped.\n\n    Parameters\n    ----------\n    path : str or Path\n        Path to the PAF file.\n\n    Yields\n    ------\n    PafRecord\n        One record per non-comment, non-empty line.\n\n    Raises\n    ------\n    FileNotFoundError\n        If ``path`` does not exist.\n    ValueError\n        If a line cannot be parsed as a PAF record.\n    \"\"\"\n    path = Path(path)\n    with path.open('r', encoding='utf-8') as fh:\n        for line in fh:\n            line = line.rstrip('\\n')\n            if not line or line.startswith('#'):\n                continue\n            yield PafRecord.from_line(line)\n</code></pre>"},{"location":"api/paf_io/#rusty_dot.paf_io.compute_gravity_contigs","title":"<code>compute_gravity_contigs(records, query_names, target_names)</code>","text":"<p>Return query and target contig names sorted by gravity centre.</p> <p>For each query contig the gravity centre is the weighted mean of target mid-point positions (normalised by the total target span) across all alignment records that involve that contig.  Target contigs are sorted symmetrically against the query axis.</p> <p>Contigs with no alignment records receive a gravity of <code>float(\"inf\")</code> and are placed at the end of the sorted list.</p> <p>Parameters:</p> Name Type Description Default <code>records</code> <code>iterable of PafRecord</code> <p>Alignment records to use for computing gravity centres.</p> required <code>query_names</code> <code>list[str]</code> <p>The query contig names to reorder.</p> required <code>target_names</code> <code>list[str]</code> <p>The target contig names to reorder.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> ordered by ascending gravity centre.</p> Source code in <code>python/rusty_dot/paf_io.py</code> <pre><code>def compute_gravity_contigs(\n    records: Iterable[PafRecord],\n    query_names: list[str],\n    target_names: list[str],\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Return query and target contig names sorted by gravity centre.\n\n    For each query contig the gravity centre is the weighted mean of target\n    mid-point positions (normalised by the total target span) across all\n    alignment records that involve that contig.  Target contigs are sorted\n    symmetrically against the query axis.\n\n    Contigs with no alignment records receive a gravity of ``float(\"inf\")``\n    and are placed at the end of the sorted list.\n\n    Parameters\n    ----------\n    records : iterable of PafRecord\n        Alignment records to use for computing gravity centres.\n    query_names : list[str]\n        The query contig names to reorder.\n    target_names : list[str]\n        The target contig names to reorder.\n\n    Returns\n    -------\n    tuple[list[str], list[str]]\n        ``(sorted_query_names, sorted_target_names)`` ordered by ascending\n        gravity centre.\n    \"\"\"\n    query_set = set(query_names)\n    target_set = set(target_names)\n\n    # Collect all records into a list and build sequence-length maps from them.\n    q_len_map: dict[str, int] = {}\n    t_len_map: dict[str, int] = {}\n    all_records: list[PafRecord] = []\n    for rec in records:\n        all_records.append(rec)\n        q_len_map[rec.query_name] = rec.query_len\n        t_len_map[rec.target_name] = rec.target_len\n\n    # Build cumulative target offsets using actual sequence lengths.\n    t_offsets: dict[str, int] = {}\n    t_off = 0\n    for t in target_names:\n        t_offsets[t] = t_off\n        t_off += t_len_map.get(t, 1)\n    total_target_len = max(t_off, 1)\n\n    # Build cumulative query offsets using actual sequence lengths.\n    q_offsets_real: dict[str, int] = {}\n    q_off = 0\n    for q in query_names:\n        q_offsets_real[q] = q_off\n        q_off += q_len_map.get(q, 1)\n    total_query_len = max(q_off, 1)\n\n    # Accumulate weighted positions.\n    q_weight: dict[str, float] = dict.fromkeys(query_names, 0.0)\n    q_wpos: dict[str, float] = dict.fromkeys(query_names, 0.0)\n    t_weight: dict[str, float] = dict.fromkeys(target_names, 0.0)\n    t_wpos: dict[str, float] = dict.fromkeys(target_names, 0.0)\n\n    for rec in all_records:\n        if rec.query_name not in query_set or rec.target_name not in target_set:\n            continue\n        size = float(rec.alignment_block_len or (rec.query_end - rec.query_start))\n        if size &lt;= 0:\n            continue\n\n        # Target gravity from query's perspective.\n        t_mid = (\n            t_offsets.get(rec.target_name, 0)\n            + (rec.target_start + rec.target_end) / 2.0\n        )\n        q_weight[rec.query_name] += size\n        q_wpos[rec.query_name] += size * t_mid\n\n        # Query gravity from target's perspective.\n        q_mid = (\n            q_offsets_real.get(rec.query_name, 0)\n            + (rec.query_start + rec.query_end) / 2.0\n        )\n        t_weight[rec.target_name] += size\n        t_wpos[rec.target_name] += size * q_mid\n\n    def _gravity(name: str, wt: dict, wp: dict, total: float) -&gt; float:\n        w = wt.get(name, 0.0)\n        return (wp.get(name, 0.0) / w / total) if w &gt; 0 else float('inf')\n\n    sorted_q = sorted(\n        query_names,\n        key=lambda n: _gravity(n, q_weight, q_wpos, total_target_len),\n    )\n    sorted_t = sorted(\n        target_names,\n        key=lambda n: _gravity(n, t_weight, t_wpos, total_query_len),\n    )\n    return sorted_q, sorted_t\n</code></pre>"},{"location":"api/sequence_index/","title":"SequenceIndex","text":"<p>The <code>SequenceIndex</code> class is the primary interface for building and querying FM-index-backed sequence comparison data. It is implemented in Rust (via PyO3) for maximum performance.</p>"},{"location":"api/sequence_index/#class","title":"Class","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex","title":"<code>SequenceIndex</code>","text":"<p>FM-index backed sequence comparison engine.</p> <p>Builds FM-indexes and k-mer sets for DNA sequences read from FASTA files or provided directly, then supports fast pairwise k-mer coordinate lookup with optional sequential run merging.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The k-mer length to use for indexing and comparison.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; idx = SequenceIndex(k=10)\n&gt;&gt;&gt; idx.add_sequence(\"seq1\", \"ACGTACGTACGT\")\n&gt;&gt;&gt; idx.add_sequence(\"seq2\", \"TACGTACGTACG\")\n&gt;&gt;&gt; matches = idx.compare_sequences(\"seq1\", \"seq2\")\n</code></pre>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex-attributes","title":"Attributes","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.k","title":"<code>k</code>  <code>property</code>","text":"<p>The k-mer length used for this index.</p> <p>Returns:</p> Type Description <code>int</code> <p>The k-mer length supplied at construction time.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex-functions","title":"Functions","text":""},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__init__","title":"<code>__init__(k)</code>","text":"<p>Initialise an empty SequenceIndex.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>The k-mer length to use for indexing and comparison. Must be greater than zero.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>k</code> is zero.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.add_sequence","title":"<code>add_sequence(name, seq)</code>","text":"<p>Add a single sequence to the index.</p> <p>Builds an FM-index and collects the k-mer set for the given sequence, storing both for subsequent comparisons.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Unique identifier for the sequence.</p> required <code>seq</code> <code>str</code> <p>DNA sequence string. Uppercase is recommended; lowercase input is accepted and treated as uppercase.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the FM-index cannot be built (e.g., invalid characters).</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.load_fasta","title":"<code>load_fasta(path)</code>","text":"<p>Load all sequences from a FASTA or gzipped FASTA file.</p> <p>Parses the file with needletail (automatic gzip detection) and calls <code>add_sequence</code> for every record found.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a FASTA (<code>.fa</code>, <code>.fasta</code>) or gzipped FASTA (<code>.fa.gz</code>, <code>.fasta.gz</code>) file.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>Sequence names (record identifiers) that were added, in the order they appear in the file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be opened or parsed.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.sequence_names","title":"<code>sequence_names()</code>","text":"<p>Return all sequence names currently held in the index.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>Unordered list of sequence identifiers.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_kmer_set","title":"<code>get_kmer_set(name)</code>","text":"<p>Return the set of unique k-mers for a named sequence.</p> <p>Only k-mers composed entirely of the characters A, C, G, T are included (k-mers containing N or other IUPAC codes are excluded).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The sequence identifier.</p> required <p>Returns:</p> Type Description <code>set[str]</code> <p>The set of unique k-mer strings (length <code>k</code>) found in the sequence.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_sequence_length","title":"<code>get_sequence_length(name)</code>","text":"<p>Return the length of a named sequence in base pairs.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The sequence identifier.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The sequence length in base pairs (not including any internal sentinel character).</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If <code>name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.compare_sequences","title":"<code>compare_sequences(query_name, target_name, merge=True)</code>","text":"<p>Find shared k-mer matches between two sequences.</p> <p>Intersects the k-mer sets of the two sequences and looks up the coordinates of each shared k-mer in both FM-indexes.  Uses the smaller k-mer set as the probe for efficiency.</p> <p>When <code>merge=True</code> (default) consecutive k-mer hits on the same co-linear diagonal are merged into a single coordinate block. Results for each <code>(query_name, target_name, merge)</code> combination are cached; repeated calls with the same arguments are free.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence (defines the y-axis in a dotplot).</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence (defines the x-axis in a dotplot).</p> required <code>merge</code> <code>bool</code> <p>When <code>True</code> (default), merge consecutive co-linear k-mer hits into contiguous coordinate blocks.  When <code>False</code>, every individual k-mer hit is returned as its own block.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int]]</code> <p>List of <code>(query_start, query_end, target_start, target_end)</code> coordinate tuples.  All coordinates are 0-based; end positions are exclusive.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either <code>query_name</code> or <code>target_name</code> is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.get_paf","title":"<code>get_paf(query_name, target_name, merge=True)</code>","text":"<p>Return PAF-formatted alignment strings for a sequence pair.</p> <p>Calls <code>compare_sequences</code> internally (using the cache if available) and formats the result as 12-column PAF lines.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs before generating PAF lines.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>PAF lines as tab-separated strings.  Each line has 12 fields: query name, query length, query start, query end, strand, target name, target length, target start, target end, residue matches, alignment block length, mapping quality.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.precompute_all_pairs","title":"<code>precompute_all_pairs(merge=True)</code>","text":"<p>Pre-calculate comparisons for every ordered sequence pair.</p> <p>Iterates over all <code>(i, j)</code> pairs where <code>i != j</code> and calls <code>compare_sequences</code> for each, populating the cache.  Subsequent individual calls to <code>compare_sequences</code> for any pair will then be served from the cache.</p> <p>Parameters:</p> Name Type Description Default <code>merge</code> <code>bool</code> <p>Whether to merge consecutive co-linear k-mer runs.  Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>Ordered list of <code>(query_name, target_name)</code> pairs that were computed.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.compare_sequences_stranded","title":"<code>compare_sequences_stranded(query_name, target_name, merge=True)</code>","text":"<p>Find shared k-mer matches between two sequences on both strands.</p> <p>In addition to the forward (<code>+</code>) strand matches returned by :meth:<code>compare_sequences</code>, this method also searches for k-mers in the query whose reverse complement appears in the target, reporting those as <code>\"-\"</code> strand matches.</p> <p>Parameters:</p> Name Type Description Default <code>query_name</code> <code>str</code> <p>Name of the query sequence.</p> required <code>target_name</code> <code>str</code> <p>Name of the target sequence.</p> required <code>merge</code> <code>bool</code> <p>Whether to merge co-linear k-mer runs.  Forward runs are merged by diagonal; reverse runs are merged by anti-diagonal. Default is <code>True</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[tuple[int, int, int, int, str]]</code> <p>List of <code>(query_start, query_end, target_start, target_end, strand)</code> tuples.  Coordinates are 0-based; end positions are exclusive. <code>strand</code> is <code>\"+\"</code> for forward matches and <code>\"-\"</code> for reverse-complement matches.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If either sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.optimal_contig_order","title":"<code>optimal_contig_order(query_names, target_names)</code>","text":"<p>Return query and target contig names sorted for maximum collinearity.</p> <p>Uses the gravity-centre algorithm: for each query contig the gravity is the weighted mean of target mid-point positions (normalised by total target span) across all matches.  Query contigs with no matches are placed at the end.  The same algorithm is applied symmetrically to reorder the target contigs.</p> <p>Parameters:</p> Name Type Description Default <code>query_names</code> <code>list[str]</code> <p>Names of the query sequences to reorder.</p> required <code>target_names</code> <code>list[str]</code> <p>Names of the target sequences to use as the reference axis.</p> required <p>Returns:</p> Type Description <code>tuple[list[str], list[str]]</code> <p><code>(sorted_query_names, sorted_target_names)</code> ordered by ascending gravity centre.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If any sequence name is not present in the index.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.save","title":"<code>save(path)</code>","text":"<p>Serialise the index to a binary file.</p> <p>Stores the original sequence bytes and k-mer sets using bincode. The FM-index is rebuilt from the sequence bytes when the file is loaded, so the on-disk format is compact and version-independent.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Destination file path.  The file is created or overwritten.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be created or serialisation fails.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.load","title":"<code>load(path)</code>","text":"<p>Load sequences from a previously serialised index file.</p> <p>Deserialises sequence bytes and k-mer sets from a file written by <code>save</code>, then rebuilds the FM-index for each sequence in memory.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to a binary index file produced by <code>save</code>.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the file cannot be read, deserialisation fails, or the k-mer length stored in the file does not match <code>self.k</code>.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of sequences currently held in the index.</p> <p>Returns:</p> Type Description <code>int</code> <p>Count of indexed sequences.</p>"},{"location":"api/sequence_index/#rusty_dot._rusty_dot.SequenceIndex.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a concise string representation of the index.</p> <p>Returns:</p> Type Description <code>str</code> <p>A string of the form <code>SequenceIndex(k=&lt;k&gt;, sequences=&lt;n&gt;)</code>.</p>"},{"location":"tutorials/dotplot_tutorial/","title":"Dotplot Visualization Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import tempfile\nimport os\n\nfrom rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n</pre> import tempfile import os  from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter In\u00a0[\u00a0]: Copied! <pre># Helper to create a reverse complement\ndef revcomp(seq):\n    table = str.maketrans('ACGTacgt', 'TGCAtgca')\n    return seq.translate(table)[::-1]\n\n\nunit = 'ACGTACGTACGT'  # 12 bp repeat unit\nseq_a = unit * 10  # 120 bp  \u2014 the reference\nseq_b = 'T' + unit * 9 + 'T'  # 120 bp  \u2014 shifted by 1\nseq_c = revcomp(unit * 5) + unit * 5  # 120 bp  \u2014 half inverted\n\nidx = SequenceIndex(k=8)\nidx.add_sequence('reference', seq_a)\nidx.add_sequence('shifted', seq_b)\nidx.add_sequence('partial_inv', seq_c)\n\nprint(f'Index: {idx}')\n</pre> # Helper to create a reverse complement def revcomp(seq):     table = str.maketrans('ACGTacgt', 'TGCAtgca')     return seq.translate(table)[::-1]   unit = 'ACGTACGTACGT'  # 12 bp repeat unit seq_a = unit * 10  # 120 bp  \u2014 the reference seq_b = 'T' + unit * 9 + 'T'  # 120 bp  \u2014 shifted by 1 seq_c = revcomp(unit * 5) + unit * 5  # 120 bp  \u2014 half inverted  idx = SequenceIndex(k=8) idx.add_sequence('reference', seq_a) idx.add_sequence('shifted', seq_b) idx.add_sequence('partial_inv', seq_c)  print(f'Index: {idx}') In\u00a0[\u00a0]: Copied! <pre>plotter = DotPlotter(idx)\n\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    all_vs_all_path = fh.name\n\nplotter.plot(\n    output_path=all_vs_all_path,\n    title='All vs All',\n)\nprint(f'Saved: {all_vs_all_path}  ({os.path.getsize(all_vs_all_path)} bytes)')\n</pre> plotter = DotPlotter(idx)  with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     all_vs_all_path = fh.name  plotter.plot(     output_path=all_vs_all_path,     title='All vs All', ) print(f'Saved: {all_vs_all_path}  ({os.path.getsize(all_vs_all_path)} bytes)') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    subset_path = fh.name\n\nplotter.plot(\n    query_names=['reference', 'shifted'],\n    target_names=['partial_inv'],\n    output_path=subset_path,\n    title='Reference &amp; Shifted vs Partial Inversion',\n)\nprint(f'Subset plot saved: {subset_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     subset_path = fh.name  plotter.plot(     query_names=['reference', 'shifted'],     target_names=['partial_inv'],     output_path=subset_path,     title='Reference &amp; Shifted vs Partial Inversion', ) print(f'Subset plot saved: {subset_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    single_path = fh.name\n\nplotter.plot_single(\n    query_name='reference',\n    target_name='shifted',\n    output_path=single_path,\n    figsize=(5, 5),\n    title='reference vs shifted',\n)\nprint(f'Single-pair plot saved: {single_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     single_path = fh.name  plotter.plot_single(     query_name='reference',     target_name='shifted',     output_path=single_path,     figsize=(5, 5),     title='reference vs shifted', ) print(f'Single-pair plot saved: {single_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    styled_path = fh.name\n\nplotter.plot(\n    output_path=styled_path,\n    dot_size=1.5,\n    dot_color='crimson',\n    dpi=200,\n    title='Custom style: crimson, dpi=200',\n)\nprint(f'Styled plot saved: {styled_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     styled_path = fh.name  plotter.plot(     output_path=styled_path,     dot_size=1.5,     dot_color='crimson',     dpi=200,     title='Custom style: crimson, dpi=200', ) print(f'Styled plot saved: {styled_path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    unmerged_path = fh.name\n\nplotter.plot_single(\n    query_name='reference',\n    target_name='shifted',\n    output_path=unmerged_path,\n    merge=False,\n    title='reference vs shifted (unmerged k-mer hits)',\n)\nprint(f'Unmerged plot saved: {unmerged_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     unmerged_path = fh.name  plotter.plot_single(     query_name='reference',     target_name='shifted',     output_path=unmerged_path,     merge=False,     title='reference vs shifted (unmerged k-mer hits)', ) print(f'Unmerged plot saved: {unmerged_path}') In\u00a0[\u00a0]: Copied! <pre>for dpi in [72, 150, 300]:\n    with tempfile.NamedTemporaryFile(suffix=f'_dpi{dpi}.png', delete=False) as fh:\n        path = fh.name\n    plotter.plot_single(\n        'reference',\n        'shifted',\n        output_path=path,\n        dpi=dpi,\n        title=f'DPI = {dpi}',\n    )\n    size_kb = os.path.getsize(path) / 1024\n    print(f'DPI={dpi:4d}  file size={size_kb:.1f} kB  path={path}')\n</pre> for dpi in [72, 150, 300]:     with tempfile.NamedTemporaryFile(suffix=f'_dpi{dpi}.png', delete=False) as fh:         path = fh.name     plotter.plot_single(         'reference',         'shifted',         output_path=path,         dpi=dpi,         title=f'DPI = {dpi}',     )     size_kb = os.path.getsize(path) / 1024     print(f'DPI={dpi:4d}  file size={size_kb:.1f} kB  path={path}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    large_path = fh.name\n\nplotter.plot(\n    output_path=large_path,\n    figsize_per_panel=6.0,  # each panel is 6\u00d76 inches\n    title='Large panels (6 inches each)',\n)\nprint(f'Large-panel plot saved: {large_path}')\n</pre> with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     large_path = fh.name  plotter.plot(     output_path=large_path,     figsize_per_panel=6.0,  # each panel is 6\u00d76 inches     title='Large panels (6 inches each)', ) print(f'Large-panel plot saved: {large_path}')"},{"location":"tutorials/dotplot_tutorial/#dotplot-visualization-tutorial","title":"Dotplot Visualization Tutorial\u00b6","text":"<p>This notebook explores all visualisation options provided by the <code>DotPlotter</code> class.</p> <p>A dot plot (or dotplot) is a classic bioinformatics visualisation that displays all shared subsequences between two sequences.  Each dot represents a shared k-mer; diagonal runs of dots indicate conserved regions.  Inversions appear as anti-diagonal lines.</p>"},{"location":"tutorials/dotplot_tutorial/#1-build-a-test-index","title":"1. Build a test index\u00b6","text":"<p>We create three artificial sequences with different overlap patterns:</p>"},{"location":"tutorials/dotplot_tutorial/#2-all-vs-all-dotplot-default-settings","title":"2. All-vs-all dotplot (default settings)\u00b6","text":"<p><code>DotPlotter.plot()</code> without arguments produces an all-vs-all grid using all sequences in the index.</p>"},{"location":"tutorials/dotplot_tutorial/#3-subset-specific-query-and-target-sets","title":"3. Subset: specific query and target sets\u00b6","text":"<p>Pass <code>query_names</code> and <code>target_names</code> to restrict the grid to a subset of sequences.</p>"},{"location":"tutorials/dotplot_tutorial/#4-single-pair-dotplot","title":"4. Single-pair dotplot\u00b6","text":"<p><code>plot_single</code> renders one comparison panel with its own figure size and title.</p>"},{"location":"tutorials/dotplot_tutorial/#5-customising-dot-appearance","title":"5. Customising dot appearance\u00b6","text":"<p>All plotting methods accept <code>dot_size</code> and <code>dot_color</code> to control the appearance of match lines.</p>"},{"location":"tutorials/dotplot_tutorial/#6-controlling-merge-behaviour","title":"6. Controlling merge behaviour\u00b6","text":"<p>When <code>merge=True</code> (default), consecutive co-linear k-mer hits are merged into single lines. Set <code>merge=False</code> to display every individual k-mer hit as its own point \u2014 useful for inspecting raw k-mer density.</p>"},{"location":"tutorials/dotplot_tutorial/#7-output-resolution","title":"7. Output resolution\u00b6","text":"<p>Use the <code>dpi</code> parameter to control the resolution of the saved image. Higher DPI is better for print-quality figures.</p>"},{"location":"tutorials/dotplot_tutorial/#8-panel-size-control","title":"8. Panel size control\u00b6","text":"<p>For all-vs-all grids, <code>figsize_per_panel</code> controls the size (in inches) of each subplot panel.</p>"},{"location":"tutorials/dotplot_tutorial/#summary-of-dotplotter-parameters","title":"Summary of DotPlotter parameters\u00b6","text":"Parameter Default Description <code>query_names</code> <code>None</code> List of query sequence names (rows); <code>None</code> = all <code>target_names</code> <code>None</code> List of target sequence names (columns); <code>None</code> = all <code>output_path</code> <code>\"dotplot.png\"</code> Output file path <code>figsize_per_panel</code> <code>4.0</code> Inches per subplot panel (all-vs-all only) <code>figsize</code> <code>(6, 6)</code> Total figure size for <code>plot_single</code> <code>dot_size</code> <code>0.5</code> Line/marker size for each match <code>dot_color</code> <code>\"blue\"</code> Colour of match lines <code>merge</code> <code>True</code> Merge co-linear k-mer runs into blocks <code>title</code> <code>None</code> Figure title <code>dpi</code> <code>150</code> Output image resolution"},{"location":"tutorials/paf_workflow/","title":"PAF Workflow Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>import tempfile\nimport os\n\nfrom rusty_dot import SequenceIndex, py_coords_to_paf\nfrom rusty_dot.paf_io import (\n    PafRecord,\n    PafAlignment,\n    parse_paf_file,\n)\n</pre> import tempfile import os  from rusty_dot import SequenceIndex, py_coords_to_paf from rusty_dot.paf_io import (     PafRecord,     PafAlignment,     parse_paf_file, ) In\u00a0[\u00a0]: Copied! <pre># Build a small index\nidx = SequenceIndex(k=10)\nunit = 'ACGTACGTACGT'\nidx.add_sequence('query', unit * 8)  # 96 bp\nidx.add_sequence('target', ('T' + unit * 7 + 'T'))  # 98 bp\n\n# Get PAF lines\npaf_lines = idx.get_paf('query', 'target', merge=True)\nprint(f'Generated {len(paf_lines)} PAF lines')\nprint('\\nPAF columns (first record):')\ncol_names = [\n    'query_name',\n    'query_len',\n    'query_start',\n    'query_end',\n    'strand',\n    'target_name',\n    'target_len',\n    'target_start',\n    'target_end',\n    'residue_matches',\n    'block_len',\n    'mapq',\n]\nif paf_lines:\n    for col, val in zip(col_names, paf_lines[0].split('\\t')):\n        print(f'  {col:20s}: {val}')\n</pre> # Build a small index idx = SequenceIndex(k=10) unit = 'ACGTACGTACGT' idx.add_sequence('query', unit * 8)  # 96 bp idx.add_sequence('target', ('T' + unit * 7 + 'T'))  # 98 bp  # Get PAF lines paf_lines = idx.get_paf('query', 'target', merge=True) print(f'Generated {len(paf_lines)} PAF lines') print('\\nPAF columns (first record):') col_names = [     'query_name',     'query_len',     'query_start',     'query_end',     'strand',     'target_name',     'target_len',     'target_start',     'target_end',     'residue_matches',     'block_len',     'mapq', ] if paf_lines:     for col, val in zip(col_names, paf_lines[0].split('\\t')):         print(f'  {col:20s}: {val}') In\u00a0[\u00a0]: Copied! <pre>with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    paf_path = fh.name\n    for line in paf_lines:\n        fh.write(line + '\\n')\n\nprint(f'PAF file written: {paf_path}')\nprint(f'File size: {os.path.getsize(paf_path)} bytes')\n</pre> with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     paf_path = fh.name     for line in paf_lines:         fh.write(line + '\\n')  print(f'PAF file written: {paf_path}') print(f'File size: {os.path.getsize(paf_path)} bytes') In\u00a0[\u00a0]: Copied! <pre>records = list(parse_paf_file(paf_path))\nprint(f'Loaded {len(records)} records')\n\nif records:\n    rec = records[0]\n    print('\\nFirst record:')\n    print(\n        f'  query:   {rec.query_name}  [{rec.query_start}-{rec.query_end}]  len={rec.query_len}'\n    )\n    print(\n        f'  target:  {rec.target_name}  [{rec.target_start}-{rec.target_end}]  len={rec.target_len}'\n    )\n    print(f'  strand:  {rec.strand}')\n    print(f'  matches: {rec.residue_matches}')\n    print(f'  q_aligned_len: {rec.query_aligned_len}')\n    print(f'  t_aligned_len: {rec.target_aligned_len}')\n</pre> records = list(parse_paf_file(paf_path)) print(f'Loaded {len(records)} records')  if records:     rec = records[0]     print('\\nFirst record:')     print(         f'  query:   {rec.query_name}  [{rec.query_start}-{rec.query_end}]  len={rec.query_len}'     )     print(         f'  target:  {rec.target_name}  [{rec.target_start}-{rec.target_end}]  len={rec.target_len}'     )     print(f'  strand:  {rec.strand}')     print(f'  matches: {rec.residue_matches}')     print(f'  q_aligned_len: {rec.query_aligned_len}')     print(f'  t_aligned_len: {rec.target_aligned_len}') In\u00a0[\u00a0]: Copied! <pre>line = 'query\\t96\\t5\\t90\\t+\\ttarget\\t98\\t5\\t90\\t80\\t85\\t255\\ttp:A:P\\tcg:Z:10=5X20=3I30='\nrec = PafRecord.from_line(line)\n\nprint('Parsed PafRecord:')\nprint(f'  cigar:            {rec.cigar}')\nprint(f'  alignment_length: {rec.alignment_length}')\nprint(f'  n_matches:        {rec.n_matches}')\nprint(f'  n_mismatches:     {rec.n_mismatches}')\nprint(f'  n_gaps:           {rec.n_gaps}')\nprint(f'  n_gap_bases:      {rec.n_gap_bases}')\nprint(f'  tags:             {rec.tags}')\n</pre> line = 'query\\t96\\t5\\t90\\t+\\ttarget\\t98\\t5\\t90\\t80\\t85\\t255\\ttp:A:P\\tcg:Z:10=5X20=3I30=' rec = PafRecord.from_line(line)  print('Parsed PafRecord:') print(f'  cigar:            {rec.cigar}') print(f'  alignment_length: {rec.alignment_length}') print(f'  n_matches:        {rec.n_matches}') print(f'  n_mismatches:     {rec.n_mismatches}') print(f'  n_gaps:           {rec.n_gaps}') print(f'  n_gap_bases:      {rec.n_gap_bases}') print(f'  tags:             {rec.tags}') In\u00a0[\u00a0]: Copied! <pre>print(rec.to_line())\n</pre> print(rec.to_line()) In\u00a0[\u00a0]: Copied! <pre># Load from the PAF file we created earlier\naln = PafAlignment.from_file(paf_path)\nprint(aln)\nprint(f'Query names:  {aln.query_names}')\nprint(f'Target names: {aln.target_names}')\n</pre> # Load from the PAF file we created earlier aln = PafAlignment.from_file(paf_path) print(aln) print(f'Query names:  {aln.query_names}') print(f'Target names: {aln.target_names}') In\u00a0[\u00a0]: Copied! <pre># Construct from a list of records\naln2 = PafAlignment.from_records(records)\nprint(f'from_records: {aln2}')\n</pre> # Construct from a list of records aln2 = PafAlignment.from_records(records) print(f'from_records: {aln2}') In\u00a0[\u00a0]: Copied! <pre># Filter to a specific query\nfiltered_q = aln.filter_by_query(['query'])\nprint(f\"filter_by_query(['query']): {filtered_q}\")\n\n# Filter to a specific target\nfiltered_t = aln.filter_by_target(['target'])\nprint(f\"filter_by_target(['target']): {filtered_t}\")\n</pre> # Filter to a specific query filtered_q = aln.filter_by_query(['query']) print(f\"filter_by_query(['query']): {filtered_q}\")  # Filter to a specific target filtered_t = aln.filter_by_target(['target']) print(f\"filter_by_target(['target']): {filtered_t}\") In\u00a0[\u00a0]: Copied! <pre># Build a multi-contig index to demonstrate reordering\nidx_multi = SequenceIndex(k=8)\nunit = 'ACGTACGTACGT'\nidx_multi.add_sequence('qA', unit * 5)\nidx_multi.add_sequence('qB', 'GCGCGCGCGCGCGCGCGCGC' * 3)\nidx_multi.add_sequence('tA', unit * 5)\nidx_multi.add_sequence('tB', ('T' + unit) * 4)\n\n# Write all-vs-all PAF\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    multi_paf_path = fh.name\n    for q in ['qA', 'qB']:\n        for t in ['tA', 'tB']:\n            for line in idx_multi.get_paf(q, t):\n                fh.write(line + '\\n')\n\naln_multi = PafAlignment.from_file(multi_paf_path)\nprint(f'Multi-contig alignment: {aln_multi}')\n\nq_sorted, t_sorted = aln_multi.reorder_contigs(\n    query_names=['qA', 'qB'],\n    target_names=['tA', 'tB'],\n)\nprint(f'Reordered queries:  {q_sorted}')\nprint(f'Reordered targets:  {t_sorted}')\n</pre> # Build a multi-contig index to demonstrate reordering idx_multi = SequenceIndex(k=8) unit = 'ACGTACGTACGT' idx_multi.add_sequence('qA', unit * 5) idx_multi.add_sequence('qB', 'GCGCGCGCGCGCGCGCGCGC' * 3) idx_multi.add_sequence('tA', unit * 5) idx_multi.add_sequence('tB', ('T' + unit) * 4)  # Write all-vs-all PAF with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     multi_paf_path = fh.name     for q in ['qA', 'qB']:         for t in ['tA', 'tB']:             for line in idx_multi.get_paf(q, t):                 fh.write(line + '\\n')  aln_multi = PafAlignment.from_file(multi_paf_path) print(f'Multi-contig alignment: {aln_multi}')  q_sorted, t_sorted = aln_multi.reorder_contigs(     query_names=['qA', 'qB'],     target_names=['tA', 'tB'], ) print(f'Reordered queries:  {q_sorted}') print(f'Reordered targets:  {t_sorted}') In\u00a0[\u00a0]: Copied! <pre>matches = [\n    (0, 50, 10, 60),\n    (55, 90, 65, 100),\n]\n\npaf_strings = py_coords_to_paf(\n    matches,\n    query_name='my_query',\n    query_len=100,\n    target_name='my_target',\n    target_len=120,\n)\n\nfor line in paf_strings:\n    print(line)\n</pre> matches = [     (0, 50, 10, 60),     (55, 90, 65, 100), ]  paf_strings = py_coords_to_paf(     matches,     query_name='my_query',     query_len=100,     target_name='my_target',     target_len=120, )  for line in paf_strings:     print(line) In\u00a0[\u00a0]: Copied! <pre># Pre-compute to populate the cache\nidx_multi.precompute_all_pairs(merge=True)\n\nq_order, t_order = idx_multi.optimal_contig_order(\n    query_names=['qA', 'qB'],\n    target_names=['tA', 'tB'],\n)\nprint(f'Optimal query order:  {q_order}')\nprint(f'Optimal target order: {t_order}')\n</pre> # Pre-compute to populate the cache idx_multi.precompute_all_pairs(merge=True)  q_order, t_order = idx_multi.optimal_contig_order(     query_names=['qA', 'qB'],     target_names=['tA', 'tB'], ) print(f'Optimal query order:  {q_order}') print(f'Optimal target order: {t_order}')"},{"location":"tutorials/paf_workflow/#paf-workflow-tutorial","title":"PAF Workflow Tutorial\u00b6","text":"<p>This notebook demonstrates the full PAF (Pairwise mApping Format) workflow in rusty-dot:</p> <ol> <li>Generating PAF output from a <code>SequenceIndex</code></li> <li>Writing PAF output to a file</li> <li>Reading PAF files back with <code>parse_paf_file</code> and <code>PafAlignment</code></li> <li>Parsing CIGAR strings for alignment statistics</li> <li>Filtering and reordering contigs with <code>PafAlignment.reorder_contigs</code></li> <li>Using the low-level <code>py_coords_to_paf</code> function</li> </ol> <p>PAF is a tab-separated, 12-column format used by many alignment tools.  It is the primary output format of rusty-dot.</p>"},{"location":"tutorials/paf_workflow/#1-generate-paf-output-from-a-sequenceindex","title":"1. Generate PAF output from a SequenceIndex\u00b6","text":"<p>The easiest way to produce PAF lines is <code>SequenceIndex.get_paf</code>.</p>"},{"location":"tutorials/paf_workflow/#2-write-paf-to-a-file","title":"2. Write PAF to a file\u00b6","text":"<p>PAF is a plain text format \u2014 just write each line with a newline.</p>"},{"location":"tutorials/paf_workflow/#3-read-a-paf-file-with-parse_paf_file","title":"3. Read a PAF file with parse_paf_file\u00b6","text":"<p><code>parse_paf_file</code> is a generator that yields <code>PafRecord</code> objects one at a time. Comment lines (starting with <code>#</code>) and blank lines are skipped.</p>"},{"location":"tutorials/paf_workflow/#4-parsing-a-paf-record-from-a-string","title":"4. Parsing a PAF record from a string\u00b6","text":"<p><code>PafRecord.from_line</code> parses a single PAF line string.</p>"},{"location":"tutorials/paf_workflow/#5-serialise-a-pafrecord-back-to-a-string","title":"5. Serialise a PafRecord back to a string\u00b6","text":"<p><code>to_line()</code> recreates the 12-column PAF string (tags are not re-emitted).</p>"},{"location":"tutorials/paf_workflow/#6-pafalignment-collection-with-contig-reordering","title":"6. PafAlignment \u2014 collection with contig reordering\u00b6","text":"<p><code>PafAlignment</code> wraps a list of <code>PafRecord</code> objects and provides filtering and gravity-based contig reordering.</p>"},{"location":"tutorials/paf_workflow/#filtering","title":"Filtering\u00b6","text":""},{"location":"tutorials/paf_workflow/#gravity-based-contig-reordering","title":"Gravity-based contig reordering\u00b6","text":"<p><code>reorder_contigs</code> sorts query and target names so that a subsequent dotplot shows maximum collinearity.  Each contig is assigned a gravity equal to the weighted mean position of its alignment blocks on the opposing axis.</p>"},{"location":"tutorials/paf_workflow/#7-low-level-py_coords_to_paf","title":"7. Low-level: py_coords_to_paf\u00b6","text":"<p><code>py_coords_to_paf</code> converts raw coordinate tuples to PAF strings without going through a <code>SequenceIndex</code>.  It is useful when you have coordinate data from another source.</p>"},{"location":"tutorials/paf_workflow/#8-using-sequenceindexoptimal_contig_order","title":"8. Using SequenceIndex.optimal_contig_order\u00b6","text":"<p>The <code>SequenceIndex</code> also exposes a built-in gravity-based ordering via <code>optimal_contig_order</code>, which uses the cached comparison results.</p>"},{"location":"tutorials/paf_workflow/#summary","title":"Summary\u00b6","text":"Task API Generate PAF lines <code>SequenceIndex.get_paf(query, target)</code> Parse a PAF file <code>parse_paf_file(path)</code> or <code>PafAlignment.from_file(path)</code> Parse a single line <code>PafRecord.from_line(line)</code> Serialise a record <code>PafRecord.to_line()</code> Filter records <code>PafAlignment.filter_by_query(names)</code> / <code>filter_by_target(names)</code> Reorder contigs <code>PafAlignment.reorder_contigs()</code> or <code>SequenceIndex.optimal_contig_order()</code> Convert coords to PAF <code>py_coords_to_paf(matches, ...)</code>"},{"location":"tutorials/quickstart/","title":"Quick Start Tutorial","text":"In\u00a0[\u00a0]: Copied! <pre>from rusty_dot import SequenceIndex\nfrom rusty_dot.dotplot import DotPlotter\n\nprint('rusty-dot imported successfully')\n</pre> from rusty_dot import SequenceIndex from rusty_dot.dotplot import DotPlotter  print('rusty-dot imported successfully') In\u00a0[\u00a0]: Copied! <pre># Create an index with k=10\nidx = SequenceIndex(k=10)\nprint(idx)  # SequenceIndex(k=10, sequences=0)\n</pre> # Create an index with k=10 idx = SequenceIndex(k=10) print(idx)  # SequenceIndex(k=10, sequences=0) In\u00a0[\u00a0]: Copied! <pre># Two sequences with a shared region\nseq_a = 'ACGTACGTACGTACGTACGT' * 5  # 100 bp\nseq_b = 'TACGTACGTACGTACGTACG' * 5  # 100 bp (shifted by 1 bp)\nseq_c = 'GCGCGCGCGCGCGCGCGCGC' * 5  # 100 bp (different content)\n\nidx.add_sequence('seq_a', seq_a)\nidx.add_sequence('seq_b', seq_b)\nidx.add_sequence('seq_c', seq_c)\n\nprint(f'Indexed sequences: {idx.sequence_names()}')\nprint(f'Total sequences: {len(idx)}')\n</pre> # Two sequences with a shared region seq_a = 'ACGTACGTACGTACGTACGT' * 5  # 100 bp seq_b = 'TACGTACGTACGTACGTACG' * 5  # 100 bp (shifted by 1 bp) seq_c = 'GCGCGCGCGCGCGCGCGCGC' * 5  # 100 bp (different content)  idx.add_sequence('seq_a', seq_a) idx.add_sequence('seq_b', seq_b) idx.add_sequence('seq_c', seq_c)  print(f'Indexed sequences: {idx.sequence_names()}') print(f'Total sequences: {len(idx)}') In\u00a0[\u00a0]: Copied! <pre># How many unique 10-mers does each sequence have?\nfor name in idx.sequence_names():\n    kset = idx.get_kmer_set(name)\n    print(\n        f'{name}: {len(kset)} unique k-mers, length={idx.get_sequence_length(name)} bp'\n    )\n</pre> # How many unique 10-mers does each sequence have? for name in idx.sequence_names():     kset = idx.get_kmer_set(name)     print(         f'{name}: {len(kset)} unique k-mers, length={idx.get_sequence_length(name)} bp'     ) In\u00a0[\u00a0]: Copied! <pre>matches = idx.compare_sequences('seq_a', 'seq_b', merge=True)\nprint(f'seq_a vs seq_b: {len(matches)} match blocks')\nfor m in matches[:5]:\n    q_start, q_end, t_start, t_end = m\n    print(\n        f'  query [{q_start}-{q_end}]  target [{t_start}-{t_end}]  length={q_end - q_start}'\n    )\n</pre> matches = idx.compare_sequences('seq_a', 'seq_b', merge=True) print(f'seq_a vs seq_b: {len(matches)} match blocks') for m in matches[:5]:     q_start, q_end, t_start, t_end = m     print(         f'  query [{q_start}-{q_end}]  target [{t_start}-{t_end}]  length={q_end - q_start}'     ) In\u00a0[\u00a0]: Copied! <pre># Fewer matches between unrelated sequences\nmatches_ac = idx.compare_sequences('seq_a', 'seq_c', merge=True)\nprint(f'seq_a vs seq_c: {len(matches_ac)} match blocks')\n</pre> # Fewer matches between unrelated sequences matches_ac = idx.compare_sequences('seq_a', 'seq_c', merge=True) print(f'seq_a vs seq_c: {len(matches_ac)} match blocks') In\u00a0[\u00a0]: Copied! <pre>stranded = idx.compare_sequences_stranded('seq_a', 'seq_b', merge=True)\nfwd = [m for m in stranded if m[4] == '+']\nrev = [m for m in stranded if m[4] == '-']\nprint(f'Forward matches: {len(fwd)}, Reverse-complement matches: {len(rev)}')\n</pre> stranded = idx.compare_sequences_stranded('seq_a', 'seq_b', merge=True) fwd = [m for m in stranded if m[4] == '+'] rev = [m for m in stranded if m[4] == '-'] print(f'Forward matches: {len(fwd)}, Reverse-complement matches: {len(rev)}') In\u00a0[\u00a0]: Copied! <pre>paf_lines = idx.get_paf('seq_a', 'seq_b', merge=True)\nprint(f'PAF lines: {len(paf_lines)}')\nprint('\\nFirst PAF line:')\nif paf_lines:\n    fields = paf_lines[0].split('\\t')\n    labels = [\n        'query',\n        'q_len',\n        'q_start',\n        'q_end',\n        'strand',\n        'target',\n        't_len',\n        't_start',\n        't_end',\n        'matches',\n        'block_len',\n        'mapq',\n    ]\n    for label, value in zip(labels, fields):\n        print(f'  {label:12s}: {value}')\n</pre> paf_lines = idx.get_paf('seq_a', 'seq_b', merge=True) print(f'PAF lines: {len(paf_lines)}') print('\\nFirst PAF line:') if paf_lines:     fields = paf_lines[0].split('\\t')     labels = [         'query',         'q_len',         'q_start',         'q_end',         'strand',         'target',         't_len',         't_start',         't_end',         'matches',         'block_len',         'mapq',     ]     for label, value in zip(labels, fields):         print(f'  {label:12s}: {value}') In\u00a0[\u00a0]: Copied! <pre># Save PAF output to a file\nimport tempfile\nimport os\n\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:\n    paf_path = fh.name\n    for line in paf_lines:\n        fh.write(line + '\\n')\n\nprint(f'PAF saved to: {paf_path}')\nprint(f'File size: {os.path.getsize(paf_path)} bytes')\n</pre> # Save PAF output to a file import tempfile import os  with tempfile.NamedTemporaryFile(mode='w', suffix='.paf', delete=False) as fh:     paf_path = fh.name     for line in paf_lines:         fh.write(line + '\\n')  print(f'PAF saved to: {paf_path}') print(f'File size: {os.path.getsize(paf_path)} bytes') In\u00a0[\u00a0]: Copied! <pre>import tempfile\nimport gzip\n\nfasta_content = '&gt;seq1\\nACGTACGTACGTACGTACGT\\n&gt;seq2\\nTACGTACGTACGTACGTACG\\n'\n\n# Plain FASTA\nwith tempfile.NamedTemporaryFile(mode='w', suffix='.fasta', delete=False) as fh:\n    fh.write(fasta_content)\n    plain_path = fh.name\n\n# Gzipped FASTA\nwith tempfile.NamedTemporaryFile(suffix='.fasta.gz', delete=False) as fh:\n    gz_path = fh.name\nwith gzip.open(gz_path, 'wt') as fh:\n    fh.write(fasta_content)\n\n# Load into a fresh index\nidx2 = SequenceIndex(k=10)\nnames = idx2.load_fasta(plain_path)\nprint(f'Loaded from plain FASTA: {names}')\n\nidx3 = SequenceIndex(k=10)\nnames_gz = idx3.load_fasta(gz_path)\nprint(f'Loaded from gzipped FASTA: {names_gz}')\n</pre> import tempfile import gzip  fasta_content = '&gt;seq1\\nACGTACGTACGTACGTACGT\\n&gt;seq2\\nTACGTACGTACGTACGTACG\\n'  # Plain FASTA with tempfile.NamedTemporaryFile(mode='w', suffix='.fasta', delete=False) as fh:     fh.write(fasta_content)     plain_path = fh.name  # Gzipped FASTA with tempfile.NamedTemporaryFile(suffix='.fasta.gz', delete=False) as fh:     gz_path = fh.name with gzip.open(gz_path, 'wt') as fh:     fh.write(fasta_content)  # Load into a fresh index idx2 = SequenceIndex(k=10) names = idx2.load_fasta(plain_path) print(f'Loaded from plain FASTA: {names}')  idx3 = SequenceIndex(k=10) names_gz = idx3.load_fasta(gz_path) print(f'Loaded from gzipped FASTA: {names_gz}') In\u00a0[\u00a0]: Copied! <pre>import tempfile\n\n# Save\nwith tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as fh:\n    idx_path = fh.name\n\nidx.save(idx_path)\nprint(f'Index saved to: {idx_path}')\nprint(f'File size: {os.path.getsize(idx_path)} bytes')\n\n# Load into a new index (k must match)\nidx_loaded = SequenceIndex(k=10)\nidx_loaded.load(idx_path)\nprint(f'Loaded index: {idx_loaded}')\nprint(f'Sequences: {idx_loaded.sequence_names()}')\n</pre> import tempfile  # Save with tempfile.NamedTemporaryFile(suffix='.bin', delete=False) as fh:     idx_path = fh.name  idx.save(idx_path) print(f'Index saved to: {idx_path}') print(f'File size: {os.path.getsize(idx_path)} bytes')  # Load into a new index (k must match) idx_loaded = SequenceIndex(k=10) idx_loaded.load(idx_path) print(f'Loaded index: {idx_loaded}') print(f'Sequences: {idx_loaded.sequence_names()}') In\u00a0[\u00a0]: Copied! <pre>pairs = idx.precompute_all_pairs(merge=True)\nprint(f'Pre-computed {len(pairs)} pairs:')\nfor q, t in pairs:\n    print(f'  {q} vs {t}')\n</pre> pairs = idx.precompute_all_pairs(merge=True) print(f'Pre-computed {len(pairs)} pairs:') for q, t in pairs:     print(f'  {q} vs {t}') In\u00a0[\u00a0]: Copied! <pre>import tempfile\n\nplotter = DotPlotter(idx)\n\nwith tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:\n    out_path = fh.name\n\nplotter.plot(output_path=out_path, title='Quick Start Dotplot')\nprint(f'Dotplot saved to: {out_path}')\n</pre> import tempfile  plotter = DotPlotter(idx)  with tempfile.NamedTemporaryFile(suffix='.png', delete=False) as fh:     out_path = fh.name  plotter.plot(output_path=out_path, title='Quick Start Dotplot') print(f'Dotplot saved to: {out_path}')"},{"location":"tutorials/quickstart/#quick-start-tutorial","title":"Quick Start Tutorial\u00b6","text":"<p>This notebook demonstrates the core workflow of rusty-dot: building a sequence index, finding shared k-mer matches, generating PAF-format alignments, and visualising results as a dotplot.</p>"},{"location":"tutorials/quickstart/#prerequisites","title":"Prerequisites\u00b6","text":"<p>Install rusty-dot following the Installation guide, then run:</p> <pre>pip install jupyter\n</pre>"},{"location":"tutorials/quickstart/#1-import-the-package","title":"1. Import the package\u00b6","text":""},{"location":"tutorials/quickstart/#2-build-a-sequenceindex","title":"2. Build a SequenceIndex\u00b6","text":"<p><code>SequenceIndex</code> is the core class.  You supply the k-mer length <code>k</code> at construction time. A larger <code>k</code> reduces spurious matches but may miss shorter conserved regions.</p>"},{"location":"tutorials/quickstart/#3-add-sequences-directly","title":"3. Add sequences directly\u00b6","text":"<p>Use <code>add_sequence(name, seq)</code> to add individual sequences. These are stored in-memory and indexed immediately.</p>"},{"location":"tutorials/quickstart/#4-query-the-index","title":"4. Query the index\u00b6","text":""},{"location":"tutorials/quickstart/#4a-inspect-k-mer-sets","title":"4a. Inspect k-mer sets\u00b6","text":""},{"location":"tutorials/quickstart/#4b-find-shared-k-mer-matches","title":"4b. Find shared k-mer matches\u00b6","text":"<p><code>compare_sequences</code> intersects the k-mer sets and returns <code>(query_start, query_end, target_start, target_end)</code> tuples.</p>"},{"location":"tutorials/quickstart/#4c-stranded-matches","title":"4c. Stranded matches\u00b6","text":"<p><code>compare_sequences_stranded</code> additionally searches for reverse-complement matches, returning a 5-tuple <code>(q_start, q_end, t_start, t_end, strand)</code> where strand is <code>\"+\"</code> or <code>\"-\"</code>.</p>"},{"location":"tutorials/quickstart/#5-paf-output","title":"5. PAF output\u00b6","text":"<p>PAF (Pairwise mApping Format) is a standard tab-separated format for alignment records. <code>get_paf</code> returns a list of 12-column PAF strings.</p>"},{"location":"tutorials/quickstart/#6-load-from-fasta-files","title":"6. Load from FASTA files\u00b6","text":"<p><code>load_fasta</code> reads plain or gzipped FASTA files with automatic format detection.</p>"},{"location":"tutorials/quickstart/#7-save-and-load-the-index","title":"7. Save and load the index\u00b6","text":"<p>Indexes can be serialised to disk and reloaded, avoiding the need to reprocess large FASTA files.</p>"},{"location":"tutorials/quickstart/#8-pre-compute-all-pairs","title":"8. Pre-compute all pairs\u00b6","text":"<p>For repeated queries over the same dataset, <code>precompute_all_pairs</code> fills the result cache for every ordered <code>(i, j)</code> pair in one go.</p>"},{"location":"tutorials/quickstart/#9-simple-dotplot","title":"9. Simple dotplot\u00b6","text":"<p>The <code>DotPlotter</code> class wraps the index to generate publication-ready dotplot images. See the Dotplot Visualization tutorial for full details.</p>"},{"location":"tutorials/quickstart/#next-steps","title":"Next steps\u00b6","text":"<ul> <li>Dotplot Visualization tutorial \u2014 all plot customisation options.</li> <li>PAF Workflow tutorial \u2014 loading PAF files, CIGAR parsing, and contig reordering.</li> <li>API Reference \u2014 complete documentation for every class and function.</li> </ul>"}]}